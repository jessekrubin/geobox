// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
import typia from 'typia';
import type { BBox, BBox2d, BBox3d, Coordinate, Coordinate2d, Coordinate3d, CoordinateReferenceSystem, CoordinateReferenceSystemNullable, DeckglTilejson, Feature, FeatureCollection, FeatureCollectionType, FeatureGeneric, FeatureGenericGeometry, FeatureGenericOptions, FeatureOptions, FeatureType, GeoJsonProperties, Geometry, Geometry2d, Geometry3d, GeometryCollectionType, GeometryType, Geostats, GeostatsAttribute, GeostatsLayer, Latitude, LatitudeWgs84, LinearRing, LineStringCoordinates, LineStringGeometry, LineStringGeometry2d, LineStringGeometry3d, LineStringGeometryType, LinkedCoordinateReferenceSystem, Longitude, LongitudeWgs84, MbtilesMetadata, MbtilesMetadataRow, MbtilesTilesRow, MultiLineStringCoordinates, MultiLineStringGeometry, MultiLineStringGeometry2d, MultiLineStringGeometry3d, MultiLineStringGeometryType, MultiPointCoordinates, MultiPointGeometry, MultiPointGeometry2d, MultiPointGeometry3d, MultiPointGeometryType, MultiPolygonCoordinates, MultiPolygonGeometry, MultiPolygonGeometry2d, MultiPolygonGeometry3d, MultiPolygonGeometryType, NamedCoordinateReferenceSystem, PointCoordinates, PointFeature, PointGeometry, PointGeometry2d, PointGeometry3d, PointGeometryType, PolygonCoordinates, PolygonGeometry, PolygonGeometry2d, PolygonGeometry3d, PolygonGeometryType, SimpleStyleProperties, Tilejson300, Tilejson300Raster, Tilejson300Vector, TilejsonCommon, TilejsonRasterFormat, TilejsonVectorFormat, TilejsonVectorLayer, TilejsonVectorLayers, } from '@jsse/geotypes';
// BBox
export const assertBBox = (input: any): BBox => {
    const __is = (input: any): input is BBox => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox = (input: any, _exceptionable: boolean = true): input is BBox => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isBBox = (input: any): input is BBox => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomBBox = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<BBox> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyBBox = (input: BBox): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
        if (Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
        if (Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
        if (Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number])",
            value: input
        });
    })();
};
export const validateBBox = (input: any): typia.IValidation<BBox> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// BBox2d
export const assertBBox2d = (input: any): BBox2d => {
    const __is = (input: any): input is BBox2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox2d = (input: any, _exceptionable: boolean = true): input is BBox2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isBBox2d = (input: any): input is BBox2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomBBox2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<BBox2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyBBox2d = (input: BBox2d): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
        if (Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number])",
            value: input
        });
    })();
};
export const validateBBox2d = (input: any): typia.IValidation<BBox2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// BBox3d
export const assertBBox3d = (input: any): BBox3d => {
    const __is = (input: any): input is BBox3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox3d = (input: any, _exceptionable: boolean = true): input is BBox3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isBBox3d = (input: any): input is BBox3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomBBox3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<BBox3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyBBox3d = (input: BBox3d): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
        if (Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
            value: input
        });
    })();
};
export const validateBBox3d = (input: any): typia.IValidation<BBox3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate
export const assertCoordinate = (input: any): Coordinate => {
    const __is = (input: any): input is Coordinate => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate = (input: any, _exceptionable: boolean = true): input is Coordinate => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isCoordinate = (input: any): input is Coordinate => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomCoordinate = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Coordinate> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyCoordinate = (input: Coordinate): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input
        });
    })();
};
export const validateCoordinate = (input: any): typia.IValidation<Coordinate> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate2d
export const assertCoordinate2d = (input: any): Coordinate2d => {
    const __is = (input: any): input is Coordinate2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate2d = (input: any, _exceptionable: boolean = true): input is Coordinate2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isCoordinate2d = (input: any): input is Coordinate2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomCoordinate2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Coordinate2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyCoordinate2d = (input: Coordinate2d): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input
        });
    })();
};
export const validateCoordinate2d = (input: any): typia.IValidation<Coordinate2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate3d
export const assertCoordinate3d = (input: any): Coordinate3d => {
    const __is = (input: any): input is Coordinate3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate3d = (input: any, _exceptionable: boolean = true): input is Coordinate3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isCoordinate3d = (input: any): input is Coordinate3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomCoordinate3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Coordinate3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyCoordinate3d = (input: Coordinate3d): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input
        });
    })();
};
export const validateCoordinate3d = (input: any): typia.IValidation<Coordinate3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// CoordinateReferenceSystem
export const assertCoordinateReferenceSystem = (input: any): CoordinateReferenceSystem => {
    const __is = (input: any): input is CoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io2(input);
            else if ("name" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is CoordinateReferenceSystem => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao1(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinateReferenceSystem = (input: any, _exceptionable: boolean = true): input is CoordinateReferenceSystem => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isCoordinateReferenceSystem = (input: any): input is CoordinateReferenceSystem => {
    const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io2(input);
        else if ("name" === input.type)
            return $io0(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomCoordinateReferenceSystem = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<CoordinateReferenceSystem> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro1(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro3(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $pick([
        () => $ro2(),
        () => $ro0()
    ])();
};
export const stringifyCoordinateReferenceSystem = (input: CoordinateReferenceSystem): string => {
    const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties));
    const $io1 = (input: any): boolean => "string" === typeof input.name;
    const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties));
    const $io3 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so2(input);
        else if ("name" === input.type)
            return $so0(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $su0(input);
};
export const validateCoordinateReferenceSystem = (input: any): typia.IValidation<CoordinateReferenceSystem> => {
    const errors = [] as any[];
    const __is = (input: any): input is CoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io2(input);
            else if ("name" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is CoordinateReferenceSystem => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo1(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// CoordinateReferenceSystemNullable
export const assertCoordinateReferenceSystemNullable = (input: any): CoordinateReferenceSystemNullable => {
    const __is = (input: any): input is CoordinateReferenceSystemNullable => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io2(input);
            else if ("name" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return null === input || undefined === input || "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is CoordinateReferenceSystemNullable => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao1(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return null === input || undefined === input || ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinateReferenceSystemNullable = (input: any, _exceptionable: boolean = true): input is CoordinateReferenceSystemNullable => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return null === input || undefined === input || "object" === typeof input && null !== input && $iu0(input, true);
};
export const isCoordinateReferenceSystemNullable = (input: any): input is CoordinateReferenceSystemNullable => {
    const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io2(input);
        else if ("name" === input.type)
            return $io0(input);
        else
            return false;
    })();
    return null === input || undefined === input || "object" === typeof input && null !== input && $iu0(input);
};
export const randomCoordinateReferenceSystemNullable = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<CoordinateReferenceSystemNullable> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro1(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro3(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $pick([
        () => undefined,
        () => null,
        () => $ro2(),
        () => $ro0()
    ])();
};
export const stringifyCoordinateReferenceSystemNullable = (input: CoordinateReferenceSystemNullable): string => {
    const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties));
    const $io1 = (input: any): boolean => "string" === typeof input.name;
    const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties));
    const $io3 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so2(input);
        else if ("name" === input.type)
            return $so0(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return undefined !== input ? null !== input ? $su0(input) : "null" : undefined;
};
export const validateCoordinateReferenceSystemNullable = (input: any): typia.IValidation<CoordinateReferenceSystemNullable> => {
    const errors = [] as any[];
    const __is = (input: any): input is CoordinateReferenceSystemNullable => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io2 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io2(input);
            else if ("name" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return null === input || undefined === input || "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is CoordinateReferenceSystemNullable => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo1(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return null === input || undefined === input || ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// DeckglTilejson
export const assertDeckglTilejson = (input: any): DeckglTilejson => {
    const __is = (input: any): input is DeckglTilejson => {
        const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is DeckglTilejson => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index1 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "Array<any>",
                value: input.vector_layers
            })) && (undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(string | undefined)",
                value: input.attribution
            })) && (undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(string | undefined)",
                value: input.scheme
            })) && (undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(number | undefined)",
                value: input.maxzoom
            })) && (undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(number | undefined)",
                value: input.minzoom
            })) && (undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(string | undefined)",
                value: input.version
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsDeckglTilejson = (input: any, _exceptionable: boolean = true): input is DeckglTilejson => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version) && (3 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["tilejson", "tiles", "vector_layers", "attribution", "scheme", "maxzoom", "minzoom", "version"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isDeckglTilejson = (input: any): input is DeckglTilejson => {
    const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomDeckglTilejson = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<DeckglTilejson> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        vector_layers: (generator?.array ?? $generator.array)(() => "any type used..."),
        attribution: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        version: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])()
    });
    return $ro0();
};
export const stringifyDeckglTilejson = (input: DeckglTilejson): string => {
    const $string = (typia.json.createStringify as any).string;
    const $so0 = (input: any): any => `{${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? $string(input.attribution) : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? $string(input.scheme) : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? input.maxzoom : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? input.minzoom : undefined},`}${undefined === input.version ? "" : `"version":${undefined !== input.version ? $string(input.version) : undefined},`}"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`},"vector_layers":${`[${input.vector_layers.map((elem: any) => undefined !== elem ? JSON.stringify(elem) : "null").join(",")}]`}}`;
    return $so0(input);
};
export const validateDeckglTilejson = (input: any): typia.IValidation<DeckglTilejson> => {
    const errors = [] as any[];
    const __is = (input: any): input is DeckglTilejson => {
        const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is DeckglTilejson => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index1: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index1 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "Array<any>",
                    value: input.vector_layers
                }), undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(string | undefined)",
                    value: input.attribution
                }), undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(string | undefined)",
                    value: input.scheme
                }), undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(number | undefined)",
                    value: input.maxzoom
                }), undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(number | undefined)",
                    value: input.minzoom
                }), undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(string | undefined)",
                    value: input.version
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Feature
export const assertFeature = (input: any): Feature => {
    const __is = (input: any): input is Feature => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu1(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io11(input.properties));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
        const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io11 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io9(input);
            else if ("name" === input.type)
                return $io7(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Feature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ap1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && $au0(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            })) && (undefined === input.bbox || (Array.isArray(input.bbox) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && ($ap0(input.bbox, _path + ".bbox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.bbox
            })) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && (null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && $au1(input.crs, _path + ".crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao11(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap1(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap1(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap1(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap1(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap1(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap1(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap1(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap1(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap1(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap1(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap1(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap1(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap1(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap1(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao8(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao10(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $ao11 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            const $au1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao9(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao7(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeature = (input: any, _exceptionable: boolean = true): input is Feature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox, true && _exceptionable) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu1(input.crs, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io11(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "id", "bbox", "crs", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io7 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io8(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io8 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io9 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io10(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io10 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io11 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io1(input, true && _exceptionable);
        else
            return false;
    })();
    const $iu1 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io9(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io7(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeature = (input: any): input is Feature => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu1(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io11(input.properties));
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
    const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $io11 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io9(input);
        else if ("name" === input.type)
            return $io7(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Feature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $pick([
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bbox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        crs: $pick([
            () => undefined,
            () => null,
            () => $ro9(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro7(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro11(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro7 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro8(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro8 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro9 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro10(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro10 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro11 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyFeature = (input: Feature): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
    const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io8(input.properties));
    const $io8 = (input: any): boolean => "string" === typeof input.name;
    const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io10(input.properties));
    const $io10 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $io11 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io9(input);
        else if ("name" === input.type)
            return $io7(input);
        else
            return false;
    })();
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}${undefined === input.bbox ? "" : `"bbox":${undefined !== input.bbox ? (() => {
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.bbox
        });
    })() : undefined},`}${undefined === input.crs ? "" : `"crs":${undefined !== input.crs ? null !== input.crs ? $su1(input.crs) : "null" : undefined},`}${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so11(input.properties) : "null" : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$su0(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so7 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so9 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $so11 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so6(input);
        else if ("MultiLineString" === input.type)
            return $so5(input);
        else if ("MultiPoint" === input.type)
            return $so4(input);
        else if ("Polygon" === input.type)
            return $so3(input);
        else if ("LineString" === input.type)
            return $so2(input);
        else if ("Point" === input.type)
            return $so1(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                value: input
            });
    })();
    const $su1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so9(input);
        else if ("name" === input.type)
            return $so7(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeature = (input: any): typia.IValidation<Feature> => {
    const errors = [] as any[];
    const __is = (input: any): input is Feature => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu1(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io11(input.properties));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
        const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io11 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io9(input);
            else if ("name" === input.type)
                return $io7(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Feature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vp1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                })) && $vu0(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                }), undefined === input.bbox || (Array.isArray(input.bbox) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                })) && ($vp0(input.bbox, _path + ".bbox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.bbox
                })) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                }), null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                })) && $vu1(input.crs, _path + ".crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo11(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp1(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp1(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp1(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp1(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp1(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp1(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp1(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp1(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp1(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp1(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp1(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp1(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp1(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp1(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp1(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo8(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo10(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vo11 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            const $vu1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo9(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo7(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureCollection
export const assertFeatureCollection = (input: any): FeatureCollection => {
    const __is = (input: any): input is FeatureCollection => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
        const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
        const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
        const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
        const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
        const $io8 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io10 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io12 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io10(input);
            else if ("name" === input.type)
                return $io8(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io7(input);
            else if ("MultiLineString" === input.type)
                return $io6(input);
            else if ("MultiPoint" === input.type)
                return $io5(input);
            else if ("Polygon" === input.type)
                return $io4(input);
            else if ("LineString" === input.type)
                return $io3(input);
            else if ("Point" === input.type)
                return $io2(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ap1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>>",
                value: input.features
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            })) && (undefined === input.bbox || (Array.isArray(input.bbox) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && ($ap0(input.bbox, _path + ".bbox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.bbox
            })) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && (null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && $au0(input.crs, _path + ".crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao12(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && $au1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            })) && (undefined === input.bbox || (Array.isArray(input.bbox) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && ($ap0(input.bbox, _path + ".bbox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.bbox
            })) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && (null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && $au0(input.crs, _path + ".crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao12(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap1(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap1(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap1(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap1(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap1(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap1(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap1(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap1(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap1(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap1(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap1(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap1(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap1(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap1(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index10: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap1(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao9(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao11(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao11 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $ao12 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao10(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao8(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            const $au1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao7(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureCollection = (input: any, _exceptionable: boolean = true): input is FeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox, true && _exceptionable) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features", "id", "bbox", "crs", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu1(input.geometry, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox, true && _exceptionable) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "id", "bbox", "crs", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index4: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index6: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io7 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index9: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index10: number) => Array.isArray(elem) && ($ip1(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io8 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io9(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io9 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io10 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io11(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io11 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io12 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io10(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io8(input, true && _exceptionable);
        else
            return false;
    })();
    const $iu1 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io6(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io2(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeatureCollection = (input: any): input is FeatureCollection => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
    const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
    const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
    const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
    const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
    const $io8 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io10 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $io12 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io10(input);
        else if ("name" === input.type)
            return $io8(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input);
        else if ("MultiLineString" === input.type)
            return $io6(input);
        else if ("MultiPoint" === input.type)
            return $io5(input);
        else if ("Polygon" === input.type)
            return $io4(input);
        else if ("LineString" === input.type)
            return $io3(input);
        else if ("Point" === input.type)
            return $io2(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bbox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        crs: $pick([
            () => undefined,
            () => null,
            () => $ro10(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro8(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro12(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $pick([
            () => $ro7(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bbox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        crs: $pick([
            () => undefined,
            () => null,
            () => $ro10(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro8(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro12(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro7 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro8 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro9(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro9 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro10 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro11(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro11 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro12 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyFeatureCollection = (input: FeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
    const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
    const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
    const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
    const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
    const $io8 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io9(input.properties));
    const $io9 = (input: any): boolean => "string" === typeof input.name;
    const $io10 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io11(input.properties));
    const $io11 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $io12 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io10(input);
        else if ("name" === input.type)
            return $io8(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input);
        else if ("MultiLineString" === input.type)
            return $io6(input);
        else if ("MultiPoint" === input.type)
            return $io5(input);
        else if ("Polygon" === input.type)
            return $io4(input);
        else if ("LineString" === input.type)
            return $io3(input);
        else if ("Point" === input.type)
            return $io2(input);
        else
            return false;
    })();
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}${undefined === input.bbox ? "" : `"bbox":${undefined !== input.bbox ? (() => {
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.bbox
        });
    })() : undefined},`}${undefined === input.crs ? "" : `"crs":${undefined !== input.crs ? null !== input.crs ? $su0(input.crs) : "null" : undefined},`}${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so12(input.properties) : "null" : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}${undefined === input.bbox ? "" : `"bbox":${undefined !== input.bbox ? (() => {
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.bbox
        });
    })() : undefined},`}${undefined === input.crs ? "" : `"crs":${undefined !== input.crs ? null !== input.crs ? $su0(input.crs) : "null" : undefined},`}${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so12(input.properties) : "null" : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$su1(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so7 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so8 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so10 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $so12 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so10(input);
        else if ("name" === input.type)
            return $so8(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    const $su1 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so7(input);
        else if ("MultiLineString" === input.type)
            return $so6(input);
        else if ("MultiPoint" === input.type)
            return $so5(input);
        else if ("Polygon" === input.type)
            return $so4(input);
        else if ("LineString" === input.type)
            return $so3(input);
        else if ("Point" === input.type)
            return $so2(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeatureCollection = (input: any): typia.IValidation<FeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureCollection => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io12(input.properties));
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip1(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip1(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))));
        const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip1(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip1(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))));
        const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)));
        const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip1(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip1(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip1(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip1(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))));
        const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip1(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip1(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip1(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip1(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip1(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip1(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip1(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip1(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip1(elem) || false))))))))));
        const $io8 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io10 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io12 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io10(input);
            else if ("name" === input.type)
                return $io8(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io7(input);
            else if ("MultiLineString" === input.type)
                return $io6(input);
            else if ("MultiPoint" === input.type)
                return $io5(input);
            else if ("Polygon" === input.type)
                return $io4(input);
            else if ("LineString" === input.type)
                return $io3(input);
            else if ("Point" === input.type)
                return $io2(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vp1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties | undefined, undefined>>",
                    value: input.features
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                }), undefined === input.bbox || (Array.isArray(input.bbox) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                })) && ($vp0(input.bbox, _path + ".bbox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.bbox
                })) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                }), null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                })) && $vu0(input.crs, _path + ".crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo12(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                })) && $vu1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                }), undefined === input.bbox || (Array.isArray(input.bbox) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                })) && ($vp0(input.bbox, _path + ".bbox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.bbox
                })) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                }), null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                })) && $vu0(input.crs, _path + ".crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo12(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp1(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp1(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp1(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp1(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp1(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp1(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp1(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp1(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp1(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp1(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp1(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp1(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp1(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp1(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp1(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp1(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp1(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp1(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index10: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp1(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo9(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo11(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo11 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vo12 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo10(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo8(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            const $vu1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo7(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureCollectionType
export const assertFeatureCollectionType = (input: any): FeatureCollectionType => {
    const __is = (input: any): input is FeatureCollectionType => {
        return "FeatureCollection" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollectionType => {
            const $guard = (typia.createAssert as any).guard;
            return "FeatureCollection" === input || $guard(true, {
                path: _path + "",
                expected: "\"FeatureCollection\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureCollectionType = (input: any, _exceptionable: boolean = true): input is FeatureCollectionType => {
    return "FeatureCollection" === input;
};
export const isFeatureCollectionType = (input: any): input is FeatureCollectionType => {
    return "FeatureCollection" === input;
};
export const randomFeatureCollectionType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureCollectionType> => {
    return "FeatureCollection";
};
export const stringifyFeatureCollectionType = (input: FeatureCollectionType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input
        });
    })();
};
export const validateFeatureCollectionType = (input: any): typia.IValidation<FeatureCollectionType> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureCollectionType => {
        return "FeatureCollection" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollectionType => {
            return "FeatureCollection" === input || $report(true, {
                path: _path + "",
                expected: "\"FeatureCollection\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureGeneric
export const assertFeatureGeneric = (input: any): FeatureGeneric => {
    const __is = (input: any): input is FeatureGeneric => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry)) && (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip1(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu1(input.Crs));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io9(input);
            else if ("name" === input.type)
                return $io7(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGeneric => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ap1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ((Array.isArray(input.Coordinate) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.Coordinate
            })) && ($ap0(input.Coordinate, _path + ".Coordinate", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.Coordinate
            })) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.Coordinate
            })) && (("object" === typeof input.Geometry && null !== input.Geometry || $guard(_exceptionable, {
                path: _path + ".Geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.Geometry
            })) && $au0(input.Geometry, _path + ".Geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.Geometry
            })) && (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id || $guard(_exceptionable, {
                path: _path + ".Id",
                expected: "(number | string | undefined)",
                value: input.Id
            })) && (undefined === input.BBox || (Array.isArray(input.BBox) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.BBox
            })) && ($ap1(input.BBox, _path + ".BBox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.BBox
            })) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.BBox
            })) && (undefined === input.Crs || ("object" === typeof input.Crs && null !== input.Crs || $guard(_exceptionable, {
                path: _path + ".Crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.Crs
            })) && $au1(input.Crs, _path + ".Crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.Crs
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao8(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao10(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            const $au1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao9(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao7(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "FeatureGeneric",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "FeatureGeneric",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureGeneric = (input: any, _exceptionable: boolean = true): input is FeatureGeneric => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate, true && _exceptionable) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry, true && _exceptionable)) && (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip1(input.BBox, true && _exceptionable) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu1(input.Crs, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["Coordinate", "Geometry", "Id", "BBox", "Crs"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io7 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io8(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io8 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io9 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io10(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io10 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io1(input, true && _exceptionable);
        else
            return false;
    })();
    const $iu1 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io9(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io7(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeatureGeneric = (input: any): input is FeatureGeneric => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry)) && (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip1(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu1(input.Crs));
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io9(input);
        else if ("name" === input.type)
            return $io7(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeatureGeneric = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureGeneric> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        Coordinate: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        Geometry: $pick([
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        Id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        BBox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        Crs: $pick([
            () => undefined,
            () => $ro9(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro7(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro7 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro8(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro8 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro9 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro10(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro10 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyFeatureGeneric = (input: FeatureGeneric): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io8(input.properties));
    const $io8 = (input: any): boolean => "string" === typeof input.name;
    const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io10(input.properties));
    const $io10 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $iu1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io9(input);
        else if ("name" === input.type)
            return $io7(input);
        else
            return false;
    })();
    const $throws = (typia.json.createStringify as any).throws;
    const $string = (typia.json.createStringify as any).string;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.Id ? "" : `"Id":${undefined !== input.Id ? (() => {
        if ("string" === typeof input.Id)
            return $string(input.Id);
        if ("number" === typeof input.Id)
            return input.Id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.Id
        });
    })() : undefined},`}${undefined === input.BBox ? "" : `"BBox":${undefined !== input.BBox ? (() => {
        if (Array.isArray(input.BBox) && (input.BBox.length === 6 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3] && "number" === typeof input.BBox[4] && "number" === typeof input.BBox[5]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]},${input.BBox[4]},${input.BBox[5]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 6 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3] && "number" === typeof input.BBox[4] && "number" === typeof input.BBox[5]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]},${input.BBox[4]},${input.BBox[5]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 4 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 4 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.BBox
        });
    })() : undefined},`}${undefined === input.Crs ? "" : `"Crs":${undefined !== input.Crs ? $su1(input.Crs) : undefined},`}"Coordinate":${(() => {
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 3 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1] && "number" === typeof input.Coordinate[2]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]},${input.Coordinate[2]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 3 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1] && "number" === typeof input.Coordinate[2]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]},${input.Coordinate[2]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 2 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 2 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.Coordinate
        });
    })()},"Geometry":${$su0(input.Geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so7 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so9 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so6(input);
        else if ("MultiLineString" === input.type)
            return $so5(input);
        else if ("MultiPoint" === input.type)
            return $so4(input);
        else if ("Polygon" === input.type)
            return $so3(input);
        else if ("LineString" === input.type)
            return $so2(input);
        else if ("Point" === input.type)
            return $so1(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                value: input
            });
    })();
    const $su1 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so9(input);
        else if ("name" === input.type)
            return $so7(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeatureGeneric = (input: any): typia.IValidation<FeatureGeneric> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureGeneric => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry)) && (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip1(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu1(input.Crs));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io7 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io9 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        const $iu1 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io9(input);
            else if ("name" === input.type)
                return $io7(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGeneric => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vp1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [(Array.isArray(input.Coordinate) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.Coordinate
                })) && ($vp0(input.Coordinate, _path + ".Coordinate", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.Coordinate
                })) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.Coordinate
                }), ("object" === typeof input.Geometry && null !== input.Geometry || $report(_exceptionable, {
                    path: _path + ".Geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.Geometry
                })) && $vu0(input.Geometry, _path + ".Geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.Geometry
                }), undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id || $report(_exceptionable, {
                    path: _path + ".Id",
                    expected: "(number | string | undefined)",
                    value: input.Id
                }), undefined === input.BBox || (Array.isArray(input.BBox) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.BBox
                })) && ($vp1(input.BBox, _path + ".BBox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.BBox
                })) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.BBox
                }), undefined === input.Crs || ("object" === typeof input.Crs && null !== input.Crs || $report(_exceptionable, {
                    path: _path + ".Crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.Crs
                })) && $vu1(input.Crs, _path + ".Crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.Crs
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo8(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo9 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo10(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo10 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            const $vu1 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo9(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo7(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "FeatureGeneric",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "FeatureGeneric",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureGenericGeometry
export const assertFeatureGenericGeometry = (input: any): FeatureGenericGeometry => {
    const __is = (input: any): input is FeatureGenericGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGenericGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ((Array.isArray(input.Coordinate) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.Coordinate
            })) && ($ap0(input.Coordinate, _path + ".Coordinate", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.Coordinate
            })) || $guard(_exceptionable, {
                path: _path + ".Coordinate",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.Coordinate
            })) && (("object" === typeof input.Geometry && null !== input.Geometry || $guard(_exceptionable, {
                path: _path + ".Geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.Geometry
            })) && $au0(input.Geometry, _path + ".Geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.Geometry
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "FeatureGenericGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "FeatureGenericGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureGenericGeometry = (input: any, _exceptionable: boolean = true): input is FeatureGenericGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate, true && _exceptionable) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["Coordinate", "Geometry"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io1(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeatureGenericGeometry = (input: any): input is FeatureGenericGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry));
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeatureGenericGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureGenericGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        Coordinate: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        Geometry: $pick([
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyFeatureGenericGeometry = (input: FeatureGenericGeometry): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        else if ("MultiLineString" === input.type)
            return $io5(input);
        else if ("MultiPoint" === input.type)
            return $io4(input);
        else if ("Polygon" === input.type)
            return $io3(input);
        else if ("LineString" === input.type)
            return $io2(input);
        else if ("Point" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $throws = (typia.json.createStringify as any).throws;
    const $string = (typia.json.createStringify as any).string;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"Coordinate":${(() => {
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 3 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1] && "number" === typeof input.Coordinate[2]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]},${input.Coordinate[2]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 3 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1] && "number" === typeof input.Coordinate[2]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]},${input.Coordinate[2]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 2 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]}]`;
        if (Array.isArray(input.Coordinate) && (input.Coordinate.length === 2 && "number" === typeof input.Coordinate[0] && "number" === typeof input.Coordinate[1]))
            return `[${input.Coordinate[0]},${input.Coordinate[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.Coordinate
        });
    })()},"Geometry":${$su0(input.Geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so6(input);
        else if ("MultiLineString" === input.type)
            return $so5(input);
        else if ("MultiPoint" === input.type)
            return $so4(input);
        else if ("Polygon" === input.type)
            return $so3(input);
        else if ("LineString" === input.type)
            return $so2(input);
        else if ("Point" === input.type)
            return $so1(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeatureGenericGeometry = (input: any): typia.IValidation<FeatureGenericGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureGenericGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => Array.isArray(input.Coordinate) && ($ip0(input.Coordinate) || false) && ("object" === typeof input.Geometry && null !== input.Geometry && $iu0(input.Geometry));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            else if ("MultiLineString" === input.type)
                return $io5(input);
            else if ("MultiPoint" === input.type)
                return $io4(input);
            else if ("Polygon" === input.type)
                return $io3(input);
            else if ("LineString" === input.type)
                return $io2(input);
            else if ("Point" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGenericGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [(Array.isArray(input.Coordinate) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.Coordinate
                })) && ($vp0(input.Coordinate, _path + ".Coordinate", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.Coordinate
                })) || $report(_exceptionable, {
                    path: _path + ".Coordinate",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.Coordinate
                }), ("object" === typeof input.Geometry && null !== input.Geometry || $report(_exceptionable, {
                    path: _path + ".Geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.Geometry
                })) && $vu0(input.Geometry, _path + ".Geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.Geometry
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "FeatureGenericGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "FeatureGenericGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureGenericOptions
export const assertFeatureGenericOptions = (input: any): FeatureGenericOptions => {
    const __is = (input: any): input is FeatureGenericOptions => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip0(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu0(input.Crs));
        const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io3(input);
            else if ("name" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGenericOptions => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id || $guard(_exceptionable, {
                path: _path + ".Id",
                expected: "(number | string | undefined)",
                value: input.Id
            })) && (undefined === input.BBox || (Array.isArray(input.BBox) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.BBox
            })) && ($ap0(input.BBox, _path + ".BBox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.BBox
            })) || $guard(_exceptionable, {
                path: _path + ".BBox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.BBox
            })) && (undefined === input.Crs || ("object" === typeof input.Crs && null !== input.Crs || $guard(_exceptionable, {
                path: _path + ".Crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.Crs
            })) && $au0(input.Crs, _path + ".Crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".Crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.Crs
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao4(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "FeatureGenericOptions",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "FeatureGenericOptions",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureGenericOptions = (input: any, _exceptionable: boolean = true): input is FeatureGenericOptions => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip0(input.BBox, true && _exceptionable) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu0(input.Crs, true && _exceptionable)) && (0 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["Id", "BBox", "Crs"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io2(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io4(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io1(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isFeatureGenericOptions = (input: any): input is FeatureGenericOptions => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip0(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu0(input.Crs));
    const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io3(input);
        else if ("name" === input.type)
            return $io1(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomFeatureGenericOptions = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureGenericOptions> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        Id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        BBox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        Crs: $pick([
            () => undefined,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro2(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro4(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyFeatureGenericOptions = (input: FeatureGenericOptions): string => {
    const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io2(input.properties));
    const $io2 = (input: any): boolean => "string" === typeof input.name;
    const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io4(input.properties));
    const $io4 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io3(input);
        else if ("name" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $tail = (typia.json.createStringify as any).tail;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.Id ? "" : `"Id":${undefined !== input.Id ? (() => {
        if ("string" === typeof input.Id)
            return $string(input.Id);
        if ("number" === typeof input.Id)
            return input.Id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.Id
        });
    })() : undefined},`}${undefined === input.BBox ? "" : `"BBox":${undefined !== input.BBox ? (() => {
        if (Array.isArray(input.BBox) && (input.BBox.length === 6 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3] && "number" === typeof input.BBox[4] && "number" === typeof input.BBox[5]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]},${input.BBox[4]},${input.BBox[5]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 6 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3] && "number" === typeof input.BBox[4] && "number" === typeof input.BBox[5]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]},${input.BBox[4]},${input.BBox[5]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 4 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]}]`;
        if (Array.isArray(input.BBox) && (input.BBox.length === 4 && "number" === typeof input.BBox[0] && "number" === typeof input.BBox[1] && "number" === typeof input.BBox[2] && "number" === typeof input.BBox[3]))
            return `[${input.BBox[0]},${input.BBox[1]},${input.BBox[2]},${input.BBox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.BBox
        });
    })() : undefined},`}${undefined === input.Crs ? "" : `"Crs":${undefined !== input.Crs ? $su0(input.Crs) : undefined}`}`)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so3(input);
        else if ("name" === input.type)
            return $so1(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeatureGenericOptions = (input: any): typia.IValidation<FeatureGenericOptions> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureGenericOptions => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => (undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id) && (undefined === input.BBox || Array.isArray(input.BBox) && ($ip0(input.BBox) || false)) && (undefined === input.Crs || "object" === typeof input.Crs && null !== input.Crs && $iu0(input.Crs));
        const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io3(input);
            else if ("name" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureGenericOptions => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [undefined === input.Id || "string" === typeof input.Id || "number" === typeof input.Id || $report(_exceptionable, {
                    path: _path + ".Id",
                    expected: "(number | string | undefined)",
                    value: input.Id
                }), undefined === input.BBox || (Array.isArray(input.BBox) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.BBox
                })) && ($vp0(input.BBox, _path + ".BBox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.BBox
                })) || $report(_exceptionable, {
                    path: _path + ".BBox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.BBox
                }), undefined === input.Crs || ("object" === typeof input.Crs && null !== input.Crs || $report(_exceptionable, {
                    path: _path + ".Crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.Crs
                })) && $vu0(input.Crs, _path + ".Crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".Crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.Crs
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo4(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "FeatureGenericOptions",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "FeatureGenericOptions",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureOptions
export const assertFeatureOptions = (input: any): FeatureOptions => {
    const __is = (input: any): input is FeatureOptions => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs));
        const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io3(input);
            else if ("name" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureOptions => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            })) && (undefined === input.bbox || (Array.isArray(input.bbox) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && ($ap0(input.bbox, _path + ".bbox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.bbox
            })) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && (null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            })) && $au0(input.crs, _path + ".crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                value: input.crs
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o2",
                value: input.properties
            })) && $ao4(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o2",
                value: input.properties
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "__type",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "__type",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureOptions = (input: any, _exceptionable: boolean = true): input is FeatureOptions => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox, true && _exceptionable) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs, true && _exceptionable)) && (0 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "bbox", "crs"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io2(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io4(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io1(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isFeatureOptions = (input: any): input is FeatureOptions => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs));
    const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io3(input);
        else if ("name" === input.type)
            return $io1(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomFeatureOptions = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureOptions> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bbox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        crs: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro2(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro4(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyFeatureOptions = (input: FeatureOptions): string => {
    const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io2(input.properties));
    const $io2 = (input: any): boolean => "string" === typeof input.name;
    const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io4(input.properties));
    const $io4 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io3(input);
        else if ("name" === input.type)
            return $io1(input);
        else
            return false;
    })();
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $tail = (typia.json.createStringify as any).tail;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}${undefined === input.bbox ? "" : `"bbox":${undefined !== input.bbox ? (() => {
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.bbox
        });
    })() : undefined},`}${undefined === input.crs ? "" : `"crs":${undefined !== input.crs ? null !== input.crs ? $su0(input.crs) : "null" : undefined}`}`)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so3(input);
        else if ("name" === input.type)
            return $so1(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $so0(input);
};
export const validateFeatureOptions = (input: any): typia.IValidation<FeatureOptions> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureOptions => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (null === input.crs || undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs));
        const $io1 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io3 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io3(input);
            else if ("name" === input.type)
                return $io1(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureOptions => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                }), undefined === input.bbox || (Array.isArray(input.bbox) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                })) && ($vp0(input.bbox, _path + ".bbox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.bbox
                })) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                }), null === input.crs || undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                })) && $vu0(input.crs, _path + ".crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | null | undefined)",
                    value: input.crs
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o2",
                    value: input.properties
                })) && $vo4(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o2",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "__type",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "__type",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureType
export const assertFeatureType = (input: any): FeatureType => {
    const __is = (input: any): input is FeatureType => {
        return "Feature" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureType => {
            const $guard = (typia.createAssert as any).guard;
            return "Feature" === input || $guard(true, {
                path: _path + "",
                expected: "\"Feature\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureType = (input: any, _exceptionable: boolean = true): input is FeatureType => {
    return "Feature" === input;
};
export const isFeatureType = (input: any): input is FeatureType => {
    return "Feature" === input;
};
export const randomFeatureType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<FeatureType> => {
    return "Feature";
};
export const stringifyFeatureType = (input: FeatureType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input
        });
    })();
};
export const validateFeatureType = (input: any): typia.IValidation<FeatureType> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureType => {
        return "Feature" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureType => {
            return "Feature" === input || $report(true, {
                path: _path + "",
                expected: "\"Feature\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeoJsonProperties
export const assertGeoJsonProperties = (input: any): GeoJsonProperties => {
    const __is = (input: any): input is GeoJsonProperties => {
        const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeoJsonProperties => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return null === input || ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeoJsonProperties = (input: any, _exceptionable: boolean = true): input is GeoJsonProperties => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isGeoJsonProperties = (input: any): input is GeoJsonProperties => {
    const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomGeoJsonProperties = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<GeoJsonProperties> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $pick([
        () => null,
        () => $ro0()
    ])();
};
export const stringifyGeoJsonProperties = (input: GeoJsonProperties): string => {
    const $so0 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return null !== input ? $so0(input) : "null";
};
export const validateGeoJsonProperties = (input: any): typia.IValidation<GeoJsonProperties> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeoJsonProperties => {
        const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeoJsonProperties => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return null === input || ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry
export const assertGeometry = (input: any): Geometry => {
    const __is = (input: any): input is Geometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry = (input: any, _exceptionable: boolean = true): input is Geometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry = (input: any): input is Geometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        else if ("MultiLineString" === input.type)
            return $io4(input);
        else if ("MultiPoint" === input.type)
            return $io3(input);
        else if ("Polygon" === input.type)
            return $io2(input);
        else if ("LineString" === input.type)
            return $io1(input);
        else if ("Point" === input.type)
            return $io0(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Geometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry = (input: Geometry): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        else if ("MultiLineString" === input.type)
            return $so4(input);
        else if ("MultiPoint" === input.type)
            return $so3(input);
        else if ("Polygon" === input.type)
            return $so2(input);
        else if ("LineString" === input.type)
            return $so1(input);
        else if ("Point" === input.type)
            return $so0(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                value: input
            });
    })();
    return $su0(input);
};
export const validateGeometry = (input: any): typia.IValidation<Geometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry2d
export const assertGeometry2d = (input: any): Geometry2d => {
    const __is = (input: any): input is Geometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry2d = (input: any, _exceptionable: boolean = true): input is Geometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry2d = (input: any): input is Geometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        else if ("MultiLineString" === input.type)
            return $io4(input);
        else if ("MultiPoint" === input.type)
            return $io3(input);
        else if ("Polygon" === input.type)
            return $io2(input);
        else if ("LineString" === input.type)
            return $io1(input);
        else if ("Point" === input.type)
            return $io0(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Geometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry2d = (input: Geometry2d): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        else if ("MultiLineString" === input.type)
            return $so4(input);
        else if ("MultiPoint" === input.type)
            return $so3(input);
        else if ("Polygon" === input.type)
            return $so2(input);
        else if ("LineString" === input.type)
            return $so1(input);
        else if ("Point" === input.type)
            return $so0(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
                value: input
            });
    })();
    return $su0(input);
};
export const validateGeometry2d = (input: any): typia.IValidation<Geometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry3d
export const assertGeometry3d = (input: any): Geometry3d => {
    const __is = (input: any): input is Geometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[LinearRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "LinearRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry3d = (input: any, _exceptionable: boolean = true): input is Geometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        else if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        else if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        else if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        else if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry3d = (input: any): input is Geometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        else if ("MultiLineString" === input.type)
            return $io4(input);
        else if ("MultiPoint" === input.type)
            return $io3(input);
        else if ("Polygon" === input.type)
            return $io2(input);
        else if ("LineString" === input.type)
            return $io1(input);
        else if ("Point" === input.type)
            return $io0(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Geometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry3d = (input: Geometry3d): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        else if ("MultiLineString" === input.type)
            return $so4(input);
        else if ("MultiPoint" === input.type)
            return $so3(input);
        else if ("Polygon" === input.type)
            return $so2(input);
        else if ("LineString" === input.type)
            return $so1(input);
        else if ("Point" === input.type)
            return $so0(input);
        else
            $throws({
                expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
                value: input
            });
    })();
    return $su0(input);
};
export const validateGeometry3d = (input: any): typia.IValidation<Geometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            else if ("MultiLineString" === input.type)
                return $io4(input);
            else if ("MultiPoint" === input.type)
                return $io3(input);
            else if ("Polygon" === input.type)
                return $io2(input);
            else if ("LineString" === input.type)
                return $io1(input);
            else if ("Point" === input.type)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[LinearRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                else if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                else if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeometryCollectionType
export const assertGeometryCollectionType = (input: any): GeometryCollectionType => {
    const __is = (input: any): input is GeometryCollectionType => {
        return "GeometryCollection" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollectionType => {
            const $guard = (typia.createAssert as any).guard;
            return "GeometryCollection" === input || $guard(true, {
                path: _path + "",
                expected: "\"GeometryCollection\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometryCollectionType = (input: any, _exceptionable: boolean = true): input is GeometryCollectionType => {
    return "GeometryCollection" === input;
};
export const isGeometryCollectionType = (input: any): input is GeometryCollectionType => {
    return "GeometryCollection" === input;
};
export const randomGeometryCollectionType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<GeometryCollectionType> => {
    return "GeometryCollection";
};
export const stringifyGeometryCollectionType = (input: GeometryCollectionType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"GeometryCollection\"",
            value: input
        });
    })();
};
export const validateGeometryCollectionType = (input: any): typia.IValidation<GeometryCollectionType> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeometryCollectionType => {
        return "GeometryCollection" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollectionType => {
            return "GeometryCollection" === input || $report(true, {
                path: _path + "",
                expected: "\"GeometryCollection\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeometryType
export const assertGeometryType = (input: any): GeometryType => {
    const __is = (input: any): input is GeometryType => {
        return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input || $guard(true, {
                path: _path + "",
                expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometryType = (input: any, _exceptionable: boolean = true): input is GeometryType => {
    return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
};
export const isGeometryType = (input: any): input is GeometryType => {
    return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
};
export const randomGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<GeometryType> => {
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => "Point",
        () => "LineString",
        () => "Polygon",
        () => "MultiPoint",
        () => "MultiLineString",
        () => "MultiPolygon"
    ])();
};
export const stringifyGeometryType = (input: GeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
            value: input
        });
    })();
};
export const validateGeometryType = (input: any): typia.IValidation<GeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeometryType => {
        return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryType => {
            return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input || $report(true, {
                path: _path + "",
                expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geostats
export const assertGeostats = (input: any): Geostats => {
    const __is = (input: any): input is Geostats => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            if (["layerCount", "layers"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
            if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geostats => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index9: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index10: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("number" === typeof input.layerCount || $guard(_exceptionable, {
                path: _path + ".layerCount",
                expected: "number",
                value: input.layerCount
            })) && ((Array.isArray(input.layers) || $guard(_exceptionable, {
                path: _path + ".layers",
                expected: "Array<GeostatsLayer>",
                value: input.layers
            })) && input.layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".layers[" + _index1 + "]",
                expected: "GeostatsLayer",
                value: elem
            })) && $ao1(elem, _path + ".layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".layers[" + _index1 + "]",
                expected: "GeostatsLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".layers",
                expected: "Array<GeostatsLayer>",
                value: input.layers
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["layerCount", "layers"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.layer || $guard(_exceptionable, {
                path: _path + ".layer",
                expected: "string",
                value: input.layer
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                value: input.geometry
            })) && ("number" === typeof input.attributeCount || $guard(_exceptionable, {
                path: _path + ".attributeCount",
                expected: "number",
                value: input.attributeCount
            })) && (undefined === input.attributes || (Array.isArray(input.attributes) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && input.attributes.every((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index2 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) && $ao2(elem, _path + ".attributes[" + _index2 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index2 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostats = (input: any, _exceptionable: boolean = true): input is Geostats => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index9: number) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index10: number) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layerCount", "layers"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any, _index2: number) => "object" === typeof elem && null !== elem && $io2(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostats = (input: any): input is Geostats => {
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
        if (["layerCount", "layers"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostats = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Geostats> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layerCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layer: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            geometry: $pick([
                () => "Point",
                () => "LineString",
                () => "Polygon"
            ])(),
            attributeCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            attributes: $pick([
                () => undefined,
                () => (generator?.array ?? $generator.array)(() => $ro2(_recursive, _recursive ? 1 + _depth : _depth))
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostats = (input: Geostats): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($sp0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $tail = (typia.json.createStringify as any).tail;
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`"layerCount":${input.layerCount},"layers":${`[${input.layers.map((elem: any) => $so1(elem)).join(",")}]`},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["layerCount", "layers"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so1 = (input: any): any => `{${$tail(`${undefined === input.attributes ? "" : `"attributes":${undefined !== input.attributes ? `[${input.attributes.map((elem: any) => $so2(elem)).join(",")}]` : undefined},`}"layer":${$string(input.layer)},"count":${input.count},"geometry":${(() => {
        if ("string" === typeof input.geometry)
            return $string(input.geometry);
        if ("string" === typeof input.geometry)
            return "\"" + input.geometry + "\"";
        $throws({
            expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
            value: input.geometry
        });
    })()},"attributeCount":${input.attributeCount},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["attributes", "layer", "count", "geometry", "attributeCount"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so2 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostats = (input: any): typia.IValidation<Geostats> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geostats => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            if (["layerCount", "layers"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
            if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geostats => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index9: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index10: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["number" === typeof input.layerCount || $report(_exceptionable, {
                    path: _path + ".layerCount",
                    expected: "number",
                    value: input.layerCount
                }), (Array.isArray(input.layers) || $report(_exceptionable, {
                    path: _path + ".layers",
                    expected: "Array<GeostatsLayer>",
                    value: input.layers
                })) && input.layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".layers[" + _index1 + "]",
                    expected: "GeostatsLayer",
                    value: elem
                })) && $vo1(elem, _path + ".layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".layers[" + _index1 + "]",
                    expected: "GeostatsLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".layers",
                    expected: "Array<GeostatsLayer>",
                    value: input.layers
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["layerCount", "layers"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.layer || $report(_exceptionable, {
                    path: _path + ".layer",
                    expected: "string",
                    value: input.layer
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                    value: input.geometry
                }), "number" === typeof input.attributeCount || $report(_exceptionable, {
                    path: _path + ".attributeCount",
                    expected: "number",
                    value: input.attributeCount
                }), undefined === input.attributes || (Array.isArray(input.attributes) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                })) && input.attributes.map((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index2 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })) && $vo2(elem, _path + ".attributes[" + _index2 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index2 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeostatsAttribute
export const assertGeostatsAttribute = (input: any): GeostatsAttribute => {
    const __is = (input: any): input is GeostatsAttribute => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsAttribute => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index5: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index5 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostatsAttribute = (input: any, _exceptionable: boolean = true): input is GeostatsAttribute => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index5: number) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index6: number) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostatsAttribute = (input: any): input is GeostatsAttribute => {
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostatsAttribute = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<GeostatsAttribute> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostatsAttribute = (input: GeostatsAttribute): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $tail = (typia.json.createStringify as any).tail;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostatsAttribute = (input: any): typia.IValidation<GeostatsAttribute> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeostatsAttribute => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsAttribute => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index5: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index5 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeostatsLayer
export const assertGeostatsLayer = (input: any): GeostatsLayer => {
    const __is = (input: any): input is GeostatsLayer => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsLayer => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index6: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index9: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.layer || $guard(_exceptionable, {
                path: _path + ".layer",
                expected: "string",
                value: input.layer
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                value: input.geometry
            })) && ("number" === typeof input.attributeCount || $guard(_exceptionable, {
                path: _path + ".attributeCount",
                expected: "number",
                value: input.attributeCount
            })) && (undefined === input.attributes || (Array.isArray(input.attributes) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && input.attributes.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index1 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) && $ao1(elem, _path + ".attributes[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index1 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostatsLayer = (input: any, _exceptionable: boolean = true): input is GeostatsLayer => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index6: number) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index9: number) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostatsLayer = (input: any): input is GeostatsLayer => {
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostatsLayer = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<GeostatsLayer> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layer: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            geometry: $pick([
                () => "Point",
                () => "LineString",
                () => "Polygon"
            ])(),
            attributeCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            attributes: $pick([
                () => undefined,
                () => (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostatsLayer = (input: GeostatsLayer): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($sp0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $tail = (typia.json.createStringify as any).tail;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any[]): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ] as const,
            [
                (top: any[]): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ] as const,
            [
                (top: any[]): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ] as const
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0]![1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.attributes ? "" : `"attributes":${undefined !== input.attributes ? `[${input.attributes.map((elem: any) => $so1(elem)).join(",")}]` : undefined},`}"layer":${$string(input.layer)},"count":${input.count},"geometry":${(() => {
        if ("string" === typeof input.geometry)
            return $string(input.geometry);
        if ("string" === typeof input.geometry)
            return "\"" + input.geometry + "\"";
        $throws({
            expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
            value: input.geometry
        });
    })()},"attributeCount":${input.attributeCount},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["attributes", "layer", "count", "geometry", "attributeCount"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so1 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostatsLayer = (input: any): typia.IValidation<GeostatsLayer> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeostatsLayer => {
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any[]): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ] as const,
                [
                    (top: any[]): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ] as const
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0]![1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsLayer => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any[]): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index6: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index9: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ] as const
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0]![1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.layer || $report(_exceptionable, {
                    path: _path + ".layer",
                    expected: "string",
                    value: input.layer
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                    value: input.geometry
                }), "number" === typeof input.attributeCount || $report(_exceptionable, {
                    path: _path + ".attributeCount",
                    expected: "number",
                    value: input.attributeCount
                }), undefined === input.attributes || (Array.isArray(input.attributes) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                })) && input.attributes.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index1 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })) && $vo1(elem, _path + ".attributes[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index1 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Latitude
export const assertLatitude = (input: any): Latitude => {
    const __is = (input: any): input is Latitude => {
        return "number" === typeof input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Latitude => {
            const $guard = (typia.createAssert as any).guard;
            return "number" === typeof input || $guard(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLatitude = (input: any, _exceptionable: boolean = true): input is Latitude => {
    return "number" === typeof input;
};
export const isLatitude = (input: any): input is Latitude => {
    return "number" === typeof input;
};
export const randomLatitude = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Latitude> => {
    const $generator = (typia.createRandom as any).generator;
    return (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100);
};
export const stringifyLatitude = (input: Latitude): string => {
    return input.toString();
};
export const validateLatitude = (input: any): typia.IValidation<Latitude> => {
    const errors = [] as any[];
    const __is = (input: any): input is Latitude => {
        return "number" === typeof input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Latitude => {
            return "number" === typeof input || $report(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LatitudeWgs84
export const assertLatitudeWgs84 = (input: any): LatitudeWgs84 => {
    const __is = (input: any): input is LatitudeWgs84 => {
        return "number" === typeof input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LatitudeWgs84 => {
            const $guard = (typia.createAssert as any).guard;
            return "number" === typeof input || $guard(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLatitudeWgs84 = (input: any, _exceptionable: boolean = true): input is LatitudeWgs84 => {
    return "number" === typeof input;
};
export const isLatitudeWgs84 = (input: any): input is LatitudeWgs84 => {
    return "number" === typeof input;
};
export const randomLatitudeWgs84 = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LatitudeWgs84> => {
    const $generator = (typia.createRandom as any).generator;
    return (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100);
};
export const stringifyLatitudeWgs84 = (input: LatitudeWgs84): string => {
    return input.toString();
};
export const validateLatitudeWgs84 = (input: any): typia.IValidation<LatitudeWgs84> => {
    const errors = [] as any[];
    const __is = (input: any): input is LatitudeWgs84 => {
        return "number" === typeof input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LatitudeWgs84 => {
            return "number" === typeof input || $report(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LinearRing
export const assertLinearRing = (input: any): LinearRing => {
    const __is = (input: any): input is LinearRing => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LinearRing => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "LinearRing",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0]
            })) && ($ap0(input[0], _path + "[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0]
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0]
            })) && ((Array.isArray(input[1]) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[1]
            })) && ($ap0(input[1], _path + "[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[1]
            })) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[1]
            })) && ((Array.isArray(input[2]) || $guard(true, {
                path: _path + "[2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[2]
            })) && ($ap0(input[2], _path + "[2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[2]
            })) || $guard(true, {
                path: _path + "[2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[2]
            })) && ((Array.isArray(input[3]) || $guard(true, {
                path: _path + "[3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[3]
            })) && ($ap0(input[3], _path + "[3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[3]
            })) || $guard(true, {
                path: _path + "[3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[3]
            })) && ((Array.isArray(input.slice(4)) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(4)
            })) && input.slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(4)
            }))) || $guard(true, {
                path: _path + "",
                expected: "LinearRing",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLinearRing = (input: any, _exceptionable: boolean = true): input is LinearRing => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0], true && _exceptionable) || false) && (Array.isArray(input[1]) && ($ip0(input[1], true && _exceptionable) || false)) && (Array.isArray(input[2]) && ($ip0(input[2], true && _exceptionable) || false)) && (Array.isArray(input[3]) && ($ip0(input[3], true && _exceptionable) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))));
};
export const isLinearRing = (input: any): input is LinearRing => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
};
export const randomLinearRing = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LinearRing> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    ];
};
export const stringifyLinearRing = (input: LinearRing): string => {
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    return `[${(() => {
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0]
        });
    })()},${(() => {
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[1]
        });
    })()},${(() => {
        if (Array.isArray(input[2]) && (input[2].length === 3 && "number" === typeof input[2][0] && "number" === typeof input[2][1] && "number" === typeof input[2][2]))
            return `[${input[2][0]},${input[2][1]},${input[2][2]}]`;
        if (Array.isArray(input[2]) && (input[2].length === 3 && "number" === typeof input[2][0] && "number" === typeof input[2][1] && "number" === typeof input[2][2]))
            return `[${input[2][0]},${input[2][1]},${input[2][2]}]`;
        if (Array.isArray(input[2]) && (input[2].length === 2 && "number" === typeof input[2][0] && "number" === typeof input[2][1]))
            return `[${input[2][0]},${input[2][1]}]`;
        if (Array.isArray(input[2]) && (input[2].length === 2 && "number" === typeof input[2][0] && "number" === typeof input[2][1]))
            return `[${input[2][0]},${input[2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[2]
        });
    })()},${(() => {
        if (Array.isArray(input[3]) && (input[3].length === 3 && "number" === typeof input[3][0] && "number" === typeof input[3][1] && "number" === typeof input[3][2]))
            return `[${input[3][0]},${input[3][1]},${input[3][2]}]`;
        if (Array.isArray(input[3]) && (input[3].length === 3 && "number" === typeof input[3][0] && "number" === typeof input[3][1] && "number" === typeof input[3][2]))
            return `[${input[3][0]},${input[3][1]},${input[3][2]}]`;
        if (Array.isArray(input[3]) && (input[3].length === 2 && "number" === typeof input[3][0] && "number" === typeof input[3][1]))
            return `[${input[3][0]},${input[3][1]}]`;
        if (Array.isArray(input[3]) && (input[3].length === 2 && "number" === typeof input[3][0] && "number" === typeof input[3][1]))
            return `[${input[3][0]},${input[3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[3]
        });
    })()}${$rest(`[${input.slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`;
};
export const validateLinearRing = (input: any): typia.IValidation<LinearRing> => {
    const errors = [] as any[];
    const __is = (input: any): input is LinearRing => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LinearRing => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "LinearRing",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0]
                })) && ($vp0(input[0], _path + "[0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[0]
                })) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0]
                }),
                (Array.isArray(input[1]) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[1]
                })) && ($vp0(input[1], _path + "[1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[1]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[1]
                })) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[1]
                }),
                (Array.isArray(input[2]) || $report(true, {
                    path: _path + "[2]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[2]
                })) && ($vp0(input[2], _path + "[2]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[2]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[2]
                })) || $report(true, {
                    path: _path + "[2]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[2]
                }),
                (Array.isArray(input[3]) || $report(true, {
                    path: _path + "[3]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[3]
                })) && ($vp0(input[3], _path + "[3]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[3]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[3]
                })) || $report(true, {
                    path: _path + "[3]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[3]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(4)) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(4)
            })) && input.slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(4)
            }))) || $report(true, {
                path: _path + "",
                expected: "LinearRing",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringCoordinates
export const assertLineStringCoordinates = (input: any): LineStringCoordinates => {
    const __is = (input: any): input is LineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0]
            })) && ($ap0(input[0], _path + "[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0]
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0]
            })) && ((Array.isArray(input[1]) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[1]
            })) && ($ap0(input[1], _path + "[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[1]
            })) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[1]
            })) && ((Array.isArray(input.slice(2)) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(2)
            })) && input.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(2)
            }))) || $guard(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringCoordinates = (input: any, _exceptionable: boolean = true): input is LineStringCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0], true && _exceptionable) || false) && (Array.isArray(input[1]) && ($ip0(input[1], true && _exceptionable) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))));
};
export const isLineStringCoordinates = (input: any): input is LineStringCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
};
export const randomLineStringCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LineStringCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    ];
};
export const stringifyLineStringCoordinates = (input: LineStringCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    return `[${(() => {
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0]
        });
    })()},${(() => {
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[1]
        });
    })()}${$rest(`[${input.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`;
};
export const validateLineStringCoordinates = (input: any): typia.IValidation<LineStringCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0]
                })) && ($vp0(input[0], _path + "[0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[0]
                })) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0]
                }),
                (Array.isArray(input[1]) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[1]
                })) && ($vp0(input[1], _path + "[1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[1]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input[1]
                })) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[1]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(2)) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(2)
            })) && input.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.slice(2)
            }))) || $report(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry
export const assertLineStringGeometry = (input: any): LineStringGeometry => {
    const __is = (input: any): input is LineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry = (input: any, _exceptionable: boolean = true): input is LineStringGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry = (input: any): input is LineStringGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LineStringGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry = (input: LineStringGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry = (input: any): typia.IValidation<LineStringGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry2d
export const assertLineStringGeometry2d = (input: any): LineStringGeometry2d => {
    const __is = (input: any): input is LineStringGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry2d = (input: any, _exceptionable: boolean = true): input is LineStringGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry2d = (input: any): input is LineStringGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LineStringGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry2d = (input: LineStringGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry2d = (input: any): typia.IValidation<LineStringGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry3d
export const assertLineStringGeometry3d = (input: any): LineStringGeometry3d => {
    const __is = (input: any): input is LineStringGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry3d = (input: any, _exceptionable: boolean = true): input is LineStringGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry3d = (input: any): input is LineStringGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LineStringGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry3d = (input: LineStringGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry3d = (input: any): typia.IValidation<LineStringGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometryType
export const assertLineStringGeometryType = (input: any): LineStringGeometryType => {
    const __is = (input: any): input is LineStringGeometryType => {
        return "LineString" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "LineString" === input || $guard(true, {
                path: _path + "",
                expected: "\"LineString\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometryType = (input: any, _exceptionable: boolean = true): input is LineStringGeometryType => {
    return "LineString" === input;
};
export const isLineStringGeometryType = (input: any): input is LineStringGeometryType => {
    return "LineString" === input;
};
export const randomLineStringGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LineStringGeometryType> => {
    return "LineString";
};
export const stringifyLineStringGeometryType = (input: LineStringGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input
        });
    })();
};
export const validateLineStringGeometryType = (input: any): typia.IValidation<LineStringGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometryType => {
        return "LineString" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometryType => {
            return "LineString" === input || $report(true, {
                path: _path + "",
                expected: "\"LineString\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LinkedCoordinateReferenceSystem
export const assertLinkedCoordinateReferenceSystem = (input: any): LinkedCoordinateReferenceSystem => {
    const __is = (input: any): input is LinkedCoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LinkedCoordinateReferenceSystem => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao1(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LinkedCoordinateReferenceSystem",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LinkedCoordinateReferenceSystem",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLinkedCoordinateReferenceSystem = (input: any, _exceptionable: boolean = true): input is LinkedCoordinateReferenceSystem => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLinkedCoordinateReferenceSystem = (input: any): input is LinkedCoordinateReferenceSystem => {
    const $io0 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLinkedCoordinateReferenceSystem = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LinkedCoordinateReferenceSystem> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro1(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyLinkedCoordinateReferenceSystem = (input: LinkedCoordinateReferenceSystem): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    return $so0(input);
};
export const validateLinkedCoordinateReferenceSystem = (input: any): typia.IValidation<LinkedCoordinateReferenceSystem> => {
    const errors = [] as any[];
    const __is = (input: any): input is LinkedCoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LinkedCoordinateReferenceSystem => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo1(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LinkedCoordinateReferenceSystem",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LinkedCoordinateReferenceSystem",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Longitude
export const assertLongitude = (input: any): Longitude => {
    const __is = (input: any): input is Longitude => {
        return "number" === typeof input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Longitude => {
            const $guard = (typia.createAssert as any).guard;
            return "number" === typeof input || $guard(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLongitude = (input: any, _exceptionable: boolean = true): input is Longitude => {
    return "number" === typeof input;
};
export const isLongitude = (input: any): input is Longitude => {
    return "number" === typeof input;
};
export const randomLongitude = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Longitude> => {
    const $generator = (typia.createRandom as any).generator;
    return (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100);
};
export const stringifyLongitude = (input: Longitude): string => {
    return input.toString();
};
export const validateLongitude = (input: any): typia.IValidation<Longitude> => {
    const errors = [] as any[];
    const __is = (input: any): input is Longitude => {
        return "number" === typeof input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Longitude => {
            return "number" === typeof input || $report(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LongitudeWgs84
export const assertLongitudeWgs84 = (input: any): LongitudeWgs84 => {
    const __is = (input: any): input is LongitudeWgs84 => {
        return "number" === typeof input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LongitudeWgs84 => {
            const $guard = (typia.createAssert as any).guard;
            return "number" === typeof input || $guard(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLongitudeWgs84 = (input: any, _exceptionable: boolean = true): input is LongitudeWgs84 => {
    return "number" === typeof input;
};
export const isLongitudeWgs84 = (input: any): input is LongitudeWgs84 => {
    return "number" === typeof input;
};
export const randomLongitudeWgs84 = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<LongitudeWgs84> => {
    const $generator = (typia.createRandom as any).generator;
    return (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100);
};
export const stringifyLongitudeWgs84 = (input: LongitudeWgs84): string => {
    return input.toString();
};
export const validateLongitudeWgs84 = (input: any): typia.IValidation<LongitudeWgs84> => {
    const errors = [] as any[];
    const __is = (input: any): input is LongitudeWgs84 => {
        return "number" === typeof input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LongitudeWgs84 => {
            return "number" === typeof input || $report(true, {
                path: _path + "",
                expected: "number",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesMetadata
export const assertMbtilesMetadata = (input: any): MbtilesMetadata => {
    const __is = (input: any): input is MbtilesMetadata => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadata => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.value || $guard(_exceptionable, {
                path: _path + ".value",
                expected: "string",
                value: input.value
            }));
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            })) && input.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) && $ao0(elem, _path + "[" + _index1 + "]", true) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesMetadata = (input: any, _exceptionable: boolean = true): input is MbtilesMetadata => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && "string" === typeof input.value && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "value"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return Array.isArray(input) && input.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io0(elem, true));
};
export const isMbtilesMetadata = (input: any): input is MbtilesMetadata => {
    const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
    return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
};
export const randomMbtilesMetadata = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MbtilesMetadata> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        value: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return (generator?.array ?? $generator.array)(() => $ro0());
};
export const stringifyMbtilesMetadata = (input: MbtilesMetadata): string => {
    const $string = (typia.json.createStringify as any).string;
    return `[${input.map((elem: any) => `{"name":${$string((elem as any).name)},"value":${$string((elem as any).value)}}`).join(",")}]`;
};
export const validateMbtilesMetadata = (input: any): typia.IValidation<MbtilesMetadata> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesMetadata => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadata => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.value || $report(_exceptionable, {
                    path: _path + ".value",
                    expected: "string",
                    value: input.value
                })].every((flag: boolean) => flag);
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            })) && input.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) && $vo0(elem, _path + "[" + _index1 + "]", true) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesMetadataRow
export const assertMbtilesMetadataRow = (input: any): MbtilesMetadataRow => {
    const __is = (input: any): input is MbtilesMetadataRow => {
        return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.value || $guard(_exceptionable, {
                path: _path + ".value",
                expected: "string",
                value: input.value
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesMetadataRow = (input: any, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && "string" === typeof input.value && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "value"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMbtilesMetadataRow = (input: any): input is MbtilesMetadataRow => {
    return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
};
export const randomMbtilesMetadataRow = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MbtilesMetadataRow> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        value: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyMbtilesMetadataRow = (input: MbtilesMetadataRow): string => {
    const $string = (typia.json.createStringify as any).string;
    return `{"name":${$string((input as any).name)},"value":${$string((input as any).value)}}`;
};
export const validateMbtilesMetadataRow = (input: any): typia.IValidation<MbtilesMetadataRow> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesMetadataRow => {
        return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.value || $report(_exceptionable, {
                    path: _path + ".value",
                    expected: "string",
                    value: input.value
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesTilesRow
export const assertMbtilesTilesRow = (input: any): MbtilesTilesRow => {
    const __is = (input: any): input is MbtilesTilesRow => {
        const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesTilesRow => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("number" === typeof input.zoom_level || $guard(_exceptionable, {
                path: _path + ".zoom_level",
                expected: "number",
                value: input.zoom_level
            })) && ("number" === typeof input.tile_column || $guard(_exceptionable, {
                path: _path + ".tile_column",
                expected: "number",
                value: input.tile_column
            })) && ("number" === typeof input.tile_row || $guard(_exceptionable, {
                path: _path + ".tile_row",
                expected: "number",
                value: input.tile_row
            })) && true;
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesTilesRow = (input: any, _exceptionable: boolean = true): input is MbtilesTilesRow => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true && (4 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["zoom_level", "tile_column", "tile_row", "tile_data"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMbtilesTilesRow = (input: any): input is MbtilesTilesRow => {
    const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMbtilesTilesRow = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MbtilesTilesRow> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        zoom_level: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_column: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_row: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_data: "any type used..."
    });
    return $ro0();
};
export const stringifyMbtilesTilesRow = (input: MbtilesTilesRow): string => {
    const $so0 = (input: any): any => `{${undefined === input.tile_data || "function" === typeof input.tile_data ? "" : `"tile_data":${undefined !== input.tile_data ? JSON.stringify(input.tile_data) : undefined},`}"zoom_level":${input.zoom_level},"tile_column":${input.tile_column},"tile_row":${input.tile_row}}`;
    return $so0(input);
};
export const validateMbtilesTilesRow = (input: any): typia.IValidation<MbtilesTilesRow> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesTilesRow => {
        const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesTilesRow => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["number" === typeof input.zoom_level || $report(_exceptionable, {
                    path: _path + ".zoom_level",
                    expected: "number",
                    value: input.zoom_level
                }), "number" === typeof input.tile_column || $report(_exceptionable, {
                    path: _path + ".tile_column",
                    expected: "number",
                    value: input.tile_column
                }), "number" === typeof input.tile_row || $report(_exceptionable, {
                    path: _path + ".tile_row",
                    expected: "number",
                    value: input.tile_row
                }), true].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringCoordinates
export const assertMultiLineStringCoordinates = (input: any): MultiLineStringCoordinates => {
    const __is = (input: any): input is MultiLineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input[0]
            })) && (((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0]
            })) && ($ap0(input[0][0], _path + "[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0]
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0]
            })) && ((Array.isArray(input[0][1]) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][1]
            })) && ($ap0(input[0][1], _path + "[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][1]
            })) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][1]
            })) && ((Array.isArray(input[0].slice(2)) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0].slice(2)
            })) && input[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0].slice(2)
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input[0]
            })) && ((Array.isArray(input.slice(1)) || $guard(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + "[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + "[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringCoordinates = (input: any, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0], true && _exceptionable) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1], true && _exceptionable) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))));
};
export const isMultiLineStringCoordinates = (input: any): input is MultiLineStringCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
};
export const randomMultiLineStringCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiLineStringCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ],
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    ];
};
export const stringifyMultiLineStringCoordinates = (input: MultiLineStringCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    return `[${`[${(() => {
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][1]
        });
    })()}${$rest(`[${input[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`;
};
export const validateMultiLineStringCoordinates = (input: any): typia.IValidation<MultiLineStringCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input[0]
                })) && ([
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0]
                    })) && ($vp0(input[0][0], _path + "[0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][0]
                    })) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0]
                    }),
                    (Array.isArray(input[0][1]) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][1]
                    })) && ($vp0(input[0][1], _path + "[0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][1]
                    })) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input[0].slice(2)) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0].slice(2)
                })) && input[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0].slice(2)
                }))) || $report(true, {
                    path: _path + "[0]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(1)) || $report(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && ([
                (Array.isArray(elem[0]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[0]
                })) && ($vp0(elem[0], _path + "[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem[0]
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[0]
                }),
                (Array.isArray(elem[1]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[1]
                })) && ($vp0(elem[1], _path + "[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem[1]
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[1]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry
export const assertMultiLineStringGeometry = (input: any): MultiLineStringGeometry => {
    const __is = (input: any): input is MultiLineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry = (input: any): input is MultiLineStringGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiLineStringGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry = (input: MultiLineStringGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry = (input: any): typia.IValidation<MultiLineStringGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry2d
export const assertMultiLineStringGeometry2d = (input: any): MultiLineStringGeometry2d => {
    const __is = (input: any): input is MultiLineStringGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry2d = (input: any): input is MultiLineStringGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiLineStringGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry2d = (input: MultiLineStringGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry2d = (input: any): typia.IValidation<MultiLineStringGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry3d
export const assertMultiLineStringGeometry3d = (input: any): MultiLineStringGeometry3d => {
    const __is = (input: any): input is MultiLineStringGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry3d = (input: any): input is MultiLineStringGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiLineStringGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry3d = (input: MultiLineStringGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry3d = (input: any): typia.IValidation<MultiLineStringGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometryType
export const assertMultiLineStringGeometryType = (input: any): MultiLineStringGeometryType => {
    const __is = (input: any): input is MultiLineStringGeometryType => {
        return "MultiLineString" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiLineString" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiLineString\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometryType = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
    return "MultiLineString" === input;
};
export const isMultiLineStringGeometryType = (input: any): input is MultiLineStringGeometryType => {
    return "MultiLineString" === input;
};
export const randomMultiLineStringGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiLineStringGeometryType> => {
    return "MultiLineString";
};
export const stringifyMultiLineStringGeometryType = (input: MultiLineStringGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input
        });
    })();
};
export const validateMultiLineStringGeometryType = (input: any): typia.IValidation<MultiLineStringGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometryType => {
        return "MultiLineString" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
            return "MultiLineString" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiLineString\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointCoordinates
export const assertMultiPointCoordinates = (input: any): MultiPointCoordinates => {
    const __is = (input: any): input is MultiPointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            })) && input.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + _index1 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointCoordinates = (input: any, _exceptionable: boolean = true): input is MultiPointCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && input.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false));
};
export const isMultiPointCoordinates = (input: any): input is MultiPointCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
};
export const randomMultiPointCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPointCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return (generator?.array ?? $generator.array)(() => $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])());
};
export const stringifyMultiPointCoordinates = (input: MultiPointCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return `[${input.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`;
};
export const validateMultiPointCoordinates = (input: any): typia.IValidation<MultiPointCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            })) && input.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + _index1 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry
export const assertMultiPointGeometry = (input: any): MultiPointGeometry => {
    const __is = (input: any): input is MultiPointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry = (input: any): input is MultiPointGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPointGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    return $ro0();
};
export const stringifyMultiPointGeometry = (input: MultiPointGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry = (input: any): typia.IValidation<MultiPointGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry2d
export const assertMultiPointGeometry2d = (input: any): MultiPointGeometry2d => {
    const __is = (input: any): input is MultiPointGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry2d = (input: any): input is MultiPointGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPointGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    return $ro0();
};
export const stringifyMultiPointGeometry2d = (input: MultiPointGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry2d = (input: any): typia.IValidation<MultiPointGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry3d
export const assertMultiPointGeometry3d = (input: any): MultiPointGeometry3d => {
    const __is = (input: any): input is MultiPointGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry3d = (input: any): input is MultiPointGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPointGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    return $ro0();
};
export const stringifyMultiPointGeometry3d = (input: MultiPointGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry3d = (input: any): typia.IValidation<MultiPointGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometryType
export const assertMultiPointGeometryType = (input: any): MultiPointGeometryType => {
    const __is = (input: any): input is MultiPointGeometryType => {
        return "MultiPoint" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiPoint" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiPoint\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometryType = (input: any, _exceptionable: boolean = true): input is MultiPointGeometryType => {
    return "MultiPoint" === input;
};
export const isMultiPointGeometryType = (input: any): input is MultiPointGeometryType => {
    return "MultiPoint" === input;
};
export const randomMultiPointGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPointGeometryType> => {
    return "MultiPoint";
};
export const stringifyMultiPointGeometryType = (input: MultiPointGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input
        });
    })();
};
export const validateMultiPointGeometryType = (input: any): typia.IValidation<MultiPointGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometryType => {
        return "MultiPoint" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometryType => {
            return "MultiPoint" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiPoint\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonCoordinates
export const assertMultiPolygonCoordinates = (input: any): MultiPolygonCoordinates => {
    const __is = (input: any): input is MultiPolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input[0]
            })) && ((input[0].length === 1 || $guard(true, {
                path: _path + "[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input[0]
            })) && ((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input[0][0]
            })) && (((Array.isArray(input[0][0][0]) || $guard(true, {
                path: _path + "[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][0]
            })) && ($ap0(input[0][0][0], _path + "[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0][0]
            })) || $guard(true, {
                path: _path + "[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][0]
            })) && ((Array.isArray(input[0][0][1]) || $guard(true, {
                path: _path + "[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][1]
            })) && ($ap0(input[0][0][1], _path + "[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0][1]
            })) || $guard(true, {
                path: _path + "[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][1]
            })) && ((Array.isArray(input[0][0][2]) || $guard(true, {
                path: _path + "[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][2]
            })) && ($ap0(input[0][0][2], _path + "[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0][2]
            })) || $guard(true, {
                path: _path + "[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][2]
            })) && ((Array.isArray(input[0][0][3]) || $guard(true, {
                path: _path + "[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][3]
            })) && ($ap0(input[0][0][3], _path + "[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0][3]
            })) || $guard(true, {
                path: _path + "[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0][3]
            })) && ((Array.isArray(input[0][0].slice(4)) || $guard(true, {
                path: _path + "[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0].slice(4)
            })) && input[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0].slice(4)
            }))) || $guard(true, {
                path: _path + "[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input[0][0]
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input[0]
            })) && ((Array.isArray(input.slice(1)) || $guard(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + "[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + "[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + "[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + "[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonCoordinates = (input: any, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0], true && _exceptionable) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))));
};
export const isMultiPolygonCoordinates = (input: any): input is MultiPolygonCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
};
export const randomMultiPolygonCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPolygonCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ],
        [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    ];
};
export const stringifyMultiPolygonCoordinates = (input: MultiPolygonCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    return `[${`[${`[${(() => {
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 3 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1] && "number" === typeof input[0][0][0][2]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]},${input[0][0][0][2]}]`;
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 3 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1] && "number" === typeof input[0][0][0][2]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]},${input[0][0][0][2]}]`;
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 2 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]}]`;
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 2 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 3 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1] && "number" === typeof input[0][0][1][2]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]},${input[0][0][1][2]}]`;
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 3 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1] && "number" === typeof input[0][0][1][2]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]},${input[0][0][1][2]}]`;
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 2 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]}]`;
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 2 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 3 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1] && "number" === typeof input[0][0][2][2]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]},${input[0][0][2][2]}]`;
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 3 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1] && "number" === typeof input[0][0][2][2]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]},${input[0][0][2][2]}]`;
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 2 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]}]`;
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 2 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 3 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1] && "number" === typeof input[0][0][3][2]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]},${input[0][0][3][2]}]`;
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 3 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1] && "number" === typeof input[0][0][3][2]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]},${input[0][0][3][2]}]`;
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 2 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]}]`;
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 2 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0][3]
        });
    })()}${$rest(`[${input[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`;
};
export const validateMultiPolygonCoordinates = (input: any): typia.IValidation<MultiPolygonCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input[0]
                })) && ((input[0].length === 1 || $report(true, {
                    path: _path + "[0]",
                    expected: "[LinearRing<Coordinate>]",
                    value: input[0]
                })) && [
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "LinearRing<Coordinate>",
                        value: input[0][0]
                    })) && ([
                        (Array.isArray(input[0][0][0]) || $report(true, {
                            path: _path + "[0][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][0]
                        })) && ($vp0(input[0][0][0], _path + "[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input[0][0][0]
                        })) || $report(true, {
                            path: _path + "[0][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][0]
                        }),
                        (Array.isArray(input[0][0][1]) || $report(true, {
                            path: _path + "[0][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][1]
                        })) && ($vp0(input[0][0][1], _path + "[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input[0][0][1]
                        })) || $report(true, {
                            path: _path + "[0][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][1]
                        }),
                        (Array.isArray(input[0][0][2]) || $report(true, {
                            path: _path + "[0][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][2]
                        })) && ($vp0(input[0][0][2], _path + "[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input[0][0][2]
                        })) || $report(true, {
                            path: _path + "[0][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][2]
                        }),
                        (Array.isArray(input[0][0][3]) || $report(true, {
                            path: _path + "[0][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][3]
                        })) && ($vp0(input[0][0][3], _path + "[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input[0][0][3]
                        })) || $report(true, {
                            path: _path + "[0][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input[0][0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input[0][0].slice(4)) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0].slice(4)
                    })) && input[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + "[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(true, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0].slice(4)
                    }))) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "LinearRing<Coordinate>",
                        value: input[0][0]
                    })
                ].every((flag: boolean) => flag)) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(1)) || $report(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && [
                (Array.isArray(elem[0]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "LinearRing<Coordinate>",
                    value: elem[0]
                })) && ([
                    (Array.isArray(elem[0][0]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][0]
                    })) && ($vp0(elem[0][0], _path + "[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0][0]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][0]
                    }),
                    (Array.isArray(elem[0][1]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][1]
                    })) && ($vp0(elem[0][1], _path + "[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0][1]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][1]
                    }),
                    (Array.isArray(elem[0][2]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][2]
                    })) && ($vp0(elem[0][2], _path + "[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0][2]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][2]
                    }),
                    (Array.isArray(elem[0][3]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][3]
                    })) && ($vp0(elem[0][3], _path + "[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem[0][3]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0][3]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[0].slice(4)
                })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem[0].slice(4)
                }))) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "LinearRing<Coordinate>",
                    value: elem[0]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry
export const assertMultiPolygonGeometry = (input: any): MultiPolygonGeometry => {
    const __is = (input: any): input is MultiPolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[LinearRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry = (input: any): input is MultiPolygonGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPolygonGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry = (input: MultiPolygonGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry = (input: any): typia.IValidation<MultiPolygonGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[LinearRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry2d
export const assertMultiPolygonGeometry2d = (input: any): MultiPolygonGeometry2d => {
    const __is = (input: any): input is MultiPolygonGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[LinearRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry2d = (input: any): input is MultiPolygonGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPolygonGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry2d = (input: MultiPolygonGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry2d = (input: any): typia.IValidation<MultiPolygonGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[LinearRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry3d
export const assertMultiPolygonGeometry3d = (input: any): MultiPolygonGeometry3d => {
    const __is = (input: any): input is MultiPolygonGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[LinearRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[LinearRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "LinearRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry3d = (input: any): input is MultiPolygonGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPolygonGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry3d = (input: MultiPolygonGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry3d = (input: any): typia.IValidation<MultiPolygonGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[LinearRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "LinearRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[LinearRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometryType
export const assertMultiPolygonGeometryType = (input: any): MultiPolygonGeometryType => {
    const __is = (input: any): input is MultiPolygonGeometryType => {
        return "MultiPolygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiPolygon" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiPolygon\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometryType = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
    return "MultiPolygon" === input;
};
export const isMultiPolygonGeometryType = (input: any): input is MultiPolygonGeometryType => {
    return "MultiPolygon" === input;
};
export const randomMultiPolygonGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<MultiPolygonGeometryType> => {
    return "MultiPolygon";
};
export const stringifyMultiPolygonGeometryType = (input: MultiPolygonGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input
        });
    })();
};
export const validateMultiPolygonGeometryType = (input: any): typia.IValidation<MultiPolygonGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometryType => {
        return "MultiPolygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
            return "MultiPolygon" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiPolygon\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// NamedCoordinateReferenceSystem
export const assertNamedCoordinateReferenceSystem = (input: any): NamedCoordinateReferenceSystem => {
    const __is = (input: any): input is NamedCoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is NamedCoordinateReferenceSystem => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao1(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "NamedCoordinateReferenceSystem",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "NamedCoordinateReferenceSystem",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsNamedCoordinateReferenceSystem = (input: any, _exceptionable: boolean = true): input is NamedCoordinateReferenceSystem => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io1(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isNamedCoordinateReferenceSystem = (input: any): input is NamedCoordinateReferenceSystem => {
    const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomNamedCoordinateReferenceSystem = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<NamedCoordinateReferenceSystem> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro1(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyNamedCoordinateReferenceSystem = (input: NamedCoordinateReferenceSystem): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.name;
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    return $so0(input);
};
export const validateNamedCoordinateReferenceSystem = (input: any): typia.IValidation<NamedCoordinateReferenceSystem> => {
    const errors = [] as any[];
    const __is = (input: any): input is NamedCoordinateReferenceSystem => {
        const $io0 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is NamedCoordinateReferenceSystem => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo1(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "NamedCoordinateReferenceSystem",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "NamedCoordinateReferenceSystem",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointCoordinates
export const assertPointCoordinates = (input: any): PointCoordinates => {
    const __is = (input: any): input is PointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointCoordinates = (input: any, _exceptionable: boolean = true): input is PointCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isPointCoordinates = (input: any): input is PointCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomPointCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyPointCoordinates = (input: PointCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input
        });
    })();
};
export const validatePointCoordinates = (input: any): typia.IValidation<PointCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeature
export const assertPointFeature = (input: any): PointFeature => {
    const __is = (input: any): input is PointFeature => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io6(input.properties));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io2 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io4 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io6 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io4(input);
            else if ("name" === input.type)
                return $io2(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $ap1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            })) && (undefined === input.bbox || (Array.isArray(input.bbox) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && ($ap0(input.bbox, _path + ".bbox", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                value: input.bbox
            })) || $guard(_exceptionable, {
                path: _path + ".bbox",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                value: input.bbox
            })) && (undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.crs
            })) && $au0(input.crs, _path + ".crs", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".crs",
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                value: input.crs
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao6(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("name" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"name\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type",
                value: input.properties
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => "string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            });
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("link" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"link\"",
                value: input.type
            })) && (("object" === typeof input.properties && null !== input.properties || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            })) && $ao5(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "__type.o1",
                value: input.properties
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.href || $guard(_exceptionable, {
                path: _path + ".href",
                expected: "string",
                value: input.href
            })) && ("string" === typeof input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "string",
                value: input.type
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeature = (input: any, _exceptionable: boolean = true): input is PointFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox, true && _exceptionable) || false)) && (undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io6(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "id", "bbox", "crs", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && (1 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io5(input.properties, true && _exceptionable)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "properties"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.href && "string" === typeof input.type && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["href", "type"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("link" === input.type)
            return $io4(input, true && _exceptionable);
        else if ("name" === input.type)
            return $io2(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeature = (input: any): input is PointFeature => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io6(input.properties));
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io2 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
    const $io4 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
    const $io6 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io4(input);
        else if ("name" === input.type)
            return $io2(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointFeature> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bbox: $pick([
            () => undefined,
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        crs: $pick([
            () => undefined,
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "name",
        properties: $ro3(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "link",
        properties: $ro5(_recursive, _recursive ? 1 + _depth : _depth)
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        href: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        type: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeature = (input: PointFeature): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
    const $io2 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && $io3(input.properties));
    const $io3 = (input: any): boolean => "string" === typeof input.name;
    const $io4 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && $io5(input.properties));
    const $io5 = (input: any): boolean => "string" === typeof input.href && "string" === typeof input.type;
    const $io6 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $io4(input);
        else if ("name" === input.type)
            return $io2(input);
        else
            return false;
    })();
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const,
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $ip1 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}${undefined === input.bbox ? "" : `"bbox":${undefined !== input.bbox ? (() => {
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 6 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3] && "number" === typeof input.bbox[4] && "number" === typeof input.bbox[5]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]},${input.bbox[4]},${input.bbox[5]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        if (Array.isArray(input.bbox) && (input.bbox.length === 4 && "number" === typeof input.bbox[0] && "number" === typeof input.bbox[1] && "number" === typeof input.bbox[2] && "number" === typeof input.bbox[3]))
            return `[${input.bbox[0]},${input.bbox[1]},${input.bbox[2]},${input.bbox[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
            value: input.bbox
        });
    })() : undefined},`}${undefined === input.crs ? "" : `"crs":${undefined !== input.crs ? $su0(input.crs) : undefined},`}${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so6(input.properties) : "null" : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"name\"",
            value: input.type
        });
    })()},"properties":${`{"name":${$string((input.properties as any).name)}}`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"link\"",
            value: input.type
        });
    })()},"properties":${`{"href":${$string((input.properties as any).href)},"type":${$string((input.properties as any).type)}}`}}`;
    const $so6 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $su0 = (input: any): any => (() => {
        if ("link" === input.type)
            return $so4(input);
        else if ("name" === input.type)
            return $so2(input);
        else
            $throws({
                expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                value: input
            });
    })();
    return $so0(input);
};
export const validatePointFeature = (input: any): typia.IValidation<PointFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeature => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const,
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $ip1 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (undefined === input.bbox || Array.isArray(input.bbox) && ($ip0(input.bbox) || false)) && (undefined === input.crs || "object" === typeof input.crs && null !== input.crs && $iu0(input.crs)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io6(input.properties));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip1(input.coordinates) || false));
        const $io2 = (input: any): boolean => "name" === input.type && ("object" === typeof input.properties && null !== input.properties && "string" === typeof (input.properties as any).name);
        const $io4 = (input: any): boolean => "link" === input.type && ("object" === typeof input.properties && null !== input.properties && ("string" === typeof (input.properties as any).href && "string" === typeof (input.properties as any).type));
        const $io6 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("link" === input.type)
                return $io4(input);
            else if ("name" === input.type)
                return $io2(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            const $vp1 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                }), undefined === input.bbox || (Array.isArray(input.bbox) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                })) && ($vp0(input.bbox, _path + ".bbox", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | [west: number, south: number, east: number, north: number]",
                    value: input.bbox
                })) || $report(_exceptionable, {
                    path: _path + ".bbox",
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number] | readonly [west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | readonly [west: number, south: number, east: number, north: number] | undefined)",
                    value: input.bbox
                }), undefined === input.crs || ("object" === typeof input.crs && null !== input.crs || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.crs
                })) && $vu0(input.crs, _path + ".crs", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".crs",
                    expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem | undefined)",
                    value: input.crs
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo6(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp1(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["name" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"name\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["link" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"link\"",
                    value: input.type
                }), ("object" === typeof input.properties && null !== input.properties || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })) && $vo5(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "__type.o1",
                    value: input.properties
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.href || $report(_exceptionable, {
                    path: _path + ".href",
                    expected: "string",
                    value: input.href
                }), "string" === typeof input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "string",
                    value: input.type
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("link" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                else if ("name" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(LinkedCoordinateReferenceSystem | NamedCoordinateReferenceSystem)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry
export const assertPointGeometry = (input: any): PointGeometry => {
    const __is = (input: any): input is PointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry = (input: any, _exceptionable: boolean = true): input is PointGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry = (input: any): input is PointGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    return $ro0();
};
export const stringifyPointGeometry = (input: PointGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    return $so0(input);
};
export const validatePointGeometry = (input: any): typia.IValidation<PointGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry2d
export const assertPointGeometry2d = (input: any): PointGeometry2d => {
    const __is = (input: any): input is PointGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry2d = (input: any, _exceptionable: boolean = true): input is PointGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry2d = (input: any): input is PointGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    return $ro0();
};
export const stringifyPointGeometry2d = (input: PointGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    return $so0(input);
};
export const validatePointGeometry2d = (input: any): typia.IValidation<PointGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number] | readonly [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry3d
export const assertPointGeometry3d = (input: any): PointGeometry3d => {
    const __is = (input: any): input is PointGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry3d = (input: any, _exceptionable: boolean = true): input is PointGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry3d = (input: any): input is PointGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    return $ro0();
};
export const stringifyPointGeometry3d = (input: PointGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates
        });
    })()}}`;
    return $so0(input);
};
export const validatePointGeometry3d = (input: any): typia.IValidation<PointGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometryType
export const assertPointGeometryType = (input: any): PointGeometryType => {
    const __is = (input: any): input is PointGeometryType => {
        return "Point" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Point" === input || $guard(true, {
                path: _path + "",
                expected: "\"Point\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometryType = (input: any, _exceptionable: boolean = true): input is PointGeometryType => {
    return "Point" === input;
};
export const isPointGeometryType = (input: any): input is PointGeometryType => {
    return "Point" === input;
};
export const randomPointGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PointGeometryType> => {
    return "Point";
};
export const stringifyPointGeometryType = (input: PointGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Point\"",
            value: input
        });
    })();
};
export const validatePointGeometryType = (input: any): typia.IValidation<PointGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometryType => {
        return "Point" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometryType => {
            return "Point" === input || $report(true, {
                path: _path + "",
                expected: "\"Point\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonCoordinates
export const assertPolygonCoordinates = (input: any): PolygonCoordinates => {
    const __is = (input: any): input is PolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            })) && ((input.length === 1 || $guard(true, {
                path: _path + "",
                expected: "[LinearRing<Coordinate>]",
                value: input
            })) && ((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "LinearRing<Coordinate>",
                value: input[0]
            })) && (((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0]
            })) && ($ap0(input[0][0], _path + "[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][0]
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][0]
            })) && ((Array.isArray(input[0][1]) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][1]
            })) && ($ap0(input[0][1], _path + "[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][1]
            })) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][1]
            })) && ((Array.isArray(input[0][2]) || $guard(true, {
                path: _path + "[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][2]
            })) && ($ap0(input[0][2], _path + "[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][2]
            })) || $guard(true, {
                path: _path + "[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][2]
            })) && ((Array.isArray(input[0][3]) || $guard(true, {
                path: _path + "[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][3]
            })) && ($ap0(input[0][3], _path + "[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input[0][3]
            })) || $guard(true, {
                path: _path + "[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0][3]
            })) && ((Array.isArray(input[0].slice(4)) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0].slice(4)
            })) && input[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input[0].slice(4)
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "LinearRing<Coordinate>",
                value: input[0]
            }))) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonCoordinates = (input: any, _exceptionable: boolean = true): input is PolygonCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0], true && _exceptionable) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1], true && _exceptionable) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2], true && _exceptionable) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3], true && _exceptionable) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))));
};
export const isPolygonCoordinates = (input: any): input is PolygonCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
};
export const randomPolygonCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PolygonCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    ];
};
export const stringifyPolygonCoordinates = (input: PolygonCoordinates): string => {
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    return `[${`[${(() => {
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input[0][2]) && (input[0][2].length === 3 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1] && "number" === typeof input[0][2][2]))
            return `[${input[0][2][0]},${input[0][2][1]},${input[0][2][2]}]`;
        if (Array.isArray(input[0][2]) && (input[0][2].length === 3 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1] && "number" === typeof input[0][2][2]))
            return `[${input[0][2][0]},${input[0][2][1]},${input[0][2][2]}]`;
        if (Array.isArray(input[0][2]) && (input[0][2].length === 2 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1]))
            return `[${input[0][2][0]},${input[0][2][1]}]`;
        if (Array.isArray(input[0][2]) && (input[0][2].length === 2 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1]))
            return `[${input[0][2][0]},${input[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input[0][3]) && (input[0][3].length === 3 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1] && "number" === typeof input[0][3][2]))
            return `[${input[0][3][0]},${input[0][3][1]},${input[0][3][2]}]`;
        if (Array.isArray(input[0][3]) && (input[0][3].length === 3 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1] && "number" === typeof input[0][3][2]))
            return `[${input[0][3][0]},${input[0][3][1]},${input[0][3][2]}]`;
        if (Array.isArray(input[0][3]) && (input[0][3].length === 2 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1]))
            return `[${input[0][3][0]},${input[0][3][1]}]`;
        if (Array.isArray(input[0][3]) && (input[0][3].length === 2 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1]))
            return `[${input[0][3][0]},${input[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input[0][3]
        });
    })()}${$rest(`[${input[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`;
};
export const validatePolygonCoordinates = (input: any): typia.IValidation<PolygonCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            })) && ((input.length === 1 || $report(true, {
                path: _path + "",
                expected: "[LinearRing<Coordinate>]",
                value: input
            })) && [
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "LinearRing<Coordinate>",
                    value: input[0]
                })) && ([
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0]
                    })) && ($vp0(input[0][0], _path + "[0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][0]
                    })) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][0]
                    }),
                    (Array.isArray(input[0][1]) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][1]
                    })) && ($vp0(input[0][1], _path + "[0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][1]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][1]
                    })) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][1]
                    }),
                    (Array.isArray(input[0][2]) || $report(true, {
                        path: _path + "[0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][2]
                    })) && ($vp0(input[0][2], _path + "[0][2]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][2]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][2]
                    })) || $report(true, {
                        path: _path + "[0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][2]
                    }),
                    (Array.isArray(input[0][3]) || $report(true, {
                        path: _path + "[0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][3]
                    })) && ($vp0(input[0][3], _path + "[0][3]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][3]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: input[0][3]
                    })) || $report(true, {
                        path: _path + "[0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input[0][3]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input[0].slice(4)) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0].slice(4)
                })) && input[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                    value: input[0].slice(4)
                }))) || $report(true, {
                    path: _path + "[0]",
                    expected: "LinearRing<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry
export const assertPolygonGeometry = (input: any): PolygonGeometry => {
    const __is = (input: any): input is PolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry = (input: any, _exceptionable: boolean = true): input is PolygonGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry = (input: any): input is PolygonGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PolygonGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry = (input: PolygonGeometry): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry = (input: any): typia.IValidation<PolygonGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number] | readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number] | readonly [x: number, y: number, z: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry2d
export const assertPolygonGeometry2d = (input: any): PolygonGeometry2d => {
    const __is = (input: any): input is PolygonGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number] | readonly [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry2d = (input: any, _exceptionable: boolean = true): input is PolygonGeometry2d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry2d = (input: any): input is PolygonGeometry2d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PolygonGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry2d = (input: PolygonGeometry2d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const,
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number] | readonly [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry2d = (input: any): typia.IValidation<PolygonGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry2d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const,
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry2d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number] | readonly [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "readonly [x: number, y: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number] | readonly [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number] | readonly [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry3d
export const assertPolygonGeometry3d = (input: any): PolygonGeometry3d => {
    const __is = (input: any): input is PolygonGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[LinearRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LinearRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry3d = (input: any, _exceptionable: boolean = true): input is PolygonGeometry3d => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry3d = (input: any): input is PolygonGeometry3d => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PolygonGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry3d = (input: PolygonGeometry3d): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $rest = (typia.json.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const,
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ] as const
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry3d = (input: any): typia.IValidation<PolygonGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry3d => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const,
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ] as const
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry3d => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const,
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ] as const
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(readonly [x: number, y: number, z: number] | [x: number, y: number, z: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[LinearRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "readonly [x: number, y: number, z: number] | [x: number, y: number, z: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | readonly [x: number, y: number, z: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LinearRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometryType
export const assertPolygonGeometryType = (input: any): PolygonGeometryType => {
    const __is = (input: any): input is PolygonGeometryType => {
        return "Polygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Polygon" === input || $guard(true, {
                path: _path + "",
                expected: "\"Polygon\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometryType = (input: any, _exceptionable: boolean = true): input is PolygonGeometryType => {
    return "Polygon" === input;
};
export const isPolygonGeometryType = (input: any): input is PolygonGeometryType => {
    return "Polygon" === input;
};
export const randomPolygonGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<PolygonGeometryType> => {
    return "Polygon";
};
export const stringifyPolygonGeometryType = (input: PolygonGeometryType): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input
        });
    })();
};
export const validatePolygonGeometryType = (input: any): typia.IValidation<PolygonGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometryType => {
        return "Polygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometryType => {
            return "Polygon" === input || $report(true, {
                path: _path + "",
                expected: "\"Polygon\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// SimpleStyleProperties
export const assertSimpleStyleProperties = (input: any): SimpleStyleProperties => {
    const __is = (input: any): input is SimpleStyleProperties => {
        const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
            if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is SimpleStyleProperties => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => (undefined === input.title || "string" === typeof input.title || $guard(_exceptionable, {
                path: _path + ".title",
                expected: "(string | undefined)",
                value: input.title
            })) && (undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(string | undefined)",
                value: input.description
            })) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"] || $guard(_exceptionable, {
                path: _path + "[\"marker-size\"]",
                expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
                value: input["marker-size"]
            })) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"] || $guard(_exceptionable, {
                path: _path + "[\"marker-symbol\"]",
                expected: "(string | undefined)",
                value: input["marker-symbol"]
            })) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"] || $guard(_exceptionable, {
                path: _path + "[\"marker-color\"]",
                expected: "(string | undefined)",
                value: input["marker-color"]
            })) && (undefined === input.stroke || "string" === typeof input.stroke || $guard(_exceptionable, {
                path: _path + ".stroke",
                expected: "(string | undefined)",
                value: input.stroke
            })) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"] || $guard(_exceptionable, {
                path: _path + "[\"stroke-opacity\"]",
                expected: "(number | undefined)",
                value: input["stroke-opacity"]
            })) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"] || $guard(_exceptionable, {
                path: _path + "[\"stroke-width\"]",
                expected: "(number | undefined)",
                value: input["stroke-width"]
            })) && (undefined === input.fill || "string" === typeof input.fill || $guard(_exceptionable, {
                path: _path + ".fill",
                expected: "(string | undefined)",
                value: input.fill
            })) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"] || $guard(_exceptionable, {
                path: _path + "[\"fill-opacity\"]",
                expected: "(number | undefined)",
                value: input["fill-opacity"]
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
                    return true;
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsSimpleStyleProperties = (input: any, _exceptionable: boolean = true): input is SimpleStyleProperties => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
        if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isSimpleStyleProperties = (input: any): input is SimpleStyleProperties => {
    const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
        if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomSimpleStyleProperties = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<SimpleStyleProperties> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            title: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            description: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "marker-size": $pick([
                () => undefined,
                () => "small",
                () => "medium",
                () => "large"
            ])(),
            "marker-symbol": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "marker-color": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            stroke: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "stroke-opacity": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            "stroke-width": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            fill: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "fill-opacity": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "any type used...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifySimpleStyleProperties = (input: SimpleStyleProperties): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $tail = (typia.json.createStringify as any).tail;
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.title ? "" : `"title":${undefined !== input.title ? $string(input.title) : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? $string(input.description) : undefined},`}${undefined === input["marker-size"] ? "" : `"marker-size":${undefined !== input["marker-size"] ? (() => {
        if ("string" === typeof input["marker-size"])
            return $string(input["marker-size"]);
        if ("string" === typeof input["marker-size"])
            return "\"" + input["marker-size"] + "\"";
        $throws({
            expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
            value: input["marker-size"]
        });
    })() : undefined},`}${undefined === input["marker-symbol"] ? "" : `"marker-symbol":${undefined !== input["marker-symbol"] ? $string(input["marker-symbol"]) : undefined},`}${undefined === input["marker-color"] ? "" : `"marker-color":${undefined !== input["marker-color"] ? $string(input["marker-color"]) : undefined},`}${undefined === input.stroke ? "" : `"stroke":${undefined !== input.stroke ? $string(input.stroke) : undefined},`}${undefined === input["stroke-opacity"] ? "" : `"stroke-opacity":${undefined !== input["stroke-opacity"] ? input["stroke-opacity"] : undefined},`}${undefined === input["stroke-width"] ? "" : `"stroke-width":${undefined !== input["stroke-width"] ? input["stroke-width"] : undefined},`}${undefined === input.fill ? "" : `"fill":${undefined !== input.fill ? $string(input.fill) : undefined},`}${undefined === input["fill-opacity"] ? "" : `"fill-opacity":${undefined !== input["fill-opacity"] ? input["fill-opacity"] : undefined},`}${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateSimpleStyleProperties = (input: any): typia.IValidation<SimpleStyleProperties> => {
    const errors = [] as any[];
    const __is = (input: any): input is SimpleStyleProperties => {
        const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
            if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
                return true;
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is SimpleStyleProperties => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [undefined === input.title || "string" === typeof input.title || $report(_exceptionable, {
                    path: _path + ".title",
                    expected: "(string | undefined)",
                    value: input.title
                }), undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(string | undefined)",
                    value: input.description
                }), undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"] || $report(_exceptionable, {
                    path: _path + "[\"marker-size\"]",
                    expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
                    value: input["marker-size"]
                }), undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"] || $report(_exceptionable, {
                    path: _path + "[\"marker-symbol\"]",
                    expected: "(string | undefined)",
                    value: input["marker-symbol"]
                }), undefined === input["marker-color"] || "string" === typeof input["marker-color"] || $report(_exceptionable, {
                    path: _path + "[\"marker-color\"]",
                    expected: "(string | undefined)",
                    value: input["marker-color"]
                }), undefined === input.stroke || "string" === typeof input.stroke || $report(_exceptionable, {
                    path: _path + ".stroke",
                    expected: "(string | undefined)",
                    value: input.stroke
                }), undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"] || $report(_exceptionable, {
                    path: _path + "[\"stroke-opacity\"]",
                    expected: "(number | undefined)",
                    value: input["stroke-opacity"]
                }), undefined === input["stroke-width"] || "number" === typeof input["stroke-width"] || $report(_exceptionable, {
                    path: _path + "[\"stroke-width\"]",
                    expected: "(number | undefined)",
                    value: input["stroke-width"]
                }), undefined === input.fill || "string" === typeof input.fill || $report(_exceptionable, {
                    path: _path + ".fill",
                    expected: "(string | undefined)",
                    value: input.fill
                }), undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"] || $report(_exceptionable, {
                    path: _path + "[\"fill-opacity\"]",
                    expected: "(number | undefined)",
                    value: input["fill-opacity"]
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
                        return true;
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300
export const assertTilejson300 = (input: any): Tilejson300 => {
    const __is = (input: any): input is Tilejson300 => {
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $iu0 = (input: any): any => (() => {
            if ("pbf" === input.format)
                return $io3(input);
            else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300 => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "\"pbf\"",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index7: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index7 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index7 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index7 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index8: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index8 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index9: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index9 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index10: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index10 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index11: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index11 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index12: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index12 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("pbf" === input.format)
                    return $ao3(input, _path, true && _exceptionable);
                else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                    return $ao0(input, _path, true && _exceptionable);
                else
                    return $guard(_exceptionable, {
                        path: _path,
                        expected: "(Tilejson300Vector | Tilejson300Raster)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300 = (input: any, _exceptionable: boolean = true): input is Tilejson300 => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index7: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index8: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index9: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index10: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index11: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index12: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("pbf" === input.format)
            return $io3(input, true && _exceptionable);
        else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $io0(input, true && _exceptionable);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isTilejson300 = (input: any): input is Tilejson300 => {
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $iu0 = (input: any): any => (() => {
        if ("pbf" === input.format)
            return $io3(input);
        else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $io0(input);
        else
            return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomTilejson300 = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Tilejson300> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp"
        ])(),
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: "pbf",
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    return $pick([
        () => $ro3(),
        () => $ro0()
    ])();
};
export const stringifyTilejson300 = (input: Tilejson300): string => {
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $so3 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("pbf" === input.format)
            return $so3(input);
        else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $so0(input);
        else
            $throws({
                expected: "(Tilejson300Vector | Tilejson300Raster)",
                value: input
            });
    })();
    return $su0(input);
};
export const validateTilejson300 = (input: any): typia.IValidation<Tilejson300> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300 => {
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $iu0 = (input: any): any => (() => {
            if ("pbf" === input.format)
                return $io3(input);
            else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                return $io0(input);
            else
                return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300 => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["png" === input.format || "jpg" === input.format || "webp" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"png\" | \"webp\")",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "\"pbf\"",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index7: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index7 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index7 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index7 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index8: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index8 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index9: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index9 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index10: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index10 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index11: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index11 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index12: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index12 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("pbf" === input.format)
                    return $vo3(input, _path, true && _exceptionable);
                else if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                    return $vo0(input, _path, true && _exceptionable);
                else
                    return $report(_exceptionable, {
                        path: _path,
                        expected: "(Tilejson300Vector | Tilejson300Raster)",
                        value: input
                    });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300Raster
export const assertTilejson300Raster = (input: any): Tilejson300Raster => {
    const __is = (input: any): input is Tilejson300Raster => {
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Raster => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300Raster = (input: any, _exceptionable: boolean = true): input is Tilejson300Raster => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejson300Raster = (input: any): input is Tilejson300Raster => {
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejson300Raster = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Tilejson300Raster> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp"
        ])(),
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejson300Raster = (input: Tilejson300Raster): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejson300Raster = (input: any): typia.IValidation<Tilejson300Raster> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300Raster => {
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Raster => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["png" === input.format || "jpg" === input.format || "webp" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"png\" | \"webp\")",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300Vector
export const assertTilejson300Vector = (input: any): Tilejson300Vector => {
    const __is = (input: any): input is Tilejson300Vector => {
        const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Vector => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "\"pbf\"",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300Vector = (input: any, _exceptionable: boolean = true): input is Tilejson300Vector => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejson300Vector = (input: any): input is Tilejson300Vector => {
    const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejson300Vector = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<Tilejson300Vector> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: "pbf",
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejson300Vector = (input: Tilejson300Vector): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejson300Vector = (input: any): typia.IValidation<Tilejson300Vector> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300Vector => {
        const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Vector => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "\"pbf\"",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonCommon
export const assertTilejsonCommon = (input: any): TilejsonCommon => {
    const __is = (input: any): input is TilejsonCommon => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonCommon => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
                value: input.format
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index1 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index2 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index2 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index2 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonCommon = (input: any, _exceptionable: boolean = true): input is TilejsonCommon => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index2: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "format", "tilejson", "tiles", "vector_layers", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejsonCommon = (input: any): input is TilejsonCommon => {
    const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejsonCommon = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<TilejsonCommon> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp",
            () => "pbf"
        ])(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejsonCommon = (input: TilejsonCommon): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"name":${$string(input.name)},"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejsonCommon = (input: any): typia.IValidation<TilejsonCommon> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonCommon => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonCommon => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
                    value: input.format
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index1: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index1 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index2 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index2 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index2 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonRasterFormat
export const assertTilejsonRasterFormat = (input: any): TilejsonRasterFormat => {
    const __is = (input: any): input is TilejsonRasterFormat => {
        return "png" === input || "jpg" === input || "webp" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
            const $guard = (typia.createAssert as any).guard;
            return "png" === input || "jpg" === input || "webp" === input || $guard(true, {
                path: _path + "",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonRasterFormat = (input: any, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
    return "png" === input || "jpg" === input || "webp" === input;
};
export const isTilejsonRasterFormat = (input: any): input is TilejsonRasterFormat => {
    return "png" === input || "jpg" === input || "webp" === input;
};
export const randomTilejsonRasterFormat = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<TilejsonRasterFormat> => {
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => "png",
        () => "jpg",
        () => "webp"
    ])();
};
export const stringifyTilejsonRasterFormat = (input: TilejsonRasterFormat): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input
        });
    })();
};
export const validateTilejsonRasterFormat = (input: any): typia.IValidation<TilejsonRasterFormat> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonRasterFormat => {
        return "png" === input || "jpg" === input || "webp" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
            return "png" === input || "jpg" === input || "webp" === input || $report(true, {
                path: _path + "",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorFormat
export const assertTilejsonVectorFormat = (input: any): TilejsonVectorFormat => {
    const __is = (input: any): input is TilejsonVectorFormat => {
        return "pbf" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
            const $guard = (typia.createAssert as any).guard;
            return "pbf" === input || $guard(true, {
                path: _path + "",
                expected: "\"pbf\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorFormat = (input: any, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
    return "pbf" === input;
};
export const isTilejsonVectorFormat = (input: any): input is TilejsonVectorFormat => {
    return "pbf" === input;
};
export const randomTilejsonVectorFormat = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<TilejsonVectorFormat> => {
    return "pbf";
};
export const stringifyTilejsonVectorFormat = (input: TilejsonVectorFormat): string => {
    const $string = (typia.json.createStringify as any).string;
    const $throws = (typia.json.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input
        });
    })();
};
export const validateTilejsonVectorFormat = (input: any): typia.IValidation<TilejsonVectorFormat> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorFormat => {
        return "pbf" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
            return "pbf" === input || $report(true, {
                path: _path + "",
                expected: "\"pbf\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorLayer
export const assertTilejsonVectorLayer = (input: any): TilejsonVectorLayer => {
    const __is = (input: any): input is TilejsonVectorLayer => {
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao1(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorLayer = (input: any, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejsonVectorLayer = (input: any): input is TilejsonVectorLayer => {
    const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejsonVectorLayer = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<TilejsonVectorLayer> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejsonVectorLayer = (input: TilejsonVectorLayer): string => {
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $so0 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so1(input.fields)}}`;
    const $so1 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejsonVectorLayer = (input: any): typia.IValidation<TilejsonVectorLayer> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorLayer => {
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo1(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorLayers
export const assertTilejsonVectorLayers = (input: any): TilejsonVectorLayers => {
    const __is = (input: any): input is TilejsonVectorLayers => {
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao1(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            })) && input.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao0(elem, _path + "[" + _index1 + "]", true) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorLayers = (input: any, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return Array.isArray(input) && input.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io0(elem, true));
};
export const isTilejsonVectorLayers = (input: any): input is TilejsonVectorLayers => {
    const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
};
export const randomTilejsonVectorLayers = (generator?: Partial<typia.IRandomGenerator>): typia.Resolved<TilejsonVectorLayers> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return (generator?.array ?? $generator.array)(() => $ro0());
};
export const stringifyTilejsonVectorLayers = (input: TilejsonVectorLayers): string => {
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.json.createStringify as any).string;
    const $so0 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so1(input.fields)}}`;
    const $so1 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return `[${input.map((elem: any) => $so0(elem)).join(",")}]`;
};
export const validateTilejsonVectorLayers = (input: any): typia.IValidation<TilejsonVectorLayers> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorLayers => {
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo1(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            })) && input.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $vo0(elem, _path + "[" + _index1 + "]", true) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
