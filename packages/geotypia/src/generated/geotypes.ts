// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
import typia from 'typia';
import type { BBox, BBox2d, BBox3d, Coordinate, Coordinate2d, Coordinate3d, DeckglTilejson, Feature, FeatureCollection, FeatureCollectionType, FeatureType, GeoJsonProperties, Geometry, Geometry2d, Geometry3d, GeometryCollection, GeometryCollectionType, GeometryType, Geostats, GeostatsAttribute, GeostatsLayer, LineStringCoordinates, LineStringFeature, LineStringFeature2d, LineStringFeature3d, LineStringFeatureCollection, LineStringFeatureCollection2d, LineStringFeatureCollection3d, LineStringGeometry, LineStringGeometry2d, LineStringGeometry3d, LineStringGeometryType, MbtilesMetadata, MbtilesMetadataRow, MbtilesTilesRow, MultiLineStringCoordinates, MultiLineStringFeature, MultiLineStringFeature2d, MultiLineStringFeature3d, MultiLineStringFeatureCollection, MultiLineStringFeatureCollection2d, MultiLineStringFeatureCollection3d, MultiLineStringGeometry, MultiLineStringGeometry2d, MultiLineStringGeometry3d, MultiLineStringGeometryType, MultiPointCoordinates, MultiPointFeature, MultiPointFeature2d, MultiPointFeature3d, MultiPointFeatureCollection, MultiPointFeatureCollection2d, MultiPointFeatureCollection3d, MultiPointGeometry, MultiPointGeometry2d, MultiPointGeometry3d, MultiPointGeometryType, MultiPolygonCoordinates, MultiPolygonFeature, MultiPolygonFeature2d, MultiPolygonFeature3d, MultiPolygonFeatureCollection, MultiPolygonFeatureCollection2d, MultiPolygonFeatureCollection3d, MultiPolygonGeometry, MultiPolygonGeometry2d, MultiPolygonGeometry3d, MultiPolygonGeometryType, PointCoordinates, PointFeature, PointFeature2d, PointFeature3d, PointFeatureCollection, PointFeatureCollection2d, PointFeatureCollection3d, PointGeometry, PointGeometry2d, PointGeometry3d, PointGeometryType, PolygonCoordinates, PolygonCoordinatesRing, PolygonFeature, PolygonFeature2d, PolygonFeature3d, PolygonFeatureCollection, PolygonFeatureCollection2d, PolygonFeatureCollection3d, PolygonGeometry, PolygonGeometry2d, PolygonGeometry3d, PolygonGeometryType, SimpleStyleProperties, Tilejson300, Tilejson300Raster, Tilejson300Vector, TilejsonCommon, TilejsonRasterFormat, TilejsonVectorFormat, TilejsonVectorLayer, TilejsonVectorLayers, } from '@jsse/geotypes';
// BBox
export const assertBBox = (input: any): BBox => {
    const __is = (input: any): input is BBox => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ],
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                        (entire: any[]): any => (entire.length === 6 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        })) && ("number" === typeof entire[4] || $guard(_exceptionable, {
                            path: _path + "[4]",
                            expected: "number",
                            value: entire[4]
                        })) && ("number" === typeof entire[5] || $guard(_exceptionable, {
                            path: _path + "[5]",
                            expected: "number",
                            value: entire[5]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                        (entire: any[]): any => (entire.length === 4 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        })) && ("number" === typeof entire[3] || $guard(_exceptionable, {
                            path: _path + "[3]",
                            expected: "number",
                            value: entire[3]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "[west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox = (input: any, _exceptionable: boolean = true): input is BBox => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ],
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isBBox = (input: any): input is BBox => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
            ],
            [
                (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomBBox = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<BBox> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyBBox = (input: BBox): string => {
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
        if (Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]))
            return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
        $throws({
            expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
            value: input
        });
    })();
};
export const validateBBox = (input: any): typia.IValidation<BBox> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 6 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3] && "number" === typeof top[4] && "number" === typeof top[5],
                    (entire: any[]): any => entire.length === 6 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3] && "number" === typeof entire[4] && "number" === typeof entire[5]
                ],
                [
                    (top: any[]): any => top.length === 4 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2] && "number" === typeof top[3],
                    (entire: any[]): any => entire.length === 4 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2] && "number" === typeof entire[3]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 6 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3],
                            "number" === typeof top[4],
                            "number" === typeof top[5]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 6 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            }),
                            "number" === typeof entire[4] || $report(_exceptionable, {
                                path: _path + "[4]",
                                expected: "number",
                                value: entire[4]
                            }),
                            "number" === typeof entire[5] || $report(_exceptionable, {
                                path: _path + "[5]",
                                expected: "number",
                                value: entire[5]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 4 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2],
                            "number" === typeof top[3]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 4 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            }),
                            "number" === typeof entire[3] || $report(_exceptionable, {
                                path: _path + "[3]",
                                expected: "number",
                                value: entire[3]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "[west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([west: number, south: number, east: number, north: number, minZ: number, maxZ: number] | [west: number, south: number, east: number, north: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// BBox2d
export const assertBBox2d = (input: any): BBox2d => {
    const __is = (input: any): input is BBox2d => {
        return Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox2d => {
            const $guard = (typia.createAssert as any).guard;
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "BBox2d",
                value: input
            })) && ((input.length === 4 || $guard(true, {
                path: _path + "",
                expected: "[number, number, number, number]",
                value: input
            })) && ("number" === typeof input[0] || $guard(true, {
                path: _path + "[0]",
                expected: "number",
                value: input[0]
            })) && ("number" === typeof input[1] || $guard(true, {
                path: _path + "[1]",
                expected: "number",
                value: input[1]
            })) && ("number" === typeof input[2] || $guard(true, {
                path: _path + "[2]",
                expected: "number",
                value: input[2]
            })) && ("number" === typeof input[3] || $guard(true, {
                path: _path + "[3]",
                expected: "number",
                value: input[3]
            }))) || $guard(true, {
                path: _path + "",
                expected: "BBox2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox2d = (input: any, _exceptionable: boolean = true): input is BBox2d => {
    return Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]);
};
export const isBBox2d = (input: any): input is BBox2d => {
    return Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]);
};
export const randomBBox2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<BBox2d> => {
    const $generator = (typia.createRandom as any).generator;
    return [
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
    ];
};
export const stringifyBBox2d = (input: BBox2d): string => {
    return `[${input[0]},${input[1]},${input[2]},${input[3]}]`;
};
export const validateBBox2d = (input: any): typia.IValidation<BBox2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox2d => {
        return Array.isArray(input) && (input.length === 4 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3]);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox2d => {
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "BBox2d",
                value: input
            })) && ((input.length === 4 || $report(true, {
                path: _path + "",
                expected: "[number, number, number, number]",
                value: input
            })) && [
                "number" === typeof input[0] || $report(true, {
                    path: _path + "[0]",
                    expected: "number",
                    value: input[0]
                }),
                "number" === typeof input[1] || $report(true, {
                    path: _path + "[1]",
                    expected: "number",
                    value: input[1]
                }),
                "number" === typeof input[2] || $report(true, {
                    path: _path + "[2]",
                    expected: "number",
                    value: input[2]
                }),
                "number" === typeof input[3] || $report(true, {
                    path: _path + "[3]",
                    expected: "number",
                    value: input[3]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "BBox2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// BBox3d
export const assertBBox3d = (input: any): BBox3d => {
    const __is = (input: any): input is BBox3d => {
        return Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox3d => {
            const $guard = (typia.createAssert as any).guard;
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "BBox3d",
                value: input
            })) && ((input.length === 6 || $guard(true, {
                path: _path + "",
                expected: "[number, number, number, number, number, number]",
                value: input
            })) && ("number" === typeof input[0] || $guard(true, {
                path: _path + "[0]",
                expected: "number",
                value: input[0]
            })) && ("number" === typeof input[1] || $guard(true, {
                path: _path + "[1]",
                expected: "number",
                value: input[1]
            })) && ("number" === typeof input[2] || $guard(true, {
                path: _path + "[2]",
                expected: "number",
                value: input[2]
            })) && ("number" === typeof input[3] || $guard(true, {
                path: _path + "[3]",
                expected: "number",
                value: input[3]
            })) && ("number" === typeof input[4] || $guard(true, {
                path: _path + "[4]",
                expected: "number",
                value: input[4]
            })) && ("number" === typeof input[5] || $guard(true, {
                path: _path + "[5]",
                expected: "number",
                value: input[5]
            }))) || $guard(true, {
                path: _path + "",
                expected: "BBox3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsBBox3d = (input: any, _exceptionable: boolean = true): input is BBox3d => {
    return Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]);
};
export const isBBox3d = (input: any): input is BBox3d => {
    return Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]);
};
export const randomBBox3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<BBox3d> => {
    const $generator = (typia.createRandom as any).generator;
    return [
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
    ];
};
export const stringifyBBox3d = (input: BBox3d): string => {
    return `[${input[0]},${input[1]},${input[2]},${input[3]},${input[4]},${input[5]}]`;
};
export const validateBBox3d = (input: any): typia.IValidation<BBox3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is BBox3d => {
        return Array.isArray(input) && (input.length === 6 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2] && "number" === typeof input[3] && "number" === typeof input[4] && "number" === typeof input[5]);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is BBox3d => {
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "BBox3d",
                value: input
            })) && ((input.length === 6 || $report(true, {
                path: _path + "",
                expected: "[number, number, number, number, number, number]",
                value: input
            })) && [
                "number" === typeof input[0] || $report(true, {
                    path: _path + "[0]",
                    expected: "number",
                    value: input[0]
                }),
                "number" === typeof input[1] || $report(true, {
                    path: _path + "[1]",
                    expected: "number",
                    value: input[1]
                }),
                "number" === typeof input[2] || $report(true, {
                    path: _path + "[2]",
                    expected: "number",
                    value: input[2]
                }),
                "number" === typeof input[3] || $report(true, {
                    path: _path + "[3]",
                    expected: "number",
                    value: input[3]
                }),
                "number" === typeof input[4] || $report(true, {
                    path: _path + "[4]",
                    expected: "number",
                    value: input[4]
                }),
                "number" === typeof input[5] || $report(true, {
                    path: _path + "[5]",
                    expected: "number",
                    value: input[5]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "BBox3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate
export const assertCoordinate = (input: any): Coordinate => {
    const __is = (input: any): input is Coordinate => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate = (input: any, _exceptionable: boolean = true): input is Coordinate => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isCoordinate = (input: any): input is Coordinate => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomCoordinate = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Coordinate> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyCoordinate = (input: Coordinate): string => {
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input
        });
    })();
};
export const validateCoordinate = (input: any): typia.IValidation<Coordinate> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate2d
export const assertCoordinate2d = (input: any): Coordinate2d => {
    const __is = (input: any): input is Coordinate2d => {
        return Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate2d => {
            const $guard = (typia.createAssert as any).guard;
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "Coordinate2d",
                value: input
            })) && ((input.length === 2 || $guard(true, {
                path: _path + "",
                expected: "[number, number]",
                value: input
            })) && ("number" === typeof input[0] || $guard(true, {
                path: _path + "[0]",
                expected: "number",
                value: input[0]
            })) && ("number" === typeof input[1] || $guard(true, {
                path: _path + "[1]",
                expected: "number",
                value: input[1]
            }))) || $guard(true, {
                path: _path + "",
                expected: "Coordinate2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate2d = (input: any, _exceptionable: boolean = true): input is Coordinate2d => {
    return Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]);
};
export const isCoordinate2d = (input: any): input is Coordinate2d => {
    return Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]);
};
export const randomCoordinate2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Coordinate2d> => {
    const $generator = (typia.createRandom as any).generator;
    return [
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
    ];
};
export const stringifyCoordinate2d = (input: Coordinate2d): string => {
    return `[${input[0]},${input[1]}]`;
};
export const validateCoordinate2d = (input: any): typia.IValidation<Coordinate2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate2d => {
        return Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate2d => {
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "Coordinate2d",
                value: input
            })) && ((input.length === 2 || $report(true, {
                path: _path + "",
                expected: "[number, number]",
                value: input
            })) && [
                "number" === typeof input[0] || $report(true, {
                    path: _path + "[0]",
                    expected: "number",
                    value: input[0]
                }),
                "number" === typeof input[1] || $report(true, {
                    path: _path + "[1]",
                    expected: "number",
                    value: input[1]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "Coordinate2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Coordinate3d
export const assertCoordinate3d = (input: any): Coordinate3d => {
    const __is = (input: any): input is Coordinate3d => {
        return Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate3d => {
            const $guard = (typia.createAssert as any).guard;
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "Coordinate3d",
                value: input
            })) && ((input.length === 3 || $guard(true, {
                path: _path + "",
                expected: "[number, number, number]",
                value: input
            })) && ("number" === typeof input[0] || $guard(true, {
                path: _path + "[0]",
                expected: "number",
                value: input[0]
            })) && ("number" === typeof input[1] || $guard(true, {
                path: _path + "[1]",
                expected: "number",
                value: input[1]
            })) && ("number" === typeof input[2] || $guard(true, {
                path: _path + "[2]",
                expected: "number",
                value: input[2]
            }))) || $guard(true, {
                path: _path + "",
                expected: "Coordinate3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsCoordinate3d = (input: any, _exceptionable: boolean = true): input is Coordinate3d => {
    return Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]);
};
export const isCoordinate3d = (input: any): input is Coordinate3d => {
    return Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]);
};
export const randomCoordinate3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Coordinate3d> => {
    const $generator = (typia.createRandom as any).generator;
    return [
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
    ];
};
export const stringifyCoordinate3d = (input: Coordinate3d): string => {
    return `[${input[0]},${input[1]},${input[2]}]`;
};
export const validateCoordinate3d = (input: any): typia.IValidation<Coordinate3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Coordinate3d => {
        return Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Coordinate3d => {
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "Coordinate3d",
                value: input
            })) && ((input.length === 3 || $report(true, {
                path: _path + "",
                expected: "[number, number, number]",
                value: input
            })) && [
                "number" === typeof input[0] || $report(true, {
                    path: _path + "[0]",
                    expected: "number",
                    value: input[0]
                }),
                "number" === typeof input[1] || $report(true, {
                    path: _path + "[1]",
                    expected: "number",
                    value: input[1]
                }),
                "number" === typeof input[2] || $report(true, {
                    path: _path + "[2]",
                    expected: "number",
                    value: input[2]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "Coordinate3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// DeckglTilejson
export const assertDeckglTilejson = (input: any): DeckglTilejson => {
    const __is = (input: any): input is DeckglTilejson => {
        const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is DeckglTilejson => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index1 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "Array<any>",
                value: input.vector_layers
            })) && (undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(string | undefined)",
                value: input.attribution
            })) && (undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(string | undefined)",
                value: input.scheme
            })) && (undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(number | undefined)",
                value: input.maxzoom
            })) && (undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(number | undefined)",
                value: input.minzoom
            })) && (undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(string | undefined)",
                value: input.version
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsDeckglTilejson = (input: any, _exceptionable: boolean = true): input is DeckglTilejson => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version) && (3 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["tilejson", "tiles", "vector_layers", "attribution", "scheme", "maxzoom", "minzoom", "version"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isDeckglTilejson = (input: any): input is DeckglTilejson => {
    const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomDeckglTilejson = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<DeckglTilejson> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        vector_layers: (generator?.array ?? $generator.array)(() => "fucking any type exists..."),
        attribution: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        version: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])()
    });
    return $ro0();
};
export const stringifyDeckglTilejson = (input: DeckglTilejson): string => {
    const $string = (typia.createStringify as any).string;
    const $so0 = (input: any): any => `{${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? $string(input.attribution) : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? $string(input.scheme) : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? input.maxzoom : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? input.minzoom : undefined},`}${undefined === input.version ? "" : `"version":${undefined !== input.version ? $string(input.version) : undefined},`}"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`},"vector_layers":${`[${input.vector_layers.map((elem: any) => undefined !== elem ? JSON.stringify(elem) : "null").join(",")}]`}}`;
    return $so0(input);
};
export const validateDeckglTilejson = (input: any): typia.IValidation<DeckglTilejson> => {
    const errors = [] as any[];
    const __is = (input: any): input is DeckglTilejson => {
        const $io0 = (input: any): boolean => "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && Array.isArray(input.vector_layers) && (undefined === input.attribution || "string" === typeof input.attribution) && (undefined === input.scheme || "string" === typeof input.scheme) && (undefined === input.maxzoom || "number" === typeof input.maxzoom) && (undefined === input.minzoom || "number" === typeof input.minzoom) && (undefined === input.version || "string" === typeof input.version);
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is DeckglTilejson => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index1: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index1 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "Array<any>",
                    value: input.vector_layers
                }), undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(string | undefined)",
                    value: input.attribution
                }), undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(string | undefined)",
                    value: input.scheme
                }), undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(number | undefined)",
                    value: input.maxzoom
                }), undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(number | undefined)",
                    value: input.minzoom
                }), undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(string | undefined)",
                    value: input.version
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "DeckglTilejson",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Feature
export const assertFeature = (input: any): Feature => {
    const __is = (input: any): input is Feature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io7(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io7 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            if ("MultiLineString" === input.type)
                return $io5(input);
            if ("MultiPoint" === input.type)
                return $io4(input);
            if ("Polygon" === input.type)
                return $io3(input);
            if ("LineString" === input.type)
                return $io2(input);
            if ("Point" === input.type)
                return $io1(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Feature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && $au0(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao7(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeature = (input: any, _exceptionable: boolean = true): input is Feature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io7(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io7 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io5(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io4(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io3(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io2(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io1(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeature = (input: any): input is Feature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io7(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io7 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        if ("MultiLineString" === input.type)
            return $io5(input);
        if ("MultiPoint" === input.type)
            return $io4(input);
        if ("Polygon" === input.type)
            return $io3(input);
        if ("LineString" === input.type)
            return $io2(input);
        if ("Point" === input.type)
            return $io1(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Feature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $pick([
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro7(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro7 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyFeature = (input: Feature): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io7 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        if ("MultiLineString" === input.type)
            return $io5(input);
        if ("MultiPoint" === input.type)
            return $io4(input);
        if ("Polygon" === input.type)
            return $io3(input);
        if ("LineString" === input.type)
            return $io2(input);
        if ("Point" === input.type)
            return $io1(input);
        return false;
    })();
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so7(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$su0(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so7 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so6(input);
        if ("MultiLineString" === input.type)
            return $so5(input);
        if ("MultiPoint" === input.type)
            return $so4(input);
        if ("Polygon" === input.type)
            return $so3(input);
        if ("LineString" === input.type)
            return $so2(input);
        if ("Point" === input.type)
            return $so1(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
            value: input
        });
    })();
    return $so0(input);
};
export const validateFeature = (input: any): typia.IValidation<Feature> => {
    const errors = [] as any[];
    const __is = (input: any): input is Feature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io7(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io7 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            if ("MultiLineString" === input.type)
                return $io5(input);
            if ("MultiPoint" === input.type)
                return $io4(input);
            if ("Polygon" === input.type)
                return $io3(input);
            if ("LineString" === input.type)
                return $io2(input);
            if ("Point" === input.type)
                return $io1(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Feature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                })) && $vu0(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo7(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Feature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureCollection
export const assertFeatureCollection = (input: any): FeatureCollection => {
    const __is = (input: any): input is FeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io8(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io8 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io7(input);
            if ("MultiLineString" === input.type)
                return $io6(input);
            if ("MultiPoint" === input.type)
                return $io5(input);
            if ("Polygon" === input.type)
                return $io4(input);
            if ("LineString" === input.type)
                return $io3(input);
            if ("Point" === input.type)
                return $io2(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "Feature<Geometry<Coordinate>, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "Feature<Geometry<Coordinate>, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && $au0(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao8(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index10: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao7(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureCollection = (input: any, _exceptionable: boolean = true): input is FeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io8(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index6: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io7 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index9: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index10: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io8 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io6(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io5(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io4(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io3(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io2(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isFeatureCollection = (input: any): input is FeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io8(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io8 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input);
        if ("MultiLineString" === input.type)
            return $io6(input);
        if ("MultiPoint" === input.type)
            return $io5(input);
        if ("Polygon" === input.type)
            return $io4(input);
        if ("LineString" === input.type)
            return $io3(input);
        if ("Point" === input.type)
            return $io2(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<FeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $pick([
            () => $ro7(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro8(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro7 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro8 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyFeatureCollection = (input: FeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io8(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io8 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io7(input);
        if ("MultiLineString" === input.type)
            return $io6(input);
        if ("MultiPoint" === input.type)
            return $io5(input);
        if ("Polygon" === input.type)
            return $io4(input);
        if ("LineString" === input.type)
            return $io3(input);
        if ("Point" === input.type)
            return $io2(input);
        return false;
    })();
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so8(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$su0(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so7 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so8 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so7(input);
        if ("MultiLineString" === input.type)
            return $so6(input);
        if ("MultiPoint" === input.type)
            return $so5(input);
        if ("Polygon" === input.type)
            return $so4(input);
        if ("LineString" === input.type)
            return $so3(input);
        if ("Point" === input.type)
            return $so2(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
            value: input
        });
    })();
    return $so0(input);
};
export const validateFeatureCollection = (input: any): typia.IValidation<FeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $iu0(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io8(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io3 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io4 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io5 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io6 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io7 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io8 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io7(input);
            if ("MultiLineString" === input.type)
                return $io6(input);
            if ("MultiPoint" === input.type)
                return $io5(input);
            if ("Polygon" === input.type)
                return $io4(input);
            if ("LineString" === input.type)
                return $io3(input);
            if ("Point" === input.type)
                return $io2(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "Feature<Geometry<Coordinate>, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "Feature<Geometry<Coordinate>, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<Feature<Geometry<Coordinate>, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                })) && $vu0(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo8(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo7 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index10: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo8 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo7(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "FeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureCollectionType
export const assertFeatureCollectionType = (input: any): FeatureCollectionType => {
    const __is = (input: any): input is FeatureCollectionType => {
        return "FeatureCollection" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollectionType => {
            const $guard = (typia.createAssert as any).guard;
            return "FeatureCollection" === input || $guard(true, {
                path: _path + "",
                expected: "\"FeatureCollection\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureCollectionType = (input: any, _exceptionable: boolean = true): input is FeatureCollectionType => {
    return "FeatureCollection" === input;
};
export const isFeatureCollectionType = (input: any): input is FeatureCollectionType => {
    return "FeatureCollection" === input;
};
export const randomFeatureCollectionType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<FeatureCollectionType> => {
    return "FeatureCollection";
};
export const stringifyFeatureCollectionType = (input: FeatureCollectionType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input
        });
    })();
};
export const validateFeatureCollectionType = (input: any): typia.IValidation<FeatureCollectionType> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureCollectionType => {
        return "FeatureCollection" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureCollectionType => {
            return "FeatureCollection" === input || $report(true, {
                path: _path + "",
                expected: "\"FeatureCollection\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// FeatureType
export const assertFeatureType = (input: any): FeatureType => {
    const __is = (input: any): input is FeatureType => {
        return "Feature" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureType => {
            const $guard = (typia.createAssert as any).guard;
            return "Feature" === input || $guard(true, {
                path: _path + "",
                expected: "\"Feature\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsFeatureType = (input: any, _exceptionable: boolean = true): input is FeatureType => {
    return "Feature" === input;
};
export const isFeatureType = (input: any): input is FeatureType => {
    return "Feature" === input;
};
export const randomFeatureType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<FeatureType> => {
    return "Feature";
};
export const stringifyFeatureType = (input: FeatureType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input
        });
    })();
};
export const validateFeatureType = (input: any): typia.IValidation<FeatureType> => {
    const errors = [] as any[];
    const __is = (input: any): input is FeatureType => {
        return "Feature" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is FeatureType => {
            return "Feature" === input || $report(true, {
                path: _path + "",
                expected: "\"Feature\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeoJsonProperties
export const assertGeoJsonProperties = (input: any): GeoJsonProperties => {
    const __is = (input: any): input is GeoJsonProperties => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeoJsonProperties => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return null === input || ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeoJsonProperties = (input: any, _exceptionable: boolean = true): input is GeoJsonProperties => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isGeoJsonProperties = (input: any): input is GeoJsonProperties => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomGeoJsonProperties = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeoJsonProperties> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $pick([
        () => null,
        () => $ro0()
    ])();
};
export const stringifyGeoJsonProperties = (input: GeoJsonProperties): string => {
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return null !== input ? $so0(input) : "null";
};
export const validateGeoJsonProperties = (input: any): typia.IValidation<GeoJsonProperties> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeoJsonProperties => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return null === input || "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeoJsonProperties => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return null === input || ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(Record<string, unknown> | null)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry
export const assertGeometry = (input: any): Geometry => {
    const __is = (input: any): input is Geometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry = (input: any, _exceptionable: boolean = true): input is Geometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry = (input: any): input is Geometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        if ("MultiLineString" === input.type)
            return $io4(input);
        if ("MultiPoint" === input.type)
            return $io3(input);
        if ("Polygon" === input.type)
            return $io2(input);
        if ("LineString" === input.type)
            return $io1(input);
        if ("Point" === input.type)
            return $io0(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Geometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry = (input: Geometry): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        if ("MultiLineString" === input.type)
            return $so4(input);
        if ("MultiPoint" === input.type)
            return $so3(input);
        if ("Polygon" === input.type)
            return $so2(input);
        if ("LineString" === input.type)
            return $so1(input);
        if ("Point" === input.type)
            return $so0(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
            value: input
        });
    })();
    return $su0(input);
};
export const validateGeometry = (input: any): typia.IValidation<Geometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index3 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index5) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index5) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index8) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index8) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index8) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index8) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry2d
export const assertGeometry2d = (input: any): Geometry2d => {
    const __is = (input: any): input is Geometry2d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            })) && ((input.coordinates.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((elem[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "[number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((elem[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "[number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "[number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "[number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "[number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "[number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry2d = (input: any, _exceptionable: boolean = true): input is Geometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry2d = (input: any): input is Geometry2d => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        if ("MultiLineString" === input.type)
            return $io4(input);
        if ("MultiPoint" === input.type)
            return $io3(input);
        if ("Polygon" === input.type)
            return $io2(input);
        if ("LineString" === input.type)
            return $io1(input);
        if ("Point" === input.type)
            return $io0(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Geometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry2d = (input: Geometry2d): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]}]`}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]}]`},${`[${elem[1][0]},${elem[1][1]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]}]`},${`[${elem[0][1][0]},${elem[0][1][1]}]`},${`[${elem[0][2][0]},${elem[0][2][1]}]`},${`[${elem[0][3][0]},${elem[0][3][1]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        if ("MultiLineString" === input.type)
            return $so4(input);
        if ("MultiPoint" === input.type)
            return $so3(input);
        if ("Polygon" === input.type)
            return $so2(input);
        if ("LineString" === input.type)
            return $so1(input);
        if ("Point" === input.type)
            return $so0(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
            value: input
        });
    })();
    return $su0(input);
};
export const validateGeometry2d = (input: any): typia.IValidation<Geometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry2d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index3 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index3 + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index4) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index4) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    })) && ((elem[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "[number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })) && ((elem[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "[number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })) && ((elem.length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "[number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][1]",
                                expected: "number",
                                value: elem[1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "[number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "[number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "[number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "[number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d> | LineStringGeometry<Coordinate2d> | PointGeometry<Coordinate2d>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate2d> | MultiLineStringGeometry<Coordinate2d> | MultiPointGeometry<Coordinate2d> | MultiPolygonGeometry<Coordinate2d> | PointGeometry<Coordinate2d> | PolygonGeometry<Coordinate2d>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geometry3d
export const assertGeometry3d = (input: any): Geometry3d => {
    const __is = (input: any): input is Geometry3d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            })) && ((input.coordinates.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[2]",
                expected: "number",
                value: input.coordinates[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "number",
                value: input.coordinates[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            })) && ("number" === typeof input.coordinates[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][2]",
                expected: "number",
                value: input.coordinates[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            })) && ("number" === typeof input.coordinates[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][2]",
                expected: "number",
                value: input.coordinates[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            })) && ("number" === typeof input.coordinates[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][2]",
                expected: "number",
                value: input.coordinates[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index3 + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((elem[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "[number, number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0][2]",
                expected: "number",
                value: elem[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((elem[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "[number, number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            })) && ("number" === typeof elem[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1][2]",
                expected: "number",
                value: elem[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index5) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            })) && ("number" === typeof input.coordinates[0][0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][2]",
                expected: "number",
                value: input.coordinates[0][0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            })) && ("number" === typeof input.coordinates[0][0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][2]",
                expected: "number",
                value: input.coordinates[0][0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            })) && ("number" === typeof input.coordinates[0][0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][2]",
                expected: "number",
                value: input.coordinates[0][0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "[number, number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            })) && ("number" === typeof elem[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][2]",
                expected: "number",
                value: elem[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "[number, number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            })) && ("number" === typeof elem[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][2]",
                expected: "number",
                value: elem[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "[number, number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            })) && ("number" === typeof elem[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][2]",
                expected: "number",
                value: elem[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "[number, number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            })) && ("number" === typeof elem[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][2]",
                expected: "number",
                value: elem[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index8) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao0(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometry3d = (input: any, _exceptionable: boolean = true): input is Geometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index5: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index6: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index7: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index8: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index9: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io4(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io3(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io2(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io1(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io0(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isGeometry3d = (input: any): input is Geometry3d => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io5(input);
        if ("MultiLineString" === input.type)
            return $io4(input);
        if ("MultiPoint" === input.type)
            return $io3(input);
        if ("Polygon" === input.type)
            return $io2(input);
        if ("LineString" === input.type)
            return $io1(input);
        if ("Point" === input.type)
            return $io0(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Geometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    return $pick([
        () => $ro5(),
        () => $ro4(),
        () => $ro3(),
        () => $ro2(),
        () => $ro1(),
        () => $ro0()
    ])();
};
export const stringifyGeometry3d = (input: Geometry3d): string => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`},${`[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`},${`[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`},${`[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`},${`[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so5(input);
        if ("MultiLineString" === input.type)
            return $so4(input);
        if ("MultiPoint" === input.type)
            return $so3(input);
        if ("Polygon" === input.type)
            return $so2(input);
        if ("LineString" === input.type)
            return $so1(input);
        if ("Point" === input.type)
            return $so0(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
            value: input
        });
    })();
    return $su0(input);
};
export const validateGeometry3d = (input: any): typia.IValidation<Geometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geometry3d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io3 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io4 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io5 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io5(input);
            if ("MultiLineString" === input.type)
                return $io4(input);
            if ("MultiPoint" === input.type)
                return $io3(input);
            if ("Polygon" === input.type)
                return $io2(input);
            if ("LineString" === input.type)
                return $io1(input);
            if ("Point" === input.type)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    }),
                    "number" === typeof input.coordinates[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[2]",
                        expected: "number",
                        value: input.coordinates[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        }),
                        "number" === typeof input.coordinates[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "number",
                            value: input.coordinates[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        }),
                        "number" === typeof input.coordinates[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][2]",
                            expected: "number",
                            value: input.coordinates[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            }),
                            "number" === typeof input.coordinates[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][2]",
                                expected: "number",
                                value: input.coordinates[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            }),
                            "number" === typeof input.coordinates[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][2]",
                                expected: "number",
                                value: input.coordinates[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index3 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index3 + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index3 + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index3 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index4) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index4) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index4) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index4) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    })) && ((elem[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "[number, number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        }),
                        "number" === typeof elem[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][0][2]",
                            expected: "number",
                            value: elem[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })) && ((elem[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "[number, number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        }),
                        "number" === typeof elem[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index5) + "][1][2]",
                            expected: "number",
                            value: elem[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "][" + (2 + _index6) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index5) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                }),
                                "number" === typeof input.coordinates[0][0][0][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                }),
                                "number" === typeof input.coordinates[0][0][1][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                }),
                                "number" === typeof input.coordinates[0][0][2][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                }),
                                "number" === typeof input.coordinates[0][0][3][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })) && ((elem.length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "[number, number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][1]",
                                expected: "number",
                                value: elem[1]
                            }),
                            "number" === typeof elem[2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index7) + "][2]",
                                expected: "number",
                                value: elem[2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index7) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "[number, number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            }),
                            "number" === typeof elem[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][0][2]",
                                expected: "number",
                                value: elem[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "[number, number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            }),
                            "number" === typeof elem[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][1][2]",
                                expected: "number",
                                value: elem[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "[number, number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            }),
                            "number" === typeof elem[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][2][2]",
                                expected: "number",
                                value: elem[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "[number, number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            }),
                            "number" === typeof elem[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index8) + "][0][3][2]",
                                expected: "number",
                                value: elem[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0][" + (4 + _index9) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index8) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index8) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo0(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d> | LineStringGeometry<Coordinate3d> | PointGeometry<Coordinate3d>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(LineStringGeometry<Coordinate3d> | MultiLineStringGeometry<Coordinate3d> | MultiPointGeometry<Coordinate3d> | MultiPolygonGeometry<Coordinate3d> | PointGeometry<Coordinate3d> | PolygonGeometry<Coordinate3d>)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeometryCollection
export const assertGeometryCollection = (input: any): GeometryCollection => {
    const __is = (input: any): input is GeometryCollection => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "GeometryCollection" === input.type && (Array.isArray(input.geometries) && input.geometries.every((elem: any) => "object" === typeof elem && null !== elem && $iu0(elem)));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            if ("MultiLineString" === input.type)
                return $io5(input);
            if ("MultiPoint" === input.type)
                return $io4(input);
            if ("Polygon" === input.type)
                return $io3(input);
            if ("LineString" === input.type)
                return $io2(input);
            if ("Point" === input.type)
                return $io1(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("GeometryCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"GeometryCollection\"",
                value: input.type
            })) && ((Array.isArray(input.geometries) || $guard(_exceptionable, {
                path: _path + ".geometries",
                expected: "Array<Geometry<Coordinate>>",
                value: input.geometries
            })) && input.geometries.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".geometries[" + _index1 + "]",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: elem
            })) && $au0(elem, _path + ".geometries[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometries[" + _index1 + "]",
                expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".geometries",
                expected: "Array<Geometry<Coordinate>>",
                value: input.geometries
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index4 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index6: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index7: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index6) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index9: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index10: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index9) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $ao6(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $ao5(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $ao4(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $ao3(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $ao2(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $ao1(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "GeometryCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "GeometryCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometryCollection = (input: any, _exceptionable: boolean = true): input is GeometryCollection => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "GeometryCollection" === input.type && (Array.isArray(input.geometries) && input.geometries.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $iu0(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometries"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io4 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io5 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index5: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index6: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index7: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io6 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index8: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index9: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index10: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input, true && _exceptionable);
        if ("MultiLineString" === input.type)
            return $io5(input, true && _exceptionable);
        if ("MultiPoint" === input.type)
            return $io4(input, true && _exceptionable);
        if ("Polygon" === input.type)
            return $io3(input, true && _exceptionable);
        if ("LineString" === input.type)
            return $io2(input, true && _exceptionable);
        if ("Point" === input.type)
            return $io1(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeometryCollection = (input: any): input is GeometryCollection => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "GeometryCollection" === input.type && (Array.isArray(input.geometries) && input.geometries.every((elem: any) => "object" === typeof elem && null !== elem && $iu0(elem)));
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        if ("MultiLineString" === input.type)
            return $io5(input);
        if ("MultiPoint" === input.type)
            return $io4(input);
        if ("Polygon" === input.type)
            return $io3(input);
        if ("LineString" === input.type)
            return $io2(input);
        if ("Point" === input.type)
            return $io1(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeometryCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeometryCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "GeometryCollection",
        geometries: (generator?.array ?? $generator.array)(() => $pick([
            () => $ro6(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro5(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro4(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth),
            () => $ro1(_recursive, _recursive ? 1 + _depth : _depth)
        ])())
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro4 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro5 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro6 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyGeometryCollection = (input: GeometryCollection): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $iu0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $io6(input);
        if ("MultiLineString" === input.type)
            return $io5(input);
        if ("MultiPoint" === input.type)
            return $io4(input);
        if ("Polygon" === input.type)
            return $io3(input);
        if ("LineString" === input.type)
            return $io2(input);
        if ("Point" === input.type)
            return $io1(input);
        return false;
    })();
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"GeometryCollection\"",
            value: input.type
        });
    })()},"geometries":${`[${input.geometries.map((elem: any) => $su0(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so4 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so5 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so6 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("MultiPolygon" === input.type)
            return $so6(input);
        if ("MultiLineString" === input.type)
            return $so5(input);
        if ("MultiPoint" === input.type)
            return $so4(input);
        if ("Polygon" === input.type)
            return $so3(input);
        if ("LineString" === input.type)
            return $so2(input);
        if ("Point" === input.type)
            return $so1(input);
        $throws({
            expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
            value: input
        });
    })();
    return $so0(input);
};
export const validateGeometryCollection = (input: any): typia.IValidation<GeometryCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeometryCollection => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "GeometryCollection" === input.type && (Array.isArray(input.geometries) && input.geometries.every((elem: any) => "object" === typeof elem && null !== elem && $iu0(elem)));
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io4 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io5 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io6 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $iu0 = (input: any): any => (() => {
            if ("MultiPolygon" === input.type)
                return $io6(input);
            if ("MultiLineString" === input.type)
                return $io5(input);
            if ("MultiPoint" === input.type)
                return $io4(input);
            if ("Polygon" === input.type)
                return $io3(input);
            if ("LineString" === input.type)
                return $io2(input);
            if ("Point" === input.type)
                return $io1(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollection => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["GeometryCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"GeometryCollection\"",
                    value: input.type
                }), (Array.isArray(input.geometries) || $report(_exceptionable, {
                    path: _path + ".geometries",
                    expected: "Array<Geometry<Coordinate>>",
                    value: input.geometries
                })) && input.geometries.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".geometries[" + _index1 + "]",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: elem
                })) && $vu0(elem, _path + ".geometries[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometries[" + _index1 + "]",
                    expected: "(LineStringGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | MultiPolygonGeometry<Coordinate> | PointGeometry<Coordinate> | PolygonGeometry<Coordinate>)",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".geometries",
                    expected: "Array<Geometry<Coordinate>>",
                    value: input.geometries
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo4 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index4 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index4 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo5 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index5: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index5) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index5) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index6: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index6) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index6) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index6) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index7: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "][" + (2 + _index7) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index6) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo6 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index8: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index8) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index8) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index9: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index9) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index9) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index9) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index9) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index9) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index10: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0][" + (4 + _index10) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index9) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index9) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("MultiPolygon" === input.type)
                    return $vo6(input, _path, true && _exceptionable);
                if ("MultiLineString" === input.type)
                    return $vo5(input, _path, true && _exceptionable);
                if ("MultiPoint" === input.type)
                    return $vo4(input, _path, true && _exceptionable);
                if ("Polygon" === input.type)
                    return $vo3(input, _path, true && _exceptionable);
                if ("LineString" === input.type)
                    return $vo2(input, _path, true && _exceptionable);
                if ("Point" === input.type)
                    return $vo1(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(MultiPolygonGeometry<Coordinate> | MultiLineStringGeometry<Coordinate> | MultiPointGeometry<Coordinate> | PolygonGeometry<Coordinate> | LineStringGeometry<Coordinate> | PointGeometry<Coordinate>)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "GeometryCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "GeometryCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeometryCollectionType
export const assertGeometryCollectionType = (input: any): GeometryCollectionType => {
    const __is = (input: any): input is GeometryCollectionType => {
        return "GeometryCollection" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollectionType => {
            const $guard = (typia.createAssert as any).guard;
            return "GeometryCollection" === input || $guard(true, {
                path: _path + "",
                expected: "\"GeometryCollection\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometryCollectionType = (input: any, _exceptionable: boolean = true): input is GeometryCollectionType => {
    return "GeometryCollection" === input;
};
export const isGeometryCollectionType = (input: any): input is GeometryCollectionType => {
    return "GeometryCollection" === input;
};
export const randomGeometryCollectionType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeometryCollectionType> => {
    return "GeometryCollection";
};
export const stringifyGeometryCollectionType = (input: GeometryCollectionType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"GeometryCollection\"",
            value: input
        });
    })();
};
export const validateGeometryCollectionType = (input: any): typia.IValidation<GeometryCollectionType> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeometryCollectionType => {
        return "GeometryCollection" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryCollectionType => {
            return "GeometryCollection" === input || $report(true, {
                path: _path + "",
                expected: "\"GeometryCollection\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeometryType
export const assertGeometryType = (input: any): GeometryType => {
    const __is = (input: any): input is GeometryType => {
        return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input || $guard(true, {
                path: _path + "",
                expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeometryType = (input: any, _exceptionable: boolean = true): input is GeometryType => {
    return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
};
export const isGeometryType = (input: any): input is GeometryType => {
    return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
};
export const randomGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeometryType> => {
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => "Point",
        () => "LineString",
        () => "Polygon",
        () => "MultiPoint",
        () => "MultiLineString",
        () => "MultiPolygon"
    ])();
};
export const stringifyGeometryType = (input: GeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
            value: input
        });
    })();
};
export const validateGeometryType = (input: any): typia.IValidation<GeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeometryType => {
        return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeometryType => {
            return "Point" === input || "LineString" === input || "Polygon" === input || "MultiPoint" === input || "MultiLineString" === input || "MultiPolygon" === input || $report(true, {
                path: _path + "",
                expected: "(\"LineString\" | \"MultiLineString\" | \"MultiPoint\" | \"MultiPolygon\" | \"Point\" | \"Polygon\")",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Geostats
export const assertGeostats = (input: any): Geostats => {
    const __is = (input: any): input is Geostats => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geostats => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index9: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index10: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("number" === typeof input.layerCount || $guard(_exceptionable, {
                path: _path + ".layerCount",
                expected: "number",
                value: input.layerCount
            })) && ((Array.isArray(input.layers) || $guard(_exceptionable, {
                path: _path + ".layers",
                expected: "Array<GeostatsLayer>",
                value: input.layers
            })) && input.layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".layers[" + _index1 + "]",
                expected: "GeostatsLayer",
                value: elem
            })) && $ao1(elem, _path + ".layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".layers[" + _index1 + "]",
                expected: "GeostatsLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".layers",
                expected: "Array<GeostatsLayer>",
                value: input.layers
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.layer || $guard(_exceptionable, {
                path: _path + ".layer",
                expected: "string",
                value: input.layer
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                value: input.geometry
            })) && ("number" === typeof input.attributeCount || $guard(_exceptionable, {
                path: _path + ".attributeCount",
                expected: "number",
                value: input.attributeCount
            })) && (undefined === input.attributes || (Array.isArray(input.attributes) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && input.attributes.every((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index2 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) && $ao2(elem, _path + ".attributes[" + _index2 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index2 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostats = (input: any, _exceptionable: boolean = true): input is Geostats => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index9: number) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index10: number) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layerCount", "layers"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any, _index2: number) => "object" === typeof elem && null !== elem && $io2(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostats = (input: any): input is Geostats => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostats = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Geostats> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layerCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layer: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            geometry: $pick([
                () => "Point",
                () => "LineString",
                () => "Polygon"
            ])(),
            attributeCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            attributes: $pick([
                () => undefined,
                () => (generator?.array ?? $generator.array)(() => $ro2(_recursive, _recursive ? 1 + _depth : _depth))
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostats = (input: Geostats): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($sp0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $join = (typia.createStringify as any).join;
    const $tail = (typia.createStringify as any).tail;
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`"layerCount":${input.layerCount},"layers":${`[${input.layers.map((elem: any) => $so1(elem)).join(",")}]`},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["layerCount", "layers"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so1 = (input: any): any => `{${$tail(`${undefined === input.attributes ? "" : `"attributes":${undefined !== input.attributes ? `[${input.attributes.map((elem: any) => $so2(elem)).join(",")}]` : undefined},`}"layer":${$string(input.layer)},"count":${input.count},"geometry":${(() => {
        if ("string" === typeof input.geometry)
            return $string(input.geometry);
        if ("string" === typeof input.geometry)
            return "\"" + input.geometry + "\"";
        $throws({
            expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
            value: input.geometry
        });
    })()},"attributeCount":${input.attributeCount},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["attributes", "layer", "count", "geometry", "attributeCount"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so2 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostats = (input: any): typia.IValidation<Geostats> => {
    const errors = [] as any[];
    const __is = (input: any): input is Geostats => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "number" === typeof input.layerCount && (Array.isArray(input.layers) && input.layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io2(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io2 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Geostats => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index9: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index10: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index10 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["number" === typeof input.layerCount || $report(_exceptionable, {
                    path: _path + ".layerCount",
                    expected: "number",
                    value: input.layerCount
                }), (Array.isArray(input.layers) || $report(_exceptionable, {
                    path: _path + ".layers",
                    expected: "Array<GeostatsLayer>",
                    value: input.layers
                })) && input.layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".layers[" + _index1 + "]",
                    expected: "GeostatsLayer",
                    value: elem
                })) && $vo1(elem, _path + ".layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".layers[" + _index1 + "]",
                    expected: "GeostatsLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".layers",
                    expected: "Array<GeostatsLayer>",
                    value: input.layers
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.layer || $report(_exceptionable, {
                    path: _path + ".layer",
                    expected: "string",
                    value: input.layer
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                    value: input.geometry
                }), "number" === typeof input.attributeCount || $report(_exceptionable, {
                    path: _path + ".attributeCount",
                    expected: "number",
                    value: input.attributeCount
                }), undefined === input.attributes || (Array.isArray(input.attributes) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                })) && input.attributes.map((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index2 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })) && $vo2(elem, _path + ".attributes[" + _index2 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index2 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Geostats",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeostatsAttribute
export const assertGeostatsAttribute = (input: any): GeostatsAttribute => {
    const __is = (input: any): input is GeostatsAttribute => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsAttribute => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index5: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index5 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostatsAttribute = (input: any, _exceptionable: boolean = true): input is GeostatsAttribute => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index5: number) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index6: number) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostatsAttribute = (input: any): input is GeostatsAttribute => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostatsAttribute = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeostatsAttribute> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostatsAttribute = (input: GeostatsAttribute): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $tail = (typia.createStringify as any).tail;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostatsAttribute = (input: any): typia.IValidation<GeostatsAttribute> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeostatsAttribute => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsAttribute => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index5: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index5 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "GeostatsAttribute",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// GeostatsLayer
export const assertGeostatsLayer = (input: any): GeostatsLayer => {
    const __is = (input: any): input is GeostatsLayer => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsLayer => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index6: number) => "number" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "number",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index7: number) => "string" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "string",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.every((elem: any, _index8: number) => "boolean" === typeof elem || $guard(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "boolean",
                            value: elem
                        }))
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.every((elem: any, _index9: number) => (undefined !== elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $guard(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })))
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.layer || $guard(_exceptionable, {
                path: _path + ".layer",
                expected: "string",
                value: input.layer
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                value: input.geometry
            })) && ("number" === typeof input.attributeCount || $guard(_exceptionable, {
                path: _path + ".attributeCount",
                expected: "number",
                value: input.attributeCount
            })) && (undefined === input.attributes || (Array.isArray(input.attributes) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && input.attributes.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index1 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) && $ao1(elem, _path + ".attributes[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".attributes[" + _index1 + "]",
                expected: "GeostatsAttribute",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".attributes",
                expected: "(Array<GeostatsAttribute> | undefined)",
                value: input.attributes
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.attribute || $guard(_exceptionable, {
                path: _path + ".attribute",
                expected: "string",
                value: input.attribute
            })) && ("number" === typeof input.count || $guard(_exceptionable, {
                path: _path + ".count",
                expected: "number",
                value: input.count
            })) && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                value: input.type
            })) && ((Array.isArray(input.values) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && ($ap0(input.values, _path + ".values", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                value: input.values
            })) || $guard(_exceptionable, {
                path: _path + ".values",
                expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                value: input.values
            })) && (undefined === input.min || "number" === typeof input.min || $guard(_exceptionable, {
                path: _path + ".min",
                expected: "(number | undefined)",
                value: input.min
            })) && (undefined === input.max || "number" === typeof input.max || $guard(_exceptionable, {
                path: _path + ".max",
                expected: "(number | undefined)",
                value: input.max
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsGeostatsLayer = (input: any, _exceptionable: boolean = true): input is GeostatsLayer => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index6: number) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index7: number) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any, _index8: number) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any, _index9: number) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && Object.keys(input).every((key: any) => {
        if (["layer", "count", "geometry", "attributeCount", "attributes"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values, true && _exceptionable) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        if (["attribute", "count", "type", "values", "min", "max"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isGeostatsLayer = (input: any): input is GeostatsLayer => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return true;
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomGeostatsLayer = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<GeostatsLayer> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            layer: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            geometry: $pick([
                () => "Point",
                () => "LineString",
                () => "Polygon"
            ])(),
            attributeCount: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            attributes: $pick([
                () => undefined,
                () => (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            attribute: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            count: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            type: $pick([
                () => "string",
                () => "number",
                () => "boolean",
                () => "null",
                () => "mixed"
            ])(),
            values: $pick([
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)),
                () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
                () => (generator?.array ?? $generator.array)(() => (generator?.boolean ?? $generator.boolean)()),
                () => (generator?.array ?? $generator.array)(() => null)
            ])(),
            min: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            max: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyGeostatsLayer = (input: GeostatsLayer): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($sp0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $tail = (typia.createStringify as any).tail;
    const $sp0 = (input: any) => {
        const array = input;
        const top = input[0];
        if (0 === input.length)
            return "[]";
        const arrayPredicators = [
            [
                (top: any): any => "number" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => "string" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => $string(elem)).join(",")}]`
            ],
            [
                (top: any): any => "boolean" === typeof top,
                (entire: any[]): any => `[${entire.map((elem: any) => elem).join(",")}]`
            ],
            [
                (top: any): any => undefined !== top && null === top,
                (entire: any[]): any => `[${entire.map((elem: any) => "null").join(",")}]`
            ]
        ];
        const passed = arrayPredicators.filter((pred: any) => pred[0](top));
        if (1 === passed.length)
            return passed[0][1](array);
        else if (1 < passed.length)
            for (const pred of passed)
                if (array.every((value: any) => true === pred[0](value)))
                    return pred[1](array);
        $throws({
            expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
            value: input
        });
    };
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.attributes ? "" : `"attributes":${undefined !== input.attributes ? `[${input.attributes.map((elem: any) => $so1(elem)).join(",")}]` : undefined},`}"layer":${$string(input.layer)},"count":${input.count},"geometry":${(() => {
        if ("string" === typeof input.geometry)
            return $string(input.geometry);
        if ("string" === typeof input.geometry)
            return "\"" + input.geometry + "\"";
        $throws({
            expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
            value: input.geometry
        });
    })()},"attributeCount":${input.attributeCount},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["attributes", "layer", "count", "geometry", "attributeCount"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    const $so1 = (input: any): any => `{${$tail(`${undefined === input.min ? "" : `"min":${undefined !== input.min ? input.min : undefined},`}${undefined === input.max ? "" : `"max":${undefined !== input.max ? input.max : undefined},`}"attribute":${$string(input.attribute)},"count":${input.count},"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
            value: input.type
        });
    })()},"values":${$sp0(input.values)},${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["min", "max", "attribute", "count", "type", "values"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateGeostatsLayer = (input: any): typia.IValidation<GeostatsLayer> => {
    const errors = [] as any[];
    const __is = (input: any): input is GeostatsLayer => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const top = input[0];
            if (0 === input.length)
                return true;
            const arrayPredicators = [
                [
                    (top: any): any => "number" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "number" === typeof elem)
                ],
                [
                    (top: any): any => "string" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "string" === typeof elem)
                ],
                [
                    (top: any): any => "boolean" === typeof top,
                    (entire: any[]): any => entire.every((elem: any) => "boolean" === typeof elem)
                ],
                [
                    (top: any): any => undefined !== top && null === top,
                    (entire: any[]): any => entire.every((elem: any) => undefined !== elem && null === elem)
                ]
            ];
            const passed = arrayPredicators.filter((pred: any) => pred[0](top));
            if (1 === passed.length)
                return passed[0][1](array);
            else if (1 < passed.length)
                for (const pred of passed)
                    if (array.every((value: any) => true === pred[0](value)))
                        return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "string" === typeof input.layer && "number" === typeof input.count && ("Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry) && "number" === typeof input.attributeCount && (undefined === input.attributes || Array.isArray(input.attributes) && input.attributes.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        const $io1 = (input: any): boolean => "string" === typeof input.attribute && "number" === typeof input.count && ("string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type) && (Array.isArray(input.values) && ($ip0(input.values) || false)) && (undefined === input.min || "number" === typeof input.min) && (undefined === input.max || "number" === typeof input.max) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is GeostatsLayer => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const top = input[0];
                if (0 === input.length)
                    return true;
                const arrayPredicators = [
                    [
                        (top: any): any => "number" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index6: number) => "number" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index6 + "]",
                            expected: "number",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "string" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index7: number) => "string" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index7 + "]",
                            expected: "string",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => "boolean" === typeof top,
                        (entire: any[]): any => entire.map((elem: any, _index8: number) => "boolean" === typeof elem || $report(_exceptionable, {
                            path: _path + "[" + _index8 + "]",
                            expected: "boolean",
                            value: elem
                        })).every((flag: boolean) => flag)
                    ],
                    [
                        (top: any): any => undefined !== top && null === top,
                        (entire: any[]): any => entire.map((elem: any, _index9: number) => (undefined !== elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        })) && (null === elem || $report(_exceptionable, {
                            path: _path + "[" + _index9 + "]",
                            expected: "null",
                            value: elem
                        }))).every((flag: boolean) => flag)
                    ]
                ];
                const passed = arrayPredicators.filter((pred: any) => pred[0](top));
                if (1 === passed.length)
                    return passed[0][1](array);
                else if (1 < passed.length)
                    for (const pred of passed)
                        if (array.every((value: any) => true === pred[0](value)))
                            return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Array<number> | Array<string> | Array<boolean> | Array<null>)",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.layer || $report(_exceptionable, {
                    path: _path + ".layer",
                    expected: "string",
                    value: input.layer
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "Point" === input.geometry || "LineString" === input.geometry || "Polygon" === input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "(\"LineString\" | \"Point\" | \"Polygon\")",
                    value: input.geometry
                }), "number" === typeof input.attributeCount || $report(_exceptionable, {
                    path: _path + ".attributeCount",
                    expected: "number",
                    value: input.attributeCount
                }), undefined === input.attributes || (Array.isArray(input.attributes) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                })) && input.attributes.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index1 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })) && $vo1(elem, _path + ".attributes[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".attributes[" + _index1 + "]",
                    expected: "GeostatsAttribute",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".attributes",
                    expected: "(Array<GeostatsAttribute> | undefined)",
                    value: input.attributes
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.attribute || $report(_exceptionable, {
                    path: _path + ".attribute",
                    expected: "string",
                    value: input.attribute
                }), "number" === typeof input.count || $report(_exceptionable, {
                    path: _path + ".count",
                    expected: "number",
                    value: input.count
                }), "string" === input.type || "number" === input.type || "boolean" === input.type || "null" === input.type || "mixed" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "(\"boolean\" | \"mixed\" | \"null\" | \"number\" | \"string\")",
                    value: input.type
                }), (Array.isArray(input.values) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                })) && ($vp0(input.values, _path + ".values", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "Array<number> | Array<string> | Array<boolean> | Array<null>",
                    value: input.values
                })) || $report(_exceptionable, {
                    path: _path + ".values",
                    expected: "(Array<boolean> | Array<null> | Array<number> | Array<string>)",
                    value: input.values
                }), undefined === input.min || "number" === typeof input.min || $report(_exceptionable, {
                    path: _path + ".min",
                    expected: "(number | undefined)",
                    value: input.min
                }), undefined === input.max || "number" === typeof input.max || $report(_exceptionable, {
                    path: _path + ".max",
                    expected: "(number | undefined)",
                    value: input.max
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "GeostatsLayer",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringCoordinates
export const assertLineStringCoordinates = (input: any): LineStringCoordinates => {
    const __is = (input: any): input is LineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0]
            })) && ($ap0(input[0], _path + "[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0]
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0]
            })) && ((Array.isArray(input[1]) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[1]
            })) && ($ap0(input[1], _path + "[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[1]
            })) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[1]
            })) && ((Array.isArray(input.slice(2)) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(2)
            })) && input.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(2)
            }))) || $guard(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringCoordinates = (input: any, _exceptionable: boolean = true): input is LineStringCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0], true && _exceptionable) || false) && (Array.isArray(input[1]) && ($ip0(input[1], true && _exceptionable) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))));
};
export const isLineStringCoordinates = (input: any): input is LineStringCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
};
export const randomLineStringCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    ];
};
export const stringifyLineStringCoordinates = (input: LineStringCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    return `[${(() => {
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0]
        });
    })()},${(() => {
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[1]
        });
    })()}${$rest(`[${input.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`;
};
export const validateLineStringCoordinates = (input: any): typia.IValidation<LineStringCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input.slice(2)) && input.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0]
                })) && ($vp0(input[0], _path + "[0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[0]
                })) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0]
                }),
                (Array.isArray(input[1]) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[1]
                })) && ($vp0(input[1], _path + "[1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[1]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[1]
                })) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[1]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(2)) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(2)
            })) && input.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(2)
            }))) || $report(true, {
                path: _path + "",
                expected: "LineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeature
export const assertLineStringFeature = (input: any): LineStringFeature => {
    const __is = (input: any): input is LineStringFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeature = (input: any, _exceptionable: boolean = true): input is LineStringFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeature = (input: any): input is LineStringFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeature = (input: LineStringFeature): string => {
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeature = (input: any): typia.IValidation<LineStringFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeature2d
export const assertLineStringFeature2d = (input: any): LineStringFeature2d => {
    const __is = (input: any): input is LineStringFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeature2d = (input: any, _exceptionable: boolean = true): input is LineStringFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeature2d = (input: any): input is LineStringFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeature2d = (input: LineStringFeature2d): string => {
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeature2d = (input: any): typia.IValidation<LineStringFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeature3d
export const assertLineStringFeature3d = (input: any): LineStringFeature3d => {
    const __is = (input: any): input is LineStringFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "number",
                value: input.coordinates[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            })) && ("number" === typeof input.coordinates[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][2]",
                expected: "number",
                value: input.coordinates[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeature3d = (input: any, _exceptionable: boolean = true): input is LineStringFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeature3d = (input: any): input is LineStringFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeature3d = (input: LineStringFeature3d): string => {
    const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeature3d = (input: any): typia.IValidation<LineStringFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        }),
                        "number" === typeof input.coordinates[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "number",
                            value: input.coordinates[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        }),
                        "number" === typeof input.coordinates[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][2]",
                            expected: "number",
                            value: input.coordinates[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeatureCollection
export const assertLineStringFeatureCollection = (input: any): LineStringFeatureCollection => {
    const __is = (input: any): input is LineStringFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeatureCollection = (input: any, _exceptionable: boolean = true): input is LineStringFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeatureCollection = (input: any): input is LineStringFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeatureCollection = (input: LineStringFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeatureCollection = (input: any): typia.IValidation<LineStringFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeatureCollection2d
export const assertLineStringFeatureCollection2d = (input: any): LineStringFeatureCollection2d => {
    const __is = (input: any): input is LineStringFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is LineStringFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeatureCollection2d = (input: any): input is LineStringFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeatureCollection2d = (input: LineStringFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeatureCollection2d = (input: any): typia.IValidation<LineStringFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index2) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index2) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringFeatureCollection3d
export const assertLineStringFeatureCollection3d = (input: any): LineStringFeatureCollection3d => {
    const __is = (input: any): input is LineStringFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "LineStringFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<LineStringFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "LineStringGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "number",
                value: input.coordinates[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            })) && ("number" === typeof input.coordinates[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][2]",
                expected: "number",
                value: input.coordinates[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is LineStringFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringFeatureCollection3d = (input: any): input is LineStringFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyLineStringFeatureCollection3d = (input: LineStringFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateLineStringFeatureCollection3d = (input: any): typia.IValidation<LineStringFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "LineStringFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<LineStringFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "LineStringGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        }),
                        "number" === typeof input.coordinates[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "number",
                            value: input.coordinates[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        }),
                        "number" === typeof input.coordinates[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][2]",
                            expected: "number",
                            value: input.coordinates[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index2) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index2) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index2) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index2) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry
export const assertLineStringGeometry = (input: any): LineStringGeometry => {
    const __is = (input: any): input is LineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ($ap0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ($ap0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry = (input: any, _exceptionable: boolean = true): input is LineStringGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry = (input: any): input is LineStringGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry = (input: LineStringGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${(() => {
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`;
        if (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]))
            return `[${input.coordinates[0][0]},${input.coordinates[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`;
        if (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1]))
            return `[${input.coordinates[1][0]},${input.coordinates[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[1]
        });
    })()}${$rest(`[${input.coordinates.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry = (input: any): typia.IValidation<LineStringGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && ($ip0(input.coordinates[0]) || false) && (Array.isArray(input.coordinates[1]) && ($ip0(input.coordinates[1]) || false)) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    })) && ($vp0(input.coordinates[0], _path + ".coordinates[0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })) && ($vp0(input.coordinates[1], _path + ".coordinates[1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input.coordinates[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry2d
export const assertLineStringGeometry2d = (input: any): LineStringGeometry2d => {
    const __is = (input: any): input is LineStringGeometry2d => {
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate2d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate2d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate2d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry2d = (input: any, _exceptionable: boolean = true): input is LineStringGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry2d = (input: any): input is LineStringGeometry2d => {
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry2d = (input: LineStringGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry2d = (input: any): typia.IValidation<LineStringGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry2d => {
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 2 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 2 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate2d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate2d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate2d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometry3d
export const assertLineStringGeometry3d = (input: any): LineStringGeometry3d => {
    const __is = (input: any): input is LineStringGeometry3d => {
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("LineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"LineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[number, number, number]",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "number",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "number",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "number",
                value: input.coordinates[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "Coordinate3d",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((input.coordinates[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "[number, number, number]",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][0]",
                expected: "number",
                value: input.coordinates[1][0]
            })) && ("number" === typeof input.coordinates[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][1]",
                expected: "number",
                value: input.coordinates[1][1]
            })) && ("number" === typeof input.coordinates[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[1][2]",
                expected: "number",
                value: input.coordinates[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "Coordinate3d",
                value: input.coordinates[1]
            })) && ((Array.isArray(input.coordinates.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            })) && input.coordinates.slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...Coordinate3d",
                value: input.coordinates.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometry3d = (input: any, _exceptionable: boolean = true): input is LineStringGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isLineStringGeometry3d = (input: any): input is LineStringGeometry3d => {
    const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomLineStringGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "LineString",
        coordinates: [
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ]
    });
    return $ro0();
};
export const stringifyLineStringGeometry3d = (input: LineStringGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${input.coordinates[0][0]},${input.coordinates[0][1]},${input.coordinates[0][2]}]`},${`[${input.coordinates[1][0]},${input.coordinates[1][1]},${input.coordinates[1][2]}]`}${$rest(`[${input.coordinates.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateLineStringGeometry3d = (input: any): typia.IValidation<LineStringGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometry3d => {
        const $io0 = (input: any): boolean => "LineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 3 && "number" === typeof input.coordinates[0][0] && "number" === typeof input.coordinates[0][1] && "number" === typeof input.coordinates[0][2]) && (Array.isArray(input.coordinates[1]) && (input.coordinates[1].length === 3 && "number" === typeof input.coordinates[1][0] && "number" === typeof input.coordinates[1][1] && "number" === typeof input.coordinates[1][2])) && (Array.isArray(input.coordinates.slice(2)) && input.coordinates.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["LineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"LineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[number, number, number]",
                        value: input.coordinates[0]
                    })) && [
                        "number" === typeof input.coordinates[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "number",
                            value: input.coordinates[0][0]
                        }),
                        "number" === typeof input.coordinates[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "number",
                            value: input.coordinates[0][1]
                        }),
                        "number" === typeof input.coordinates[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "number",
                            value: input.coordinates[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "Coordinate3d",
                        value: input.coordinates[0]
                    }),
                    (Array.isArray(input.coordinates[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })) && ((input.coordinates[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "[number, number, number]",
                        value: input.coordinates[1]
                    })) && [
                        "number" === typeof input.coordinates[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][0]",
                            expected: "number",
                            value: input.coordinates[1][0]
                        }),
                        "number" === typeof input.coordinates[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][1]",
                            expected: "number",
                            value: input.coordinates[1][1]
                        }),
                        "number" === typeof input.coordinates[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[1][2]",
                            expected: "number",
                            value: input.coordinates[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "Coordinate3d",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                })) && input.coordinates.slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (2 + _index1) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (2 + _index1) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...Coordinate3d",
                    value: input.coordinates.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "LineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// LineStringGeometryType
export const assertLineStringGeometryType = (input: any): LineStringGeometryType => {
    const __is = (input: any): input is LineStringGeometryType => {
        return "LineString" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "LineString" === input || $guard(true, {
                path: _path + "",
                expected: "\"LineString\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsLineStringGeometryType = (input: any, _exceptionable: boolean = true): input is LineStringGeometryType => {
    return "LineString" === input;
};
export const isLineStringGeometryType = (input: any): input is LineStringGeometryType => {
    return "LineString" === input;
};
export const randomLineStringGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<LineStringGeometryType> => {
    return "LineString";
};
export const stringifyLineStringGeometryType = (input: LineStringGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"LineString\"",
            value: input
        });
    })();
};
export const validateLineStringGeometryType = (input: any): typia.IValidation<LineStringGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is LineStringGeometryType => {
        return "LineString" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is LineStringGeometryType => {
            return "LineString" === input || $report(true, {
                path: _path + "",
                expected: "\"LineString\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesMetadata
export const assertMbtilesMetadata = (input: any): MbtilesMetadata => {
    const __is = (input: any): input is MbtilesMetadata => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadata => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.value || $guard(_exceptionable, {
                path: _path + ".value",
                expected: "string",
                value: input.value
            }));
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            })) && input.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) && $ao0(elem, _path + "[" + _index1 + "]", true) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesMetadata = (input: any, _exceptionable: boolean = true): input is MbtilesMetadata => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && "string" === typeof input.value && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "value"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return Array.isArray(input) && input.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io0(elem, true));
};
export const isMbtilesMetadata = (input: any): input is MbtilesMetadata => {
    const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
    return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
};
export const randomMbtilesMetadata = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MbtilesMetadata> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        value: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return (generator?.array ?? $generator.array)(() => $ro0());
};
export const stringifyMbtilesMetadata = (input: MbtilesMetadata): string => {
    const $string = (typia.createStringify as any).string;
    return `[${input.map((elem: any) => `{"name":${$string((elem as any).name)},"value":${$string((elem as any).value)}}`).join(",")}]`;
};
export const validateMbtilesMetadata = (input: any): typia.IValidation<MbtilesMetadata> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesMetadata => {
        const $io0 = (input: any): boolean => "string" === typeof input.name && "string" === typeof input.value;
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadata => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.value || $report(_exceptionable, {
                    path: _path + ".value",
                    expected: "string",
                    value: input.value
                })].every((flag: boolean) => flag);
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            })) && input.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })) && $vo0(elem, _path + "[" + _index1 + "]", true) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "MbtilesMetadataRow",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadata",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesMetadataRow
export const assertMbtilesMetadataRow = (input: any): MbtilesMetadataRow => {
    const __is = (input: any): input is MbtilesMetadataRow => {
        return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.value || $guard(_exceptionable, {
                path: _path + ".value",
                expected: "string",
                value: input.value
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesMetadataRow = (input: any, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && "string" === typeof input.value && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "value"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMbtilesMetadataRow = (input: any): input is MbtilesMetadataRow => {
    return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
};
export const randomMbtilesMetadataRow = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MbtilesMetadataRow> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        value: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
    });
    return $ro0();
};
export const stringifyMbtilesMetadataRow = (input: MbtilesMetadataRow): string => {
    const $string = (typia.createStringify as any).string;
    return `{"name":${$string((input as any).name)},"value":${$string((input as any).value)}}`;
};
export const validateMbtilesMetadataRow = (input: any): typia.IValidation<MbtilesMetadataRow> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesMetadataRow => {
        return "object" === typeof input && null !== input && ("string" === typeof (input as any).name && "string" === typeof (input as any).value);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesMetadataRow => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.value || $report(_exceptionable, {
                    path: _path + ".value",
                    expected: "string",
                    value: input.value
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MbtilesMetadataRow",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MbtilesTilesRow
export const assertMbtilesTilesRow = (input: any): MbtilesTilesRow => {
    const __is = (input: any): input is MbtilesTilesRow => {
        const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesTilesRow => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("number" === typeof input.zoom_level || $guard(_exceptionable, {
                path: _path + ".zoom_level",
                expected: "number",
                value: input.zoom_level
            })) && ("number" === typeof input.tile_column || $guard(_exceptionable, {
                path: _path + ".tile_column",
                expected: "number",
                value: input.tile_column
            })) && ("number" === typeof input.tile_row || $guard(_exceptionable, {
                path: _path + ".tile_row",
                expected: "number",
                value: input.tile_row
            })) && true;
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMbtilesTilesRow = (input: any, _exceptionable: boolean = true): input is MbtilesTilesRow => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true && (4 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["zoom_level", "tile_column", "tile_row", "tile_data"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMbtilesTilesRow = (input: any): input is MbtilesTilesRow => {
    const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMbtilesTilesRow = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MbtilesTilesRow> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        zoom_level: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_column: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_row: (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
        tile_data: "fucking any type exists..."
    });
    return $ro0();
};
export const stringifyMbtilesTilesRow = (input: MbtilesTilesRow): string => {
    const $so0 = (input: any): any => `{${undefined === input.tile_data || "function" === typeof input.tile_data ? "" : `"tile_data":${undefined !== input.tile_data ? JSON.stringify(input.tile_data) : undefined},`}"zoom_level":${input.zoom_level},"tile_column":${input.tile_column},"tile_row":${input.tile_row}}`;
    return $so0(input);
};
export const validateMbtilesTilesRow = (input: any): typia.IValidation<MbtilesTilesRow> => {
    const errors = [] as any[];
    const __is = (input: any): input is MbtilesTilesRow => {
        const $io0 = (input: any): boolean => "number" === typeof input.zoom_level && "number" === typeof input.tile_column && "number" === typeof input.tile_row && true;
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MbtilesTilesRow => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["number" === typeof input.zoom_level || $report(_exceptionable, {
                    path: _path + ".zoom_level",
                    expected: "number",
                    value: input.zoom_level
                }), "number" === typeof input.tile_column || $report(_exceptionable, {
                    path: _path + ".tile_column",
                    expected: "number",
                    value: input.tile_column
                }), "number" === typeof input.tile_row || $report(_exceptionable, {
                    path: _path + ".tile_row",
                    expected: "number",
                    value: input.tile_row
                }), true].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MbtilesTilesRow",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringCoordinates
export const assertMultiLineStringCoordinates = (input: any): MultiLineStringCoordinates => {
    const __is = (input: any): input is MultiLineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input[0]
            })) && (((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0]
            })) && ($ap0(input[0][0], _path + "[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0]
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0]
            })) && ((Array.isArray(input[0][1]) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][1]
            })) && ($ap0(input[0][1], _path + "[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][1]
            })) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][1]
            })) && ((Array.isArray(input[0].slice(2)) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0].slice(2)
            })) && input[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0].slice(2)
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input[0]
            })) && ((Array.isArray(input.slice(1)) || $guard(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + "[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + "[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringCoordinates = (input: any, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0], true && _exceptionable) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1], true && _exceptionable) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))));
};
export const isMultiLineStringCoordinates = (input: any): input is MultiLineStringCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
};
export const randomMultiLineStringCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ],
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    ];
};
export const stringifyMultiLineStringCoordinates = (input: MultiLineStringCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    return `[${`[${(() => {
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][1]
        });
    })()}${$rest(`[${input[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`;
};
export const validateMultiLineStringCoordinates = (input: any): typia.IValidation<MultiLineStringCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0].slice(2)) && input[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input[0]
                })) && ([
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0]
                    })) && ($vp0(input[0][0], _path + "[0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][0]
                    })) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0]
                    }),
                    (Array.isArray(input[0][1]) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][1]
                    })) && ($vp0(input[0][1], _path + "[0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][1]
                    })) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input[0].slice(2)) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0].slice(2)
                })) && input[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[0][" + (2 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0].slice(2)
                }))) || $report(true, {
                    path: _path + "[0]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(1)) || $report(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && ([
                (Array.isArray(elem[0]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[0]
                })) && ($vp0(elem[0], _path + "[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem[0]
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[0]
                }),
                (Array.isArray(elem[1]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[1]
                })) && ($vp0(elem[1], _path + "[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem[1]
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[1]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeature
export const assertMultiLineStringFeature = (input: any): MultiLineStringFeature => {
    const __is = (input: any): input is MultiLineStringFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeature = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeature = (input: any): input is MultiLineStringFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeature = (input: MultiLineStringFeature): string => {
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeature = (input: any): typia.IValidation<MultiLineStringFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeature2d
export const assertMultiLineStringFeature2d = (input: any): MultiLineStringFeature2d => {
    const __is = (input: any): input is MultiLineStringFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((elem[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((elem[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeature2d = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeature2d = (input: any): input is MultiLineStringFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeature2d = (input: MultiLineStringFeature2d): string => {
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]}]`},${`[${elem[1][0]},${elem[1][1]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeature2d = (input: any): typia.IValidation<MultiLineStringFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    })) && ((elem[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })) && ((elem[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeature3d
export const assertMultiLineStringFeature3d = (input: any): MultiLineStringFeature3d => {
    const __is = (input: any): input is MultiLineStringFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((elem[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[number, number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "number",
                value: elem[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((elem[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[number, number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            })) && ("number" === typeof elem[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][2]",
                expected: "number",
                value: elem[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeature3d = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeature3d = (input: any): input is MultiLineStringFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeature3d = (input: MultiLineStringFeature3d): string => {
    const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`},${`[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeature3d = (input: any): typia.IValidation<MultiLineStringFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    })) && ((elem[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[number, number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        }),
                        "number" === typeof elem[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "number",
                            value: elem[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })) && ((elem[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[number, number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        }),
                        "number" === typeof elem[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][2]",
                            expected: "number",
                            value: elem[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeatureCollection
export const assertMultiLineStringFeatureCollection = (input: any): MultiLineStringFeatureCollection => {
    const __is = (input: any): input is MultiLineStringFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index3) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index3) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeatureCollection = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeatureCollection = (input: any): input is MultiLineStringFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeatureCollection = (input: MultiLineStringFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeatureCollection = (input: any): typia.IValidation<MultiLineStringFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index3) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index3) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeatureCollection2d
export const assertMultiLineStringFeatureCollection2d = (input: any): MultiLineStringFeatureCollection2d => {
    const __is = (input: any): input is MultiLineStringFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((elem[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "[number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((elem[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "[number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeatureCollection2d = (input: any): input is MultiLineStringFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeatureCollection2d = (input: MultiLineStringFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]}]`},${`[${elem[1][0]},${elem[1][1]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeatureCollection2d = (input: any): typia.IValidation<MultiLineStringFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    })) && ((elem[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "[number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })) && ((elem[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "[number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringFeatureCollection3d
export const assertMultiLineStringFeatureCollection3d = (input: any): MultiLineStringFeatureCollection3d => {
    const __is = (input: any): input is MultiLineStringFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiLineStringFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiLineStringFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiLineStringGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((elem[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "[number, number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "number",
                value: elem[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((elem[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "[number, number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            })) && ("number" === typeof elem[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1][2]",
                expected: "number",
                value: elem[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringFeatureCollection3d = (input: any): input is MultiLineStringFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiLineStringFeatureCollection3d = (input: MultiLineStringFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`},${`[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiLineStringFeatureCollection3d = (input: any): typia.IValidation<MultiLineStringFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiLineStringFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiLineStringFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiLineStringGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index2) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    })) && ((elem[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "[number, number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        }),
                        "number" === typeof elem[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "number",
                            value: elem[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })) && ((elem[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "[number, number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        }),
                        "number" === typeof elem[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][1][2]",
                            expected: "number",
                            value: elem[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "][" + (2 + _index4) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry
export const assertMultiLineStringGeometry = (input: any): MultiLineStringGeometry => {
    const __is = (input: any): input is MultiLineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ($ap0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ($ap0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0], true && _exceptionable) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1], true && _exceptionable) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry = (input: any): input is MultiLineStringGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ],
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry = (input: MultiLineStringGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${(() => {
        if (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]))
            return `[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`;
        if (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]))
            return `[${elem[0][0]},${elem[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0]
        });
    })()},${(() => {
        if (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2]))
            return `[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`;
        if (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1]))
            return `[${elem[1][0]},${elem[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[1]
        });
    })()}${$rest(`[${elem.slice(2).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry = (input: any): typia.IValidation<MultiLineStringGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && ($ip0(elem[0]) || false) && (Array.isArray(elem[1]) && ($ip0(elem[1]) || false)) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (2 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    })) && ($vp0(elem[0], _path + ".coordinates[" + (1 + _index2) + "][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })) && ($vp0(elem[1], _path + ".coordinates[" + (1 + _index2) + "][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[1]
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry2d
export const assertMultiLineStringGeometry2d = (input: any): MultiLineStringGeometry2d => {
    const __is = (input: any): input is MultiLineStringGeometry2d => {
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((elem[0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate2d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((elem[1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate2d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate2d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry2d = (input: any): input is MultiLineStringGeometry2d => {
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry2d = (input: MultiLineStringGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]}]`},${`[${elem[1][0]},${elem[1][1]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry2d = (input: any): typia.IValidation<MultiLineStringGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry2d => {
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 2 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1]) && (Array.isArray(elem[1]) && (elem[1].length === 2 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    })) && ((elem[0].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate2d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })) && ((elem[1].length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate2d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate2d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometry3d
export const assertMultiLineStringGeometry3d = (input: any): MultiLineStringGeometry3d => {
    const __is = (input: any): input is MultiLineStringGeometry3d => {
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiLineString" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiLineString\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0].slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            })) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) && (((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((elem[0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "[number, number, number]",
                value: elem[0]
            })) && ("number" === typeof elem[0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "number",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "number",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "number",
                value: elem[0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "Coordinate3d",
                value: elem[0]
            })) && ((Array.isArray(elem[1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((elem[1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "[number, number, number]",
                value: elem[1]
            })) && ("number" === typeof elem[1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                expected: "number",
                value: elem[1][0]
            })) && ("number" === typeof elem[1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                expected: "number",
                value: elem[1][1]
            })) && ("number" === typeof elem[1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1][2]",
                expected: "number",
                value: elem[1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                expected: "Coordinate3d",
                value: elem[1]
            })) && ((Array.isArray(elem.slice(2)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            })) && elem.slice(2).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "...Coordinate3d",
                value: elem.slice(2)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "LineStringCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...LineStringCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiLineStringCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiLineStringGeometry3d = (input: any): input is MultiLineStringGeometry3d => {
    const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiLineStringGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiLineString",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ],
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiLineStringGeometry3d = (input: MultiLineStringGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`}${$rest(`[${input.coordinates[0].slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${elem[0][0]},${elem[0][1]},${elem[0][2]}]`},${`[${elem[1][0]},${elem[1][1]},${elem[1][2]}]`}${$rest(`[${elem.slice(2).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiLineStringGeometry3d = (input: any): typia.IValidation<MultiLineStringGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometry3d => {
        const $io0 = (input: any): boolean => "MultiLineString" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0].slice(2)) && input.coordinates[0].slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (Array.isArray(elem[0]) && (elem[0].length === 3 && "number" === typeof elem[0][0] && "number" === typeof elem[0][1] && "number" === typeof elem[0][2]) && (Array.isArray(elem[1]) && (elem[1].length === 3 && "number" === typeof elem[1][0] && "number" === typeof elem[1][1] && "number" === typeof elem[1][2])) && (Array.isArray(elem.slice(2)) && elem.slice(2).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiLineString" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiLineString\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(2)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    })) && input.coordinates[0].slice(2).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (2 + _index1) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (2 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(2)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "LineStringCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })) && ([
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    })) && ((elem[0].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "[number, number, number]",
                        value: elem[0]
                    })) && [
                        "number" === typeof elem[0][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "number",
                            value: elem[0][0]
                        }),
                        "number" === typeof elem[0][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "number",
                            value: elem[0][1]
                        }),
                        "number" === typeof elem[0][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "number",
                            value: elem[0][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "Coordinate3d",
                        value: elem[0]
                    }),
                    (Array.isArray(elem[1]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })) && ((elem[1].length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "[number, number, number]",
                        value: elem[1]
                    })) && [
                        "number" === typeof elem[1][0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][0]",
                            expected: "number",
                            value: elem[1][0]
                        }),
                        "number" === typeof elem[1][1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][1]",
                            expected: "number",
                            value: elem[1][1]
                        }),
                        "number" === typeof elem[1][2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][1][2]",
                            expected: "number",
                            value: elem[1][2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][1]",
                        expected: "Coordinate3d",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem.slice(2)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                })) && elem.slice(2).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "][" + (2 + _index3) + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "...Coordinate3d",
                    value: elem.slice(2)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "LineStringCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...LineStringCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiLineStringCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiLineStringGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiLineStringGeometryType
export const assertMultiLineStringGeometryType = (input: any): MultiLineStringGeometryType => {
    const __is = (input: any): input is MultiLineStringGeometryType => {
        return "MultiLineString" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiLineString" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiLineString\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiLineStringGeometryType = (input: any, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
    return "MultiLineString" === input;
};
export const isMultiLineStringGeometryType = (input: any): input is MultiLineStringGeometryType => {
    return "MultiLineString" === input;
};
export const randomMultiLineStringGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiLineStringGeometryType> => {
    return "MultiLineString";
};
export const stringifyMultiLineStringGeometryType = (input: MultiLineStringGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiLineString\"",
            value: input
        });
    })();
};
export const validateMultiLineStringGeometryType = (input: any): typia.IValidation<MultiLineStringGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiLineStringGeometryType => {
        return "MultiLineString" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiLineStringGeometryType => {
            return "MultiLineString" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiLineString\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointCoordinates
export const assertMultiPointCoordinates = (input: any): MultiPointCoordinates => {
    const __is = (input: any): input is MultiPointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            })) && input.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + _index1 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointCoordinates = (input: any, _exceptionable: boolean = true): input is MultiPointCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && input.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false));
};
export const isMultiPointCoordinates = (input: any): input is MultiPointCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
};
export const randomMultiPointCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return (generator?.array ?? $generator.array)(() => $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])());
};
export const stringifyMultiPointCoordinates = (input: MultiPointCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    return `[${input.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`;
};
export const validateMultiPointCoordinates = (input: any): typia.IValidation<MultiPointCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && input.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            })) && input.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + _index1 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "MultiPointCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeature
export const assertMultiPointFeature = (input: any): MultiPointFeature => {
    const __is = (input: any): input is MultiPointFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeature = (input: any, _exceptionable: boolean = true): input is MultiPointFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeature = (input: any): input is MultiPointFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeature = (input: MultiPointFeature): string => {
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeature = (input: any): typia.IValidation<MultiPointFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeature2d
export const assertMultiPointFeature2d = (input: any): MultiPointFeature2d => {
    const __is = (input: any): input is MultiPointFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeature2d = (input: any, _exceptionable: boolean = true): input is MultiPointFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeature2d = (input: any): input is MultiPointFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeature2d = (input: MultiPointFeature2d): string => {
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeature2d = (input: any): typia.IValidation<MultiPointFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeature3d
export const assertMultiPointFeature3d = (input: any): MultiPointFeature3d => {
    const __is = (input: any): input is MultiPointFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeature3d = (input: any, _exceptionable: boolean = true): input is MultiPointFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeature3d = (input: any): input is MultiPointFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeature3d = (input: MultiPointFeature3d): string => {
    const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeature3d = (input: any): typia.IValidation<MultiPointFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeatureCollection
export const assertMultiPointFeatureCollection = (input: any): MultiPointFeatureCollection => {
    const __is = (input: any): input is MultiPointFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index2 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeatureCollection = (input: any, _exceptionable: boolean = true): input is MultiPointFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeatureCollection = (input: any): input is MultiPointFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeatureCollection = (input: MultiPointFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeatureCollection = (input: any): typia.IValidation<MultiPointFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index2 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeatureCollection2d
export const assertMultiPointFeatureCollection2d = (input: any): MultiPointFeatureCollection2d => {
    const __is = (input: any): input is MultiPointFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is MultiPointFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeatureCollection2d = (input: any): input is MultiPointFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeatureCollection2d = (input: MultiPointFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeatureCollection2d = (input: any): typia.IValidation<MultiPointFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index2 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index2 + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointFeatureCollection3d
export const assertMultiPointFeatureCollection3d = (input: any): MultiPointFeatureCollection3d => {
    const __is = (input: any): input is MultiPointFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPointFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPointFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPointGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index2 + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is MultiPointFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointFeatureCollection3d = (input: any): input is MultiPointFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPointFeatureCollection3d = (input: MultiPointFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPointFeatureCollection3d = (input: any): typia.IValidation<MultiPointFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPointFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPointFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPointGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index2 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index2 + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index2 + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index2 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry
export const assertMultiPointGeometry = (input: any): MultiPointGeometry => {
    const __is = (input: any): input is MultiPointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry = (input: any): input is MultiPointGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])())
    });
    return $ro0();
};
export const stringifyMultiPointGeometry = (input: MultiPointGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry = (input: any): typia.IValidation<MultiPointGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + ".coordinates[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry2d
export const assertMultiPointGeometry2d = (input: any): MultiPointGeometry2d => {
    const __is = (input: any): input is MultiPointGeometry2d => {
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry2d = (input: any): input is MultiPointGeometry2d => {
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    return $ro0();
};
export const stringifyMultiPointGeometry2d = (input: MultiPointGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry2d = (input: any): typia.IValidation<MultiPointGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry2d => {
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })) && ((elem.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][1]",
                        expected: "number",
                        value: elem[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate2d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometry3d
export const assertMultiPointGeometry3d = (input: any): MultiPointGeometry3d => {
    const __is = (input: any): input is MultiPointGeometry3d => {
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPoint" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPoint\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && input.coordinates.every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + _index1 + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPointCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPointGeometry3d = (input: any): input is MultiPointGeometry3d => {
    const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPointGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPoint",
        coordinates: (generator?.array ?? $generator.array)(() => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])
    });
    return $ro0();
};
export const stringifyMultiPointGeometry3d = (input: MultiPointGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates.map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`}}`;
    return $so0(input);
};
export const validateMultiPointGeometry3d = (input: any): typia.IValidation<MultiPointGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometry3d => {
        const $io0 = (input: any): boolean => "MultiPoint" === input.type && (Array.isArray(input.coordinates) && input.coordinates.every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPoint" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPoint\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && input.coordinates.map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })) && ((elem.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "[number, number, number]",
                    value: elem
                })) && [
                    "number" === typeof elem[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][0]",
                        expected: "number",
                        value: elem[0]
                    }),
                    "number" === typeof elem[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][1]",
                        expected: "number",
                        value: elem[1]
                    }),
                    "number" === typeof elem[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[" + _index1 + "][2]",
                        expected: "number",
                        value: elem[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + _index1 + "]",
                    expected: "Coordinate3d",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPointCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPointGeometryType
export const assertMultiPointGeometryType = (input: any): MultiPointGeometryType => {
    const __is = (input: any): input is MultiPointGeometryType => {
        return "MultiPoint" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiPoint" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiPoint\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPointGeometryType = (input: any, _exceptionable: boolean = true): input is MultiPointGeometryType => {
    return "MultiPoint" === input;
};
export const isMultiPointGeometryType = (input: any): input is MultiPointGeometryType => {
    return "MultiPoint" === input;
};
export const randomMultiPointGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPointGeometryType> => {
    return "MultiPoint";
};
export const stringifyMultiPointGeometryType = (input: MultiPointGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiPoint\"",
            value: input
        });
    })();
};
export const validateMultiPointGeometryType = (input: any): typia.IValidation<MultiPointGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPointGeometryType => {
        return "MultiPoint" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPointGeometryType => {
            return "MultiPoint" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiPoint\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonCoordinates
export const assertMultiPolygonCoordinates = (input: any): MultiPolygonCoordinates => {
    const __is = (input: any): input is MultiPolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input[0]
            })) && ((input[0].length === 1 || $guard(true, {
                path: _path + "[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input[0]
            })) && ((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input[0][0]
            })) && (((Array.isArray(input[0][0][0]) || $guard(true, {
                path: _path + "[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][0]
            })) && ($ap0(input[0][0][0], _path + "[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0][0]
            })) || $guard(true, {
                path: _path + "[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][0]
            })) && ((Array.isArray(input[0][0][1]) || $guard(true, {
                path: _path + "[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][1]
            })) && ($ap0(input[0][0][1], _path + "[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0][1]
            })) || $guard(true, {
                path: _path + "[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][1]
            })) && ((Array.isArray(input[0][0][2]) || $guard(true, {
                path: _path + "[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][2]
            })) && ($ap0(input[0][0][2], _path + "[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0][2]
            })) || $guard(true, {
                path: _path + "[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][2]
            })) && ((Array.isArray(input[0][0][3]) || $guard(true, {
                path: _path + "[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][3]
            })) && ($ap0(input[0][0][3], _path + "[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0][3]
            })) || $guard(true, {
                path: _path + "[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0][3]
            })) && ((Array.isArray(input[0][0].slice(4)) || $guard(true, {
                path: _path + "[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0].slice(4)
            })) && input[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0].slice(4)
            }))) || $guard(true, {
                path: _path + "[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input[0][0]
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input[0]
            })) && ((Array.isArray(input.slice(1)) || $guard(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + "[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + "[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + "[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + "[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonCoordinates = (input: any, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0], true && _exceptionable) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))));
};
export const isMultiPolygonCoordinates = (input: any): input is MultiPolygonCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
};
export const randomMultiPolygonCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ],
        [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    ];
};
export const stringifyMultiPolygonCoordinates = (input: MultiPolygonCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    return `[${`[${`[${(() => {
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 3 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1] && "number" === typeof input[0][0][0][2]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]},${input[0][0][0][2]}]`;
        if (Array.isArray(input[0][0][0]) && (input[0][0][0].length === 2 && "number" === typeof input[0][0][0][0] && "number" === typeof input[0][0][0][1]))
            return `[${input[0][0][0][0]},${input[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 3 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1] && "number" === typeof input[0][0][1][2]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]},${input[0][0][1][2]}]`;
        if (Array.isArray(input[0][0][1]) && (input[0][0][1].length === 2 && "number" === typeof input[0][0][1][0] && "number" === typeof input[0][0][1][1]))
            return `[${input[0][0][1][0]},${input[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 3 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1] && "number" === typeof input[0][0][2][2]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]},${input[0][0][2][2]}]`;
        if (Array.isArray(input[0][0][2]) && (input[0][0][2].length === 2 && "number" === typeof input[0][0][2][0] && "number" === typeof input[0][0][2][1]))
            return `[${input[0][0][2][0]},${input[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 3 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1] && "number" === typeof input[0][0][3][2]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]},${input[0][0][3][2]}]`;
        if (Array.isArray(input[0][0][3]) && (input[0][0][3].length === 2 && "number" === typeof input[0][0][3][0] && "number" === typeof input[0][0][3][1]))
            return `[${input[0][0][3][0]},${input[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0][3]
        });
    })()}${$rest(`[${input[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`;
};
export const validateMultiPolygonCoordinates = (input: any): typia.IValidation<MultiPolygonCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && (input[0].length === 1 && (Array.isArray(input[0][0]) && (Array.isArray(input[0][0][0]) && ($ip0(input[0][0][0]) || false) && (Array.isArray(input[0][0][1]) && ($ip0(input[0][0][1]) || false)) && (Array.isArray(input[0][0][2]) && ($ip0(input[0][0][2]) || false)) && (Array.isArray(input[0][0][3]) && ($ip0(input[0][0][3]) || false)) && (Array.isArray(input[0][0].slice(4)) && input[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.slice(1)) && input.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input[0]
                })) && ((input[0].length === 1 || $report(true, {
                    path: _path + "[0]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input[0]
                })) && [
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input[0][0]
                    })) && ([
                        (Array.isArray(input[0][0][0]) || $report(true, {
                            path: _path + "[0][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][0]
                        })) && ($vp0(input[0][0][0], _path + "[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input[0][0][0]
                        })) || $report(true, {
                            path: _path + "[0][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][0]
                        }),
                        (Array.isArray(input[0][0][1]) || $report(true, {
                            path: _path + "[0][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][1]
                        })) && ($vp0(input[0][0][1], _path + "[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input[0][0][1]
                        })) || $report(true, {
                            path: _path + "[0][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][1]
                        }),
                        (Array.isArray(input[0][0][2]) || $report(true, {
                            path: _path + "[0][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][2]
                        })) && ($vp0(input[0][0][2], _path + "[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input[0][0][2]
                        })) || $report(true, {
                            path: _path + "[0][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][2]
                        }),
                        (Array.isArray(input[0][0][3]) || $report(true, {
                            path: _path + "[0][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][3]
                        })) && ($vp0(input[0][0][3], _path + "[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + "[0][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input[0][0][3]
                        })) || $report(true, {
                            path: _path + "[0][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input[0][0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input[0][0].slice(4)) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0].slice(4)
                    })) && input[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + "[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(true, {
                        path: _path + "[0][0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0].slice(4)
                    }))) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input[0][0]
                    })
                ].every((flag: boolean) => flag)) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(1)) || $report(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            })) && input.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && [
                (Array.isArray(elem[0]) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "PolygonCoordinatesRing<Coordinate>",
                    value: elem[0]
                })) && ([
                    (Array.isArray(elem[0][0]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][0]
                    })) && ($vp0(elem[0][0], _path + "[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0][0]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][0]
                    }),
                    (Array.isArray(elem[0][1]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][1]
                    })) && ($vp0(elem[0][1], _path + "[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0][1]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][1]
                    }),
                    (Array.isArray(elem[0][2]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][2]
                    })) && ($vp0(elem[0][2], _path + "[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0][2]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][2]
                    }),
                    (Array.isArray(elem[0][3]) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][3]
                    })) && ($vp0(elem[0][3], _path + "[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem[0][3]
                    })) || $report(true, {
                        path: _path + "[" + (1 + _index2) + "][0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0][3]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[0].slice(4)
                })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem[0].slice(4)
                }))) || $report(true, {
                    path: _path + "[" + (1 + _index2) + "][0]",
                    expected: "PolygonCoordinatesRing<Coordinate>",
                    value: elem[0]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.slice(1)
            }))) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeature
export const assertMultiPolygonFeature = (input: any): MultiPolygonFeature => {
    const __is = (input: any): input is MultiPolygonFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeature = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeature = (input: any): input is MultiPolygonFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeature = (input: MultiPolygonFeature): string => {
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeature = (input: any): typia.IValidation<MultiPolygonFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeature2d
export const assertMultiPolygonFeature2d = (input: any): MultiPolygonFeature2d => {
    const __is = (input: any): input is MultiPolygonFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeature2d = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeature2d = (input: any): input is MultiPolygonFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeature2d = (input: MultiPolygonFeature2d): string => {
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]}]`},${`[${elem[0][1][0]},${elem[0][1][1]}]`},${`[${elem[0][2][0]},${elem[0][2][1]}]`},${`[${elem[0][3][0]},${elem[0][3][1]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeature2d = (input: any): typia.IValidation<MultiPolygonFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })) && ((elem.length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                                expected: "number",
                                value: elem[1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeature3d
export const assertMultiPolygonFeature3d = (input: any): MultiPolygonFeature3d => {
    const __is = (input: any): input is MultiPolygonFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            })) && ("number" === typeof input.coordinates[0][0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][2]",
                expected: "number",
                value: input.coordinates[0][0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            })) && ("number" === typeof input.coordinates[0][0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][2]",
                expected: "number",
                value: input.coordinates[0][0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            })) && ("number" === typeof input.coordinates[0][0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][2]",
                expected: "number",
                value: input.coordinates[0][0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[number, number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            })) && ("number" === typeof elem[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][2]",
                expected: "number",
                value: elem[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[number, number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            })) && ("number" === typeof elem[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][2]",
                expected: "number",
                value: elem[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[number, number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            })) && ("number" === typeof elem[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][2]",
                expected: "number",
                value: elem[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[number, number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            })) && ("number" === typeof elem[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][2]",
                expected: "number",
                value: elem[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeature3d = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeature3d = (input: any): input is MultiPolygonFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeature3d = (input: MultiPolygonFeature3d): string => {
    const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`},${`[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`},${`[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`},${`[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeature3d = (input: any): typia.IValidation<MultiPolygonFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                }),
                                "number" === typeof input.coordinates[0][0][0][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                }),
                                "number" === typeof input.coordinates[0][0][1][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                }),
                                "number" === typeof input.coordinates[0][0][2][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                }),
                                "number" === typeof input.coordinates[0][0][3][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })) && ((elem.length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[number, number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                                expected: "number",
                                value: elem[1]
                            }),
                            "number" === typeof elem[2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][2]",
                                expected: "number",
                                value: elem[2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[number, number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            }),
                            "number" === typeof elem[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][2]",
                                expected: "number",
                                value: elem[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[number, number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            }),
                            "number" === typeof elem[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][2]",
                                expected: "number",
                                value: elem[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[number, number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            }),
                            "number" === typeof elem[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][2]",
                                expected: "number",
                                value: elem[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[number, number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            }),
                            "number" === typeof elem[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][2]",
                                expected: "number",
                                value: elem[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeatureCollection
export const assertMultiPolygonFeatureCollection = (input: any): MultiPolygonFeatureCollection => {
    const __is = (input: any): input is MultiPolygonFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index3) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index3) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index3) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index3) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeatureCollection = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index4: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeatureCollection = (input: any): input is MultiPolygonFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeatureCollection = (input: MultiPolygonFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeatureCollection = (input: any): typia.IValidation<MultiPolygonFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index3) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index3) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index3) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index3) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeatureCollection2d
export const assertMultiPolygonFeatureCollection2d = (input: any): MultiPolygonFeatureCollection2d => {
    const __is = (input: any): input is MultiPolygonFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "[number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "[number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "[number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "[number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeatureCollection2d = (input: any): input is MultiPolygonFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeatureCollection2d = (input: MultiPolygonFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]}]`},${`[${elem[0][1][0]},${elem[0][1][1]}]`},${`[${elem[0][2][0]},${elem[0][2][1]}]`},${`[${elem[0][3][0]},${elem[0][3][1]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeatureCollection2d = (input: any): typia.IValidation<MultiPolygonFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })) && ((elem.length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "[number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][1]",
                                expected: "number",
                                value: elem[1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "[number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "[number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "[number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "[number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonFeatureCollection3d
export const assertMultiPolygonFeatureCollection3d = (input: any): MultiPolygonFeatureCollection3d => {
    const __is = (input: any): input is MultiPolygonFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "MultiPolygonFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<MultiPolygonFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "MultiPolygonGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            })) && ("number" === typeof input.coordinates[0][0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][2]",
                expected: "number",
                value: input.coordinates[0][0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            })) && ("number" === typeof input.coordinates[0][0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][2]",
                expected: "number",
                value: input.coordinates[0][0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            })) && ("number" === typeof input.coordinates[0][0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][2]",
                expected: "number",
                value: input.coordinates[0][0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "[number, number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            })) && ("number" === typeof elem[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][2]",
                expected: "number",
                value: elem[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "[number, number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            })) && ("number" === typeof elem[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][2]",
                expected: "number",
                value: elem[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "[number, number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            })) && ("number" === typeof elem[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][2]",
                expected: "number",
                value: elem[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "[number, number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            })) && ("number" === typeof elem[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][2]",
                expected: "number",
                value: elem[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index4: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index3) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index4: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonFeatureCollection3d = (input: any): input is MultiPolygonFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyMultiPolygonFeatureCollection3d = (input: MultiPolygonFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`},${`[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`},${`[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`},${`[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateMultiPolygonFeatureCollection3d = (input: any): typia.IValidation<MultiPolygonFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "MultiPolygonFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<MultiPolygonFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "MultiPolygonGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                }),
                                "number" === typeof input.coordinates[0][0][0][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                }),
                                "number" === typeof input.coordinates[0][0][1][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                }),
                                "number" === typeof input.coordinates[0][0][2][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                }),
                                "number" === typeof input.coordinates[0][0][3][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })) && ((elem.length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "[number, number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][1]",
                                expected: "number",
                                value: elem[1]
                            }),
                            "number" === typeof elem[2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index2) + "][2]",
                                expected: "number",
                                value: elem[2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index2) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "[number, number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            }),
                            "number" === typeof elem[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][0][2]",
                                expected: "number",
                                value: elem[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "[number, number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            }),
                            "number" === typeof elem[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][1][2]",
                                expected: "number",
                                value: elem[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "[number, number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            }),
                            "number" === typeof elem[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][2][2]",
                                expected: "number",
                                value: elem[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "[number, number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            }),
                            "number" === typeof elem[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index3) + "][0][3][2]",
                                expected: "number",
                                value: elem[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index4: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0][" + (4 + _index4) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index3) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index3) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry
export const assertMultiPolygonGeometry = (input: any): MultiPolygonGeometry => {
    const __is = (input: any): input is MultiPolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ($ap0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ($ap0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ($ap0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ($ap0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ($ap0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ($ap0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ($ap0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ($ap0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0], true && _exceptionable) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1], true && _exceptionable) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2], true && _exceptionable) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3], true && _exceptionable) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false)))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry = (input: any): input is MultiPolygonGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ],
            [
                [
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])(),
                    $pick([
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ],
                        () => [
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                        ]
                    ])()
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry = (input: MultiPolygonGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]))
            return `[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1]))
            return `[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1]))
            return `[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1]))
            return `[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0][3]
        });
    })()}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${(() => {
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]))
            return `[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`;
        if (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]))
            return `[${elem[0][0][0]},${elem[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][0]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2]))
            return `[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`;
        if (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1]))
            return `[${elem[0][1][0]},${elem[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][1]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2]))
            return `[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`;
        if (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1]))
            return `[${elem[0][2][0]},${elem[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][2]
        });
    })()},${(() => {
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2]))
            return `[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`;
        if (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1]))
            return `[${elem[0][3][0]},${elem[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem[0][3]
        });
    })()}${$rest(`[${elem[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry = (input: any): typia.IValidation<MultiPolygonGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && ($ip0(input.coordinates[0][0][0]) || false) && (Array.isArray(input.coordinates[0][0][1]) && ($ip0(input.coordinates[0][0][1]) || false)) && (Array.isArray(input.coordinates[0][0][2]) && ($ip0(input.coordinates[0][0][2]) || false)) && (Array.isArray(input.coordinates[0][0][3]) && ($ip0(input.coordinates[0][0][3]) || false)) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && ($ip0(elem[0][0]) || false) && (Array.isArray(elem[0][1]) && ($ip0(elem[0][1]) || false)) && (Array.isArray(elem[0][2]) && ($ip0(elem[0][2]) || false)) && (Array.isArray(elem[0][3]) && ($ip0(elem[0][3]) || false)) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            })) && ($vp0(input.coordinates[0][0][0], _path + ".coordinates[0][0][0]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][0]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            })) && ($vp0(input.coordinates[0][0][1], _path + ".coordinates[0][0][1]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][1]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            })) && ($vp0(input.coordinates[0][0][2], _path + ".coordinates[0][0][2]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][2]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })) && ($vp0(input.coordinates[0][0][3], _path + ".coordinates[0][0][3]", true && _exceptionable) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                                value: input.coordinates[0][0][3]
                            })) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })) && ($vp0(elem, _path + ".coordinates[0][0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        })) && ($vp0(elem[0][0], _path + ".coordinates[" + (1 + _index2) + "][0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        })) && ($vp0(elem[0][1], _path + ".coordinates[" + (1 + _index2) + "][0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        })) && ($vp0(elem[0][2], _path + ".coordinates[" + (1 + _index2) + "][0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })) && ($vp0(elem[0][3], _path + ".coordinates[" + (1 + _index2) + "][0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: elem[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry2d
export const assertMultiPolygonGeometry2d = (input: any): MultiPolygonGeometry2d => {
    const __is = (input: any): input is MultiPolygonGeometry2d => {
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate2d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate2d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate2d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate2d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate2d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate2d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry2d = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry2d = (input: any): input is MultiPolygonGeometry2d => {
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry2d = (input: MultiPolygonGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]}]`},${`[${elem[0][1][0]},${elem[0][1][1]}]`},${`[${elem[0][2][0]},${elem[0][2][1]}]`},${`[${elem[0][3][0]},${elem[0][3][1]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry2d = (input: any): typia.IValidation<MultiPolygonGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry2d => {
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 2 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 2 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 2 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 2 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 2 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 2 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 2 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 2 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 2 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate2d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })) && ((elem.length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                                expected: "number",
                                value: elem[1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate2d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate2d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate2d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate2d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate2d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate2d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate2d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate2d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometry3d
export const assertMultiPolygonGeometry3d = (input: any): MultiPolygonGeometry3d => {
    const __is = (input: any): input is MultiPolygonGeometry3d => {
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("MultiPolygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"MultiPolygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && (((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((input.coordinates[0].length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            })) && (((Array.isArray(input.coordinates[0][0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((input.coordinates[0][0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][0]
            })) && ((Array.isArray(input.coordinates[0][0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((input.coordinates[0][0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][0]",
                expected: "number",
                value: input.coordinates[0][0][1][0]
            })) && ("number" === typeof input.coordinates[0][0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][1]",
                expected: "number",
                value: input.coordinates[0][0][1][1]
            })) && ("number" === typeof input.coordinates[0][0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1][2]",
                expected: "number",
                value: input.coordinates[0][0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][1]
            })) && ((Array.isArray(input.coordinates[0][0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((input.coordinates[0][0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][2]
            })) && ("number" === typeof input.coordinates[0][0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][0]",
                expected: "number",
                value: input.coordinates[0][0][2][0]
            })) && ("number" === typeof input.coordinates[0][0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][1]",
                expected: "number",
                value: input.coordinates[0][0][2][1]
            })) && ("number" === typeof input.coordinates[0][0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2][2]",
                expected: "number",
                value: input.coordinates[0][0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][2]
            })) && ((Array.isArray(input.coordinates[0][0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((input.coordinates[0][0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0][3]
            })) && ("number" === typeof input.coordinates[0][0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][0]",
                expected: "number",
                value: input.coordinates[0][0][3][0]
            })) && ("number" === typeof input.coordinates[0][0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][1]",
                expected: "number",
                value: input.coordinates[0][0][3][1]
            })) && ("number" === typeof input.coordinates[0][0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3][2]",
                expected: "number",
                value: input.coordinates[0][0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0][3]
            })) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            })) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0][0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0][0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates[0]
            })) && ((Array.isArray(input.coordinates.slice(1)) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            })) && input.coordinates.slice(1).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) && ((elem.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: elem
            })) && ((Array.isArray(elem[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            })) && (((Array.isArray(elem[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((elem[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "[number, number, number]",
                value: elem[0][0]
            })) && ("number" === typeof elem[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                expected: "number",
                value: elem[0][0][0]
            })) && ("number" === typeof elem[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                expected: "number",
                value: elem[0][0][1]
            })) && ("number" === typeof elem[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][2]",
                expected: "number",
                value: elem[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                expected: "Coordinate3d",
                value: elem[0][0]
            })) && ((Array.isArray(elem[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((elem[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "[number, number, number]",
                value: elem[0][1]
            })) && ("number" === typeof elem[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                expected: "number",
                value: elem[0][1][0]
            })) && ("number" === typeof elem[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                expected: "number",
                value: elem[0][1][1]
            })) && ("number" === typeof elem[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][2]",
                expected: "number",
                value: elem[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                expected: "Coordinate3d",
                value: elem[0][1]
            })) && ((Array.isArray(elem[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((elem[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "[number, number, number]",
                value: elem[0][2]
            })) && ("number" === typeof elem[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                expected: "number",
                value: elem[0][2][0]
            })) && ("number" === typeof elem[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                expected: "number",
                value: elem[0][2][1]
            })) && ("number" === typeof elem[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][2]",
                expected: "number",
                value: elem[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                expected: "Coordinate3d",
                value: elem[0][2]
            })) && ((Array.isArray(elem[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((elem[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "[number, number, number]",
                value: elem[0][3]
            })) && ("number" === typeof elem[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                expected: "number",
                value: elem[0][3][0]
            })) && ("number" === typeof elem[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                expected: "number",
                value: elem[0][3][1]
            })) && ("number" === typeof elem[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][2]",
                expected: "number",
                value: elem[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                expected: "Coordinate3d",
                value: elem[0][3]
            })) && ((Array.isArray(elem[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            })) && elem[0].slice(4).every((elem: any, _index3: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "...Coordinate3d",
                value: elem[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: elem[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[" + (1 + _index2) + "]",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "...PolygonCoordinates<Coordinate3d>",
                value: input.coordinates.slice(1)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "MultiPolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometry3d = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any, _index3: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isMultiPolygonGeometry3d = (input: any): input is MultiPolygonGeometry3d => {
    const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomMultiPolygonGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "MultiPolygon",
        coordinates: [
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ],
            [
                [
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyMultiPolygonGeometry3d = (input: MultiPolygonGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${`[${input.coordinates[0][0][0][0]},${input.coordinates[0][0][0][1]},${input.coordinates[0][0][0][2]}]`},${`[${input.coordinates[0][0][1][0]},${input.coordinates[0][0][1][1]},${input.coordinates[0][0][1][2]}]`},${`[${input.coordinates[0][0][2][0]},${input.coordinates[0][0][2][1]},${input.coordinates[0][0][2][2]}]`},${`[${input.coordinates[0][0][3][0]},${input.coordinates[0][0][3][1]},${input.coordinates[0][0][3][2]}]`}${$rest(`[${input.coordinates[0][0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}${$rest(`[${input.coordinates.slice(1).map((elem: any) => `[${`[${`[${elem[0][0][0]},${elem[0][0][1]},${elem[0][0][2]}]`},${`[${elem[0][1][0]},${elem[0][1][1]},${elem[0][1][2]}]`},${`[${elem[0][2][0]},${elem[0][2][1]},${elem[0][2][2]}]`},${`[${elem[0][3][0]},${elem[0][3][1]},${elem[0][3][2]}]`}${$rest(`[${elem[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`).join(",")}]`)}]`}}`;
    return $so0(input);
};
export const validateMultiPolygonGeometry3d = (input: any): typia.IValidation<MultiPolygonGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometry3d => {
        const $io0 = (input: any): boolean => "MultiPolygon" === input.type && (Array.isArray(input.coordinates) && (Array.isArray(input.coordinates[0]) && (input.coordinates[0].length === 1 && (Array.isArray(input.coordinates[0][0]) && (Array.isArray(input.coordinates[0][0][0]) && (input.coordinates[0][0][0].length === 3 && "number" === typeof input.coordinates[0][0][0][0] && "number" === typeof input.coordinates[0][0][0][1] && "number" === typeof input.coordinates[0][0][0][2]) && (Array.isArray(input.coordinates[0][0][1]) && (input.coordinates[0][0][1].length === 3 && "number" === typeof input.coordinates[0][0][1][0] && "number" === typeof input.coordinates[0][0][1][1] && "number" === typeof input.coordinates[0][0][1][2])) && (Array.isArray(input.coordinates[0][0][2]) && (input.coordinates[0][0][2].length === 3 && "number" === typeof input.coordinates[0][0][2][0] && "number" === typeof input.coordinates[0][0][2][1] && "number" === typeof input.coordinates[0][0][2][2])) && (Array.isArray(input.coordinates[0][0][3]) && (input.coordinates[0][0][3].length === 3 && "number" === typeof input.coordinates[0][0][3][0] && "number" === typeof input.coordinates[0][0][3][1] && "number" === typeof input.coordinates[0][0][3][2])) && (Array.isArray(input.coordinates[0][0].slice(4)) && input.coordinates[0][0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))) && (Array.isArray(input.coordinates.slice(1)) && input.coordinates.slice(1).every((elem: any) => Array.isArray(elem) && (elem.length === 1 && (Array.isArray(elem[0]) && (Array.isArray(elem[0][0]) && (elem[0][0].length === 3 && "number" === typeof elem[0][0][0] && "number" === typeof elem[0][0][1] && "number" === typeof elem[0][0][2]) && (Array.isArray(elem[0][1]) && (elem[0][1].length === 3 && "number" === typeof elem[0][1][0] && "number" === typeof elem[0][1][1] && "number" === typeof elem[0][1][2])) && (Array.isArray(elem[0][2]) && (elem[0][2].length === 3 && "number" === typeof elem[0][2][0] && "number" === typeof elem[0][2][1] && "number" === typeof elem[0][2][2])) && (Array.isArray(elem[0][3]) && (elem[0][3].length === 3 && "number" === typeof elem[0][3][0] && "number" === typeof elem[0][3][1] && "number" === typeof elem[0][3][2])) && (Array.isArray(elem[0].slice(4)) && elem[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["MultiPolygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"MultiPolygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ([
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ((input.coordinates[0].length === 1 || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                        value: input.coordinates[0]
                    })) && [
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })) && ([
                            (Array.isArray(input.coordinates[0][0][0]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            })) && ((input.coordinates[0][0][0].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][0]
                            })) && [
                                "number" === typeof input.coordinates[0][0][0][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][0]
                                }),
                                "number" === typeof input.coordinates[0][0][0][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][1]
                                }),
                                "number" === typeof input.coordinates[0][0][0][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][0][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][0][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][0]
                            }),
                            (Array.isArray(input.coordinates[0][0][1]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            })) && ((input.coordinates[0][0][1].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][1]
                            })) && [
                                "number" === typeof input.coordinates[0][0][1][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][0]
                                }),
                                "number" === typeof input.coordinates[0][0][1][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][1]
                                }),
                                "number" === typeof input.coordinates[0][0][1][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][1][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][1][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][1]
                            }),
                            (Array.isArray(input.coordinates[0][0][2]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            })) && ((input.coordinates[0][0][2].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][2]
                            })) && [
                                "number" === typeof input.coordinates[0][0][2][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][0]
                                }),
                                "number" === typeof input.coordinates[0][0][2][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][1]
                                }),
                                "number" === typeof input.coordinates[0][0][2][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][2][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][2][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][2]
                            }),
                            (Array.isArray(input.coordinates[0][0][3]) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })) && ((input.coordinates[0][0][3].length === 3 || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "[number, number, number]",
                                value: input.coordinates[0][0][3]
                            })) && [
                                "number" === typeof input.coordinates[0][0][3][0] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][0]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][0]
                                }),
                                "number" === typeof input.coordinates[0][0][3][1] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][1]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][1]
                                }),
                                "number" === typeof input.coordinates[0][0][3][2] || $report(_exceptionable, {
                                    path: _path + ".coordinates[0][0][3][2]",
                                    expected: "number",
                                    value: input.coordinates[0][0][3][2]
                                })
                            ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][3]",
                                expected: "Coordinate3d",
                                value: input.coordinates[0][0][3]
                            })
                        ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0][0].slice(4)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        })) && input.coordinates[0][0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })) && ((elem.length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "[number, number, number]",
                            value: elem
                        })) && [
                            "number" === typeof elem[0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][0]",
                                expected: "number",
                                value: elem[0]
                            }),
                            "number" === typeof elem[1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][1]",
                                expected: "number",
                                value: elem[1]
                            }),
                            "number" === typeof elem[2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][" + (4 + _index1) + "][2]",
                                expected: "number",
                                value: elem[2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0][" + (4 + _index1) + "]",
                            expected: "Coordinate3d",
                            value: elem
                        })).every((flag: boolean) => flag) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "...Coordinate3d",
                            value: input.coordinates[0][0].slice(4)
                        }))) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "PolygonCoordinatesRing<Coordinate3d>",
                            value: input.coordinates[0][0]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinates<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates.slice(1)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                })) && input.coordinates.slice(1).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })) && ((elem.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: elem
                })) && [
                    (Array.isArray(elem[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })) && ([
                        (Array.isArray(elem[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        })) && ((elem[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "[number, number, number]",
                            value: elem[0][0]
                        })) && [
                            "number" === typeof elem[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][0]",
                                expected: "number",
                                value: elem[0][0][0]
                            }),
                            "number" === typeof elem[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][1]",
                                expected: "number",
                                value: elem[0][0][1]
                            }),
                            "number" === typeof elem[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][0][2]",
                                expected: "number",
                                value: elem[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][0]",
                            expected: "Coordinate3d",
                            value: elem[0][0]
                        }),
                        (Array.isArray(elem[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        })) && ((elem[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "[number, number, number]",
                            value: elem[0][1]
                        })) && [
                            "number" === typeof elem[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][0]",
                                expected: "number",
                                value: elem[0][1][0]
                            }),
                            "number" === typeof elem[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][1]",
                                expected: "number",
                                value: elem[0][1][1]
                            }),
                            "number" === typeof elem[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][1][2]",
                                expected: "number",
                                value: elem[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][1]",
                            expected: "Coordinate3d",
                            value: elem[0][1]
                        }),
                        (Array.isArray(elem[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        })) && ((elem[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "[number, number, number]",
                            value: elem[0][2]
                        })) && [
                            "number" === typeof elem[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][0]",
                                expected: "number",
                                value: elem[0][2][0]
                            }),
                            "number" === typeof elem[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][1]",
                                expected: "number",
                                value: elem[0][2][1]
                            }),
                            "number" === typeof elem[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][2][2]",
                                expected: "number",
                                value: elem[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][2]",
                            expected: "Coordinate3d",
                            value: elem[0][2]
                        }),
                        (Array.isArray(elem[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })) && ((elem[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "[number, number, number]",
                            value: elem[0][3]
                        })) && [
                            "number" === typeof elem[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][0]",
                                expected: "number",
                                value: elem[0][3][0]
                            }),
                            "number" === typeof elem[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][1]",
                                expected: "number",
                                value: elem[0][3][1]
                            }),
                            "number" === typeof elem[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[" + (1 + _index2) + "][0][3][2]",
                                expected: "number",
                                value: elem[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][3]",
                            expected: "Coordinate3d",
                            value: elem[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(elem[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    })) && elem[0].slice(4).map((elem: any, _index3: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0][" + (4 + _index3) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "...Coordinate3d",
                        value: elem[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[" + (1 + _index2) + "][0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: elem[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates[" + (1 + _index2) + "]",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "...PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates.slice(1)
                }))) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "MultiPolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "MultiPolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// MultiPolygonGeometryType
export const assertMultiPolygonGeometryType = (input: any): MultiPolygonGeometryType => {
    const __is = (input: any): input is MultiPolygonGeometryType => {
        return "MultiPolygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "MultiPolygon" === input || $guard(true, {
                path: _path + "",
                expected: "\"MultiPolygon\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsMultiPolygonGeometryType = (input: any, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
    return "MultiPolygon" === input;
};
export const isMultiPolygonGeometryType = (input: any): input is MultiPolygonGeometryType => {
    return "MultiPolygon" === input;
};
export const randomMultiPolygonGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<MultiPolygonGeometryType> => {
    return "MultiPolygon";
};
export const stringifyMultiPolygonGeometryType = (input: MultiPolygonGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"MultiPolygon\"",
            value: input
        });
    })();
};
export const validateMultiPolygonGeometryType = (input: any): typia.IValidation<MultiPolygonGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is MultiPolygonGeometryType => {
        return "MultiPolygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is MultiPolygonGeometryType => {
            return "MultiPolygon" === input || $report(true, {
                path: _path + "",
                expected: "\"MultiPolygon\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointCoordinates
export const assertPointCoordinates = (input: any): PointCoordinates => {
    const __is = (input: any): input is PointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            })) && ($ap0(input, _path + "", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input
            })) || $guard(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointCoordinates = (input: any, _exceptionable: boolean = true): input is PointCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input, true && _exceptionable) || false);
};
export const isPointCoordinates = (input: any): input is PointCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && ($ip0(input) || false);
};
export const randomPointCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ],
        () => [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    ])();
};
export const stringifyPointCoordinates = (input: PointCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if (Array.isArray(input) && (input.length === 3 && "number" === typeof input[0] && "number" === typeof input[1] && "number" === typeof input[2]))
            return `[${input[0]},${input[1]},${input[2]}]`;
        if (Array.isArray(input) && (input.length === 2 && "number" === typeof input[0] && "number" === typeof input[1]))
            return `[${input[0]},${input[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input
        });
    })();
};
export const validatePointCoordinates = (input: any): typia.IValidation<PointCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && ($ip0(input) || false);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            })) && ($vp0(input, _path + "", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input
            })) || $report(true, {
                path: _path + "",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeature
export const assertPointFeature = (input: any): PointFeature => {
    const __is = (input: any): input is PointFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeature = (input: any, _exceptionable: boolean = true): input is PointFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeature = (input: any): input is PointFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeature = (input: PointFeature): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeature = (input: any): typia.IValidation<PointFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeature2d
export const assertPointFeature2d = (input: any): PointFeature2d => {
    const __is = (input: any): input is PointFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            })) && ((input.coordinates.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeature2d = (input: any, _exceptionable: boolean = true): input is PointFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeature2d = (input: any): input is PointFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeature2d = (input: PointFeature2d): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeature2d = (input: any): typia.IValidation<PointFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeature3d
export const assertPointFeature3d = (input: any): PointFeature3d => {
    const __is = (input: any): input is PointFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            })) && ((input.coordinates.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[2]",
                expected: "number",
                value: input.coordinates[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeature3d = (input: any, _exceptionable: boolean = true): input is PointFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeature3d = (input: any): input is PointFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeature3d = (input: PointFeature3d): string => {
    const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeature3d = (input: any): typia.IValidation<PointFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    }),
                    "number" === typeof input.coordinates[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[2]",
                        expected: "number",
                        value: input.coordinates[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeatureCollection
export const assertPointFeatureCollection = (input: any): PointFeatureCollection => {
    const __is = (input: any): input is PointFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeatureCollection = (input: any, _exceptionable: boolean = true): input is PointFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeatureCollection = (input: any): input is PointFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeatureCollection = (input: PointFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeatureCollection = (input: any): typia.IValidation<PointFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeatureCollection2d
export const assertPointFeatureCollection2d = (input: any): PointFeatureCollection2d => {
    const __is = (input: any): input is PointFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            })) && ((input.coordinates.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is PointFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeatureCollection2d = (input: any): input is PointFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeatureCollection2d = (input: PointFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeatureCollection2d = (input: any): typia.IValidation<PointFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointFeatureCollection3d
export const assertPointFeatureCollection3d = (input: any): PointFeatureCollection3d => {
    const __is = (input: any): input is PointFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PointFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PointFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PointGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            })) && ((input.coordinates.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[2]",
                expected: "number",
                value: input.coordinates[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is PointFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointFeatureCollection3d = (input: any): input is PointFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPointFeatureCollection3d = (input: PointFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePointFeatureCollection3d = (input: any): typia.IValidation<PointFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PointFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PointFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PointGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    }),
                    "number" === typeof input.coordinates[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[2]",
                        expected: "number",
                        value: input.coordinates[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry
export const assertPointGeometry = (input: any): PointGeometry => {
    const __is = (input: any): input is PointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            })) && ($ap0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry = (input: any, _exceptionable: boolean = true): input is PointGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates, true && _exceptionable) || false)) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry = (input: any): input is PointGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    });
    return $ro0();
};
export const stringifyPointGeometry = (input: PointGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${(() => {
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]))
            return `[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`;
        if (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]))
            return `[${input.coordinates[0]},${input.coordinates[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates
        });
    })()}}`;
    return $so0(input);
};
export const validatePointGeometry = (input: any): typia.IValidation<PointGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && ($ip0(input.coordinates) || false));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })) && ($vp0(input.coordinates, _path + ".coordinates", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input.coordinates
                })) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry2d
export const assertPointGeometry2d = (input: any): PointGeometry2d => {
    const __is = (input: any): input is PointGeometry2d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            })) && ((input.coordinates.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate2d",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry2d = (input: any, _exceptionable: boolean = true): input is PointGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry2d = (input: any): input is PointGeometry2d => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    return $ro0();
};
export const stringifyPointGeometry2d = (input: PointGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]}]`}}`;
    return $so0(input);
};
export const validatePointGeometry2d = (input: any): typia.IValidation<PointGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry2d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 2 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1]));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 2 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate2d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometry3d
export const assertPointGeometry3d = (input: any): PointGeometry3d => {
    const __is = (input: any): input is PointGeometry3d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Point" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Point\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            })) && ((input.coordinates.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[number, number, number]",
                value: input.coordinates
            })) && ("number" === typeof input.coordinates[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "number",
                value: input.coordinates[0]
            })) && ("number" === typeof input.coordinates[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[1]",
                expected: "number",
                value: input.coordinates[1]
            })) && ("number" === typeof input.coordinates[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[2]",
                expected: "number",
                value: input.coordinates[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "Coordinate3d",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometry3d = (input: any, _exceptionable: boolean = true): input is PointGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2])) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPointGeometry3d = (input: any): input is PointGeometry3d => {
    const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPointGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Point",
        coordinates: [
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
            (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ]
    });
    return $ro0();
};
export const stringifyPointGeometry3d = (input: PointGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Point\"",
            value: input.type
        });
    })()},"coordinates":${`[${input.coordinates[0]},${input.coordinates[1]},${input.coordinates[2]}]`}}`;
    return $so0(input);
};
export const validatePointGeometry3d = (input: any): typia.IValidation<PointGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometry3d => {
        const $io0 = (input: any): boolean => "Point" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 3 && "number" === typeof input.coordinates[0] && "number" === typeof input.coordinates[1] && "number" === typeof input.coordinates[2]));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Point" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Point\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })) && ((input.coordinates.length === 3 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[number, number, number]",
                    value: input.coordinates
                })) && [
                    "number" === typeof input.coordinates[0] || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "number",
                        value: input.coordinates[0]
                    }),
                    "number" === typeof input.coordinates[1] || $report(_exceptionable, {
                        path: _path + ".coordinates[1]",
                        expected: "number",
                        value: input.coordinates[1]
                    }),
                    "number" === typeof input.coordinates[2] || $report(_exceptionable, {
                        path: _path + ".coordinates[2]",
                        expected: "number",
                        value: input.coordinates[2]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "Coordinate3d",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PointGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PointGeometryType
export const assertPointGeometryType = (input: any): PointGeometryType => {
    const __is = (input: any): input is PointGeometryType => {
        return "Point" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Point" === input || $guard(true, {
                path: _path + "",
                expected: "\"Point\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPointGeometryType = (input: any, _exceptionable: boolean = true): input is PointGeometryType => {
    return "Point" === input;
};
export const isPointGeometryType = (input: any): input is PointGeometryType => {
    return "Point" === input;
};
export const randomPointGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PointGeometryType> => {
    return "Point";
};
export const stringifyPointGeometryType = (input: PointGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Point\"",
            value: input
        });
    })();
};
export const validatePointGeometryType = (input: any): typia.IValidation<PointGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is PointGeometryType => {
        return "Point" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PointGeometryType => {
            return "Point" === input || $report(true, {
                path: _path + "",
                expected: "\"Point\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonCoordinates
export const assertPolygonCoordinates = (input: any): PolygonCoordinates => {
    const __is = (input: any): input is PolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinates => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            })) && ((input.length === 1 || $guard(true, {
                path: _path + "",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input
            })) && ((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input[0]
            })) && (((Array.isArray(input[0][0]) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0]
            })) && ($ap0(input[0][0], _path + "[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][0]
            })) || $guard(true, {
                path: _path + "[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][0]
            })) && ((Array.isArray(input[0][1]) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][1]
            })) && ($ap0(input[0][1], _path + "[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][1]
            })) || $guard(true, {
                path: _path + "[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][1]
            })) && ((Array.isArray(input[0][2]) || $guard(true, {
                path: _path + "[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][2]
            })) && ($ap0(input[0][2], _path + "[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][2]
            })) || $guard(true, {
                path: _path + "[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][2]
            })) && ((Array.isArray(input[0][3]) || $guard(true, {
                path: _path + "[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][3]
            })) && ($ap0(input[0][3], _path + "[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0][3]
            })) || $guard(true, {
                path: _path + "[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0][3]
            })) && ((Array.isArray(input[0].slice(4)) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0].slice(4)
            })) && input[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0].slice(4)
            }))) || $guard(true, {
                path: _path + "[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input[0]
            }))) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonCoordinates = (input: any, _exceptionable: boolean = true): input is PolygonCoordinates => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0], true && _exceptionable) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1], true && _exceptionable) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2], true && _exceptionable) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3], true && _exceptionable) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))));
};
export const isPolygonCoordinates = (input: any): input is PolygonCoordinates => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
};
export const randomPolygonCoordinates = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonCoordinates> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        [
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])(),
            $pick([
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                () => [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ])()
        ]
    ];
};
export const stringifyPolygonCoordinates = (input: PolygonCoordinates): string => {
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    return `[${`[${(() => {
        if (Array.isArray(input[0][0]) && (input[0][0].length === 3 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1] && "number" === typeof input[0][0][2]))
            return `[${input[0][0][0]},${input[0][0][1]},${input[0][0][2]}]`;
        if (Array.isArray(input[0][0]) && (input[0][0].length === 2 && "number" === typeof input[0][0][0] && "number" === typeof input[0][0][1]))
            return `[${input[0][0][0]},${input[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input[0][1]) && (input[0][1].length === 3 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1] && "number" === typeof input[0][1][2]))
            return `[${input[0][1][0]},${input[0][1][1]},${input[0][1][2]}]`;
        if (Array.isArray(input[0][1]) && (input[0][1].length === 2 && "number" === typeof input[0][1][0] && "number" === typeof input[0][1][1]))
            return `[${input[0][1][0]},${input[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input[0][2]) && (input[0][2].length === 3 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1] && "number" === typeof input[0][2][2]))
            return `[${input[0][2][0]},${input[0][2][1]},${input[0][2][2]}]`;
        if (Array.isArray(input[0][2]) && (input[0][2].length === 2 && "number" === typeof input[0][2][0] && "number" === typeof input[0][2][1]))
            return `[${input[0][2][0]},${input[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input[0][3]) && (input[0][3].length === 3 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1] && "number" === typeof input[0][3][2]))
            return `[${input[0][3][0]},${input[0][3][1]},${input[0][3][2]}]`;
        if (Array.isArray(input[0][3]) && (input[0][3].length === 2 && "number" === typeof input[0][3][0] && "number" === typeof input[0][3][1]))
            return `[${input[0][3][0]},${input[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0][3]
        });
    })()}${$rest(`[${input[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`;
};
export const validatePolygonCoordinates = (input: any): typia.IValidation<PolygonCoordinates> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonCoordinates => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (input.length === 1 && (Array.isArray(input[0]) && (Array.isArray(input[0][0]) && ($ip0(input[0][0]) || false) && (Array.isArray(input[0][1]) && ($ip0(input[0][1]) || false)) && (Array.isArray(input[0][2]) && ($ip0(input[0][2]) || false)) && (Array.isArray(input[0][3]) && ($ip0(input[0][3]) || false)) && (Array.isArray(input[0].slice(4)) && input[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinates => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            })) && ((input.length === 1 || $report(true, {
                path: _path + "",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input
            })) && [
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinatesRing<Coordinate>",
                    value: input[0]
                })) && ([
                    (Array.isArray(input[0][0]) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0]
                    })) && ($vp0(input[0][0], _path + "[0][0]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][0]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][0]
                    })) || $report(true, {
                        path: _path + "[0][0]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][0]
                    }),
                    (Array.isArray(input[0][1]) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][1]
                    })) && ($vp0(input[0][1], _path + "[0][1]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][1]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][1]
                    })) || $report(true, {
                        path: _path + "[0][1]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][1]
                    }),
                    (Array.isArray(input[0][2]) || $report(true, {
                        path: _path + "[0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][2]
                    })) && ($vp0(input[0][2], _path + "[0][2]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][2]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][2]
                    })) || $report(true, {
                        path: _path + "[0][2]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][2]
                    }),
                    (Array.isArray(input[0][3]) || $report(true, {
                        path: _path + "[0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][3]
                    })) && ($vp0(input[0][3], _path + "[0][3]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + "[0][3]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: input[0][3]
                    })) || $report(true, {
                        path: _path + "[0][3]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input[0][3]
                    })
                ].every((flag: boolean) => flag) && ((Array.isArray(input[0].slice(4)) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0].slice(4)
                })) && input[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })) && ($vp0(elem, _path + "[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: elem
                })) || $report(true, {
                    path: _path + "[0][" + (4 + _index1) + "]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: elem
                })).every((flag: boolean) => flag) || $report(true, {
                    path: _path + "[0]",
                    expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0].slice(4)
                }))) || $report(true, {
                    path: _path + "[0]",
                    expected: "PolygonCoordinatesRing<Coordinate>",
                    value: input[0]
                })
            ].every((flag: boolean) => flag)) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinates",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonCoordinatesRing
export const assertPolygonCoordinatesRing = (input: any): PolygonCoordinatesRing => {
    const __is = (input: any): input is PolygonCoordinatesRing => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinatesRing => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinatesRing",
                value: input
            })) && (((Array.isArray(input[0]) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0]
            })) && ($ap0(input[0], _path + "[0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[0]
            })) || $guard(true, {
                path: _path + "[0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[0]
            })) && ((Array.isArray(input[1]) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[1]
            })) && ($ap0(input[1], _path + "[1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[1]
            })) || $guard(true, {
                path: _path + "[1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[1]
            })) && ((Array.isArray(input[2]) || $guard(true, {
                path: _path + "[2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[2]
            })) && ($ap0(input[2], _path + "[2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[2]
            })) || $guard(true, {
                path: _path + "[2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[2]
            })) && ((Array.isArray(input[3]) || $guard(true, {
                path: _path + "[3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[3]
            })) && ($ap0(input[3], _path + "[3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input[3]
            })) || $guard(true, {
                path: _path + "[3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input[3]
            })) && ((Array.isArray(input.slice(4)) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(4)
            })) && input.slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + "[" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(4)
            }))) || $guard(true, {
                path: _path + "",
                expected: "PolygonCoordinatesRing",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonCoordinatesRing = (input: any, _exceptionable: boolean = true): input is PolygonCoordinatesRing => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0], true && _exceptionable) || false) && (Array.isArray(input[1]) && ($ip0(input[1], true && _exceptionable) || false)) && (Array.isArray(input[2]) && ($ip0(input[2], true && _exceptionable) || false)) && (Array.isArray(input[3]) && ($ip0(input[3], true && _exceptionable) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))));
};
export const isPolygonCoordinatesRing = (input: any): input is PolygonCoordinatesRing => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
};
export const randomPolygonCoordinatesRing = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonCoordinatesRing> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    return [
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])(),
        $pick([
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ],
            () => [
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ]
        ])()
    ];
};
export const stringifyPolygonCoordinatesRing = (input: PolygonCoordinatesRing): string => {
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    return `[${(() => {
        if (Array.isArray(input[0]) && (input[0].length === 3 && "number" === typeof input[0][0] && "number" === typeof input[0][1] && "number" === typeof input[0][2]))
            return `[${input[0][0]},${input[0][1]},${input[0][2]}]`;
        if (Array.isArray(input[0]) && (input[0].length === 2 && "number" === typeof input[0][0] && "number" === typeof input[0][1]))
            return `[${input[0][0]},${input[0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[0]
        });
    })()},${(() => {
        if (Array.isArray(input[1]) && (input[1].length === 3 && "number" === typeof input[1][0] && "number" === typeof input[1][1] && "number" === typeof input[1][2]))
            return `[${input[1][0]},${input[1][1]},${input[1][2]}]`;
        if (Array.isArray(input[1]) && (input[1].length === 2 && "number" === typeof input[1][0] && "number" === typeof input[1][1]))
            return `[${input[1][0]},${input[1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[1]
        });
    })()},${(() => {
        if (Array.isArray(input[2]) && (input[2].length === 3 && "number" === typeof input[2][0] && "number" === typeof input[2][1] && "number" === typeof input[2][2]))
            return `[${input[2][0]},${input[2][1]},${input[2][2]}]`;
        if (Array.isArray(input[2]) && (input[2].length === 2 && "number" === typeof input[2][0] && "number" === typeof input[2][1]))
            return `[${input[2][0]},${input[2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[2]
        });
    })()},${(() => {
        if (Array.isArray(input[3]) && (input[3].length === 3 && "number" === typeof input[3][0] && "number" === typeof input[3][1] && "number" === typeof input[3][2]))
            return `[${input[3][0]},${input[3][1]},${input[3][2]}]`;
        if (Array.isArray(input[3]) && (input[3].length === 2 && "number" === typeof input[3][0] && "number" === typeof input[3][1]))
            return `[${input[3][0]},${input[3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input[3]
        });
    })()}${$rest(`[${input.slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`;
};
export const validatePolygonCoordinatesRing = (input: any): typia.IValidation<PolygonCoordinatesRing> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonCoordinatesRing => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        return Array.isArray(input) && (Array.isArray(input[0]) && ($ip0(input[0]) || false) && (Array.isArray(input[1]) && ($ip0(input[1]) || false)) && (Array.isArray(input[2]) && ($ip0(input[2]) || false)) && (Array.isArray(input[3]) && ($ip0(input[3]) || false)) && (Array.isArray(input.slice(4)) && input.slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false))));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonCoordinatesRing => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinatesRing",
                value: input
            })) && ([
                (Array.isArray(input[0]) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0]
                })) && ($vp0(input[0], _path + "[0]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[0]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[0]
                })) || $report(true, {
                    path: _path + "[0]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[0]
                }),
                (Array.isArray(input[1]) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[1]
                })) && ($vp0(input[1], _path + "[1]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[1]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[1]
                })) || $report(true, {
                    path: _path + "[1]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[1]
                }),
                (Array.isArray(input[2]) || $report(true, {
                    path: _path + "[2]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[2]
                })) && ($vp0(input[2], _path + "[2]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[2]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[2]
                })) || $report(true, {
                    path: _path + "[2]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[2]
                }),
                (Array.isArray(input[3]) || $report(true, {
                    path: _path + "[3]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[3]
                })) && ($vp0(input[3], _path + "[3]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + "[3]",
                    expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                    value: input[3]
                })) || $report(true, {
                    path: _path + "[3]",
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input[3]
                })
            ].every((flag: boolean) => flag) && ((Array.isArray(input.slice(4)) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(4)
            })) && input.slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($vp0(elem, _path + "[" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $report(true, {
                path: _path + "[" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.slice(4)
            }))) || $report(true, {
                path: _path + "",
                expected: "PolygonCoordinatesRing",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeature
export const assertPolygonFeature = (input: any): PolygonFeature => {
    const __is = (input: any): input is PolygonFeature => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry<Coordinate>",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeature = (input: any, _exceptionable: boolean = true): input is PolygonFeature => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeature = (input: any): input is PolygonFeature => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeature = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeature> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeature = (input: PolygonFeature): string => {
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeature = (input: any): typia.IValidation<PolygonFeature> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeature => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeature",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeature",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeature2d
export const assertPolygonFeature2d = (input: any): PolygonFeature2d => {
    const __is = (input: any): input is PolygonFeature2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry2d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeature2d = (input: any, _exceptionable: boolean = true): input is PolygonFeature2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeature2d = (input: any): input is PolygonFeature2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeature2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeature2d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeature2d = (input: PolygonFeature2d): string => {
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeature2d = (input: any): typia.IValidation<PolygonFeature2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeature2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry2d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeature2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeature2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeature3d
export const assertPolygonFeature3d = (input: any): PolygonFeature3d => {
    const __is = (input: any): input is PolygonFeature3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry3d",
                value: input.geometry
            })) && $ao1(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao2(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            })) && ("number" === typeof input.coordinates[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][2]",
                expected: "number",
                value: input.coordinates[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            })) && ("number" === typeof input.coordinates[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][2]",
                expected: "number",
                value: input.coordinates[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeature3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeature3d = (input: any, _exceptionable: boolean = true): input is PolygonFeature3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeature3d = (input: any): input is PolygonFeature3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeature3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeature3d> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro2(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeature3d = (input: PolygonFeature3d): string => {
    const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so2(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so1(input.geometry)}}`;
    const $so1 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeature3d = (input: any): typia.IValidation<PolygonFeature3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeature3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io1(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io2(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io1 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeature3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry3d",
                    value: input.geometry
                })) && $vo1(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo2(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            }),
                            "number" === typeof input.coordinates[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][2]",
                                expected: "number",
                                value: input.coordinates[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            }),
                            "number" === typeof input.coordinates[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][2]",
                                expected: "number",
                                value: input.coordinates[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeature3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeature3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeatureCollection
export const assertPolygonFeatureCollection = (input: any): PolygonFeatureCollection => {
    const __is = (input: any): input is PolygonFeatureCollection => {
        const $join = (typia.createAssert as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature<Coordinate, GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature<Coordinate, GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry<Coordinate>",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry<Coordinate>",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeatureCollection = (input: any, _exceptionable: boolean = true): input is PolygonFeatureCollection => {
    const $join = (typia.createEquals as any).join;
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeatureCollection = (input: any): input is PolygonFeatureCollection => {
    const $join = (typia.createIs as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeatureCollection = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeatureCollection> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeatureCollection = (input: PolygonFeatureCollection): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeatureCollection = (input: any): typia.IValidation<PolygonFeatureCollection> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeatureCollection => {
        const $join = (typia.createValidate as any).join;
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection => {
            const $join = (typia.createValidate as any).join;
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature<Coordinate, GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature<Coordinate, GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry<Coordinate>",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry<Coordinate>",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index2) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeatureCollection2d
export const assertPolygonFeatureCollection2d = (input: any): PolygonFeatureCollection2d => {
    const __is = (input: any): input is PolygonFeatureCollection2d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection2d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature2d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature2d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature2d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature2d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry2d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry2d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeatureCollection2d = (input: any, _exceptionable: boolean = true): input is PolygonFeatureCollection2d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeatureCollection2d = (input: any): input is PolygonFeatureCollection2d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeatureCollection2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeatureCollection2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeatureCollection2d = (input: PolygonFeatureCollection2d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeatureCollection2d = (input: any): typia.IValidation<PolygonFeatureCollection2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeatureCollection2d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection2d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature2d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature2d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature2d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature2d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry2d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry2d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonFeatureCollection3d
export const assertPolygonFeatureCollection3d = (input: any): PolygonFeatureCollection3d => {
    const __is = (input: any): input is PolygonFeatureCollection3d => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection3d => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("FeatureCollection" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"FeatureCollection\"",
                value: input.type
            })) && ((Array.isArray(input.features) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature3d<GeoJsonProperties>>",
                value: input.features
            })) && input.features.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature3d<GeoJsonProperties>",
                value: elem
            })) && $ao1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".features[" + _index1 + "]",
                expected: "PolygonFeature3d<GeoJsonProperties>",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".features",
                expected: "Array<PolygonFeature3d<GeoJsonProperties>>",
                value: input.features
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Feature" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Feature\"",
                value: input.type
            })) && (("object" === typeof input.geometry && null !== input.geometry || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry3d",
                value: input.geometry
            })) && $ao2(input.geometry, _path + ".geometry", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".geometry",
                expected: "PolygonGeometry3d",
                value: input.geometry
            })) && (null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && $ao3(input.properties, _path + ".properties", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".properties",
                expected: "(Record<string, unknown> | null | undefined)",
                value: input.properties
            })) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "(number | string | undefined)",
                value: input.id
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            })) && ("number" === typeof input.coordinates[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][2]",
                expected: "number",
                value: input.coordinates[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            })) && ("number" === typeof input.coordinates[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][2]",
                expected: "number",
                value: input.coordinates[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonFeatureCollection3d = (input: any, _exceptionable: boolean = true): input is PolygonFeatureCollection3d => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "features"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry, true && _exceptionable)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties, true && _exceptionable)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "geometry", "properties", "id"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index2: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonFeatureCollection3d = (input: any): input is PolygonFeatureCollection3d => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonFeatureCollection3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonFeatureCollection3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "FeatureCollection",
        features: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Feature",
        geometry: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        properties: $pick([
            () => undefined,
            () => null,
            () => $ro3(_recursive, _recursive ? 1 + _depth : _depth)
        ])(),
        id: $pick([
            () => undefined,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyPolygonFeatureCollection3d = (input: PolygonFeatureCollection3d): string => {
    const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
    const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"FeatureCollection\"",
            value: input.type
        });
    })()},"features":${`[${input.features.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.properties ? "" : `"properties":${undefined !== input.properties ? null !== input.properties ? $so3(input.properties) : "null" : undefined},`}${undefined === input.id ? "" : `"id":${undefined !== input.id ? (() => {
        if ("string" === typeof input.id)
            return $string(input.id);
        if ("number" === typeof input.id)
            return input.id;
        $throws({
            expected: "(number | string | undefined)",
            value: input.id
        });
    })() : undefined},`}"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Feature\"",
            value: input.type
        });
    })()},"geometry":${$so2(input.geometry)}}`;
    const $so2 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}}`;
    const $so3 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validatePolygonFeatureCollection3d = (input: any): typia.IValidation<PolygonFeatureCollection3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonFeatureCollection3d => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "FeatureCollection" === input.type && (Array.isArray(input.features) && input.features.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem)));
        const $io1 = (input: any): boolean => "Feature" === input.type && ("object" === typeof input.geometry && null !== input.geometry && $io2(input.geometry)) && (null === input.properties || undefined === input.properties || "object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) && $io3(input.properties)) && (undefined === input.id || "string" === typeof input.id || "number" === typeof input.id);
        const $io2 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        const $io3 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonFeatureCollection3d => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["FeatureCollection" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"FeatureCollection\"",
                    value: input.type
                }), (Array.isArray(input.features) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature3d<GeoJsonProperties>>",
                    value: input.features
                })) && input.features.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature3d<GeoJsonProperties>",
                    value: elem
                })) && $vo1(elem, _path + ".features[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".features[" + _index1 + "]",
                    expected: "PolygonFeature3d<GeoJsonProperties>",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".features",
                    expected: "Array<PolygonFeature3d<GeoJsonProperties>>",
                    value: input.features
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Feature" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Feature\"",
                    value: input.type
                }), ("object" === typeof input.geometry && null !== input.geometry || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry3d",
                    value: input.geometry
                })) && $vo2(input.geometry, _path + ".geometry", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".geometry",
                    expected: "PolygonGeometry3d",
                    value: input.geometry
                }), null === input.properties || undefined === input.properties || ("object" === typeof input.properties && null !== input.properties && false === Array.isArray(input.properties) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                })) && $vo3(input.properties, _path + ".properties", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".properties",
                    expected: "(Record<string, unknown> | null | undefined)",
                    value: input.properties
                }), undefined === input.id || "string" === typeof input.id || "number" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "(number | string | undefined)",
                    value: input.id
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            }),
                            "number" === typeof input.coordinates[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][2]",
                                expected: "number",
                                value: input.coordinates[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            }),
                            "number" === typeof input.coordinates[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][2]",
                                expected: "number",
                                value: input.coordinates[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index2: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index2) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index2) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonFeatureCollection3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry
export const assertPolygonGeometry = (input: any): PolygonGeometry => {
    const __is = (input: any): input is PolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry => {
            const $guard = (typia.createAssert as any).guard;
            const $ap0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                        (entire: any[]): any => (entire.length === 3 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        })) && ("number" === typeof entire[2] || $guard(_exceptionable, {
                            path: _path + "[2]",
                            expected: "number",
                            value: entire[2]
                        }))
                    ],
                    [
                        (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                        (entire: any[]): any => (entire.length === 2 || $guard(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && ("number" === typeof entire[0] || $guard(_exceptionable, {
                            path: _path + "[0]",
                            expected: "number",
                            value: entire[0]
                        })) && ("number" === typeof entire[1] || $guard(_exceptionable, {
                            path: _path + "[1]",
                            expected: "number",
                            value: entire[1]
                        }))
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ($ap0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][0]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ($ap0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][1]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ($ap0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][2]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ($ap0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: input.coordinates[0][3]
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) && ($ap0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry = (input: any, _exceptionable: boolean = true): input is PolygonGeometry => {
    const $ip0 = (input: any, _exceptionable: boolean = true) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0], true && _exceptionable) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3], true && _exceptionable) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && ($ip0(elem, true && _exceptionable) || false))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry = (input: any): input is PolygonGeometry => {
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonGeometry> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])(),
                $pick([
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ],
                    () => [
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                        (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                    ]
                ])()
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry = (input: PolygonGeometry): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $ip0 = (input: any) => {
        const array = input;
        const tuplePredicators = [
            [
                (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
            ],
            [
                (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
            ]
        ];
        for (const pred of tuplePredicators)
            if (pred[0](array))
                return pred[1](array);
        return false;
    };
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${(() => {
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`;
        if (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]))
            return `[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][0]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`;
        if (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1]))
            return `[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][1]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`;
        if (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1]))
            return `[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][2]
        });
    })()},${(() => {
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`;
        if (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1]))
            return `[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: input.coordinates[0][3]
        });
    })()}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => (() => {
        if (Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))
            return `[${elem[0]},${elem[1]},${elem[2]}]`;
        if (Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))
            return `[${elem[0]},${elem[1]}]`;
        $throws({
            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
            value: elem
        });
    })()).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry = (input: any): typia.IValidation<PolygonGeometry> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry => {
        const $ip0 = (input: any) => {
            const array = input;
            const tuplePredicators = [
                [
                    (top: any[]): any => top.length === 3 && "number" === typeof top[0] && "number" === typeof top[1] && "number" === typeof top[2],
                    (entire: any[]): any => entire.length === 3 && "number" === typeof entire[0] && "number" === typeof entire[1] && "number" === typeof entire[2]
                ],
                [
                    (top: any[]): any => top.length === 2 && "number" === typeof top[0] && "number" === typeof top[1],
                    (entire: any[]): any => entire.length === 2 && "number" === typeof entire[0] && "number" === typeof entire[1]
                ]
            ];
            for (const pred of tuplePredicators)
                if (pred[0](array))
                    return pred[1](array);
            return false;
        };
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && ($ip0(input.coordinates[0][0]) || false) && (Array.isArray(input.coordinates[0][1]) && ($ip0(input.coordinates[0][1]) || false)) && (Array.isArray(input.coordinates[0][2]) && ($ip0(input.coordinates[0][2]) || false)) && (Array.isArray(input.coordinates[0][3]) && ($ip0(input.coordinates[0][3]) || false)) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && ($ip0(elem) || false)))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry => {
            const $vp0 = (input: any, _path: string, _exceptionable: boolean = true) => {
                const array = input;
                const tuplePredicators = [
                    [
                        (top: any[]): any => top.length === 3 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1],
                            "number" === typeof top[2]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 3 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            }),
                            "number" === typeof entire[2] || $report(_exceptionable, {
                                path: _path + "[2]",
                                expected: "number",
                                value: entire[2]
                            })
                        ].every((flag: boolean) => flag)
                    ],
                    [
                        (top: any[]): any => top.length === 2 && [
                            "number" === typeof top[0],
                            "number" === typeof top[1]
                        ].every((flag: boolean) => flag),
                        (entire: any[]): any => (entire.length === 2 || $report(_exceptionable, {
                            path: _path,
                            expected: "[number, number]",
                            value: entire
                        })) && [
                            "number" === typeof entire[0] || $report(_exceptionable, {
                                path: _path + "[0]",
                                expected: "number",
                                value: entire[0]
                            }),
                            "number" === typeof entire[1] || $report(_exceptionable, {
                                path: _path + "[1]",
                                expected: "number",
                                value: entire[1]
                            })
                        ].every((flag: boolean) => flag)
                    ]
                ];
                for (const pred of tuplePredicators)
                    if (pred[0](array))
                        return pred[1](array);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                    value: input
                });
            };
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        })) && ($vp0(input.coordinates[0][0], _path + ".coordinates[0][0]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][0]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        })) && ($vp0(input.coordinates[0][1], _path + ".coordinates[0][1]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][1]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        })) && ($vp0(input.coordinates[0][2], _path + ".coordinates[0][2]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][2]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })) && ($vp0(input.coordinates[0][3], _path + ".coordinates[0][3]", true && _exceptionable) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                            value: input.coordinates[0][3]
                        })) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })) && ($vp0(elem, _path + ".coordinates[0][" + (4 + _index1) + "]", true && _exceptionable) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[x: number, y: number, z: number] | [x: number, y: number]",
                        value: elem
                    })) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "([x: number, y: number, z: number] | [x: number, y: number])",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...([x: number, y: number, z: number] | [x: number, y: number])",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry2d
export const assertPolygonGeometry2d = (input: any): PolygonGeometry2d => {
    const __is = (input: any): input is PolygonGeometry2d => {
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry2d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate2d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate2d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate2d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate2d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) && ((elem.length === 2 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate2d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate2d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate2d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate2d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry2d = (input: any, _exceptionable: boolean = true): input is PolygonGeometry2d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry2d = (input: any): input is PolygonGeometry2d => {
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry2d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonGeometry2d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry2d = (input: PolygonGeometry2d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]}]`).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry2d = (input: any): typia.IValidation<PolygonGeometry2d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry2d => {
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 2 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 2 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 2 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 2 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 2 && "number" === typeof elem[0] && "number" === typeof elem[1])))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry2d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate2d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 2 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate2d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })) && ((elem.length === 2 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate2d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate2d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate2d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate2d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry2d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometry3d
export const assertPolygonGeometry3d = (input: any): PolygonGeometry3d => {
    const __is = (input: any): input is PolygonGeometry3d => {
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry3d => {
            const $guard = (typia.createAssert as any).guard;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("Polygon" === input.type || $guard(_exceptionable, {
                path: _path + ".type",
                expected: "\"Polygon\"",
                value: input.type
            })) && ((Array.isArray(input.coordinates) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            })) && ((input.coordinates.length === 1 || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                value: input.coordinates
            })) && ((Array.isArray(input.coordinates[0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            })) && (((Array.isArray(input.coordinates[0][0]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((input.coordinates[0][0].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "[number, number, number]",
                value: input.coordinates[0][0]
            })) && ("number" === typeof input.coordinates[0][0][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][0]",
                expected: "number",
                value: input.coordinates[0][0][0]
            })) && ("number" === typeof input.coordinates[0][0][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][1]",
                expected: "number",
                value: input.coordinates[0][0][1]
            })) && ("number" === typeof input.coordinates[0][0][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0][2]",
                expected: "number",
                value: input.coordinates[0][0][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][0]",
                expected: "Coordinate3d",
                value: input.coordinates[0][0]
            })) && ((Array.isArray(input.coordinates[0][1]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((input.coordinates[0][1].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "[number, number, number]",
                value: input.coordinates[0][1]
            })) && ("number" === typeof input.coordinates[0][1][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][0]",
                expected: "number",
                value: input.coordinates[0][1][0]
            })) && ("number" === typeof input.coordinates[0][1][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][1]",
                expected: "number",
                value: input.coordinates[0][1][1]
            })) && ("number" === typeof input.coordinates[0][1][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1][2]",
                expected: "number",
                value: input.coordinates[0][1][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][1]",
                expected: "Coordinate3d",
                value: input.coordinates[0][1]
            })) && ((Array.isArray(input.coordinates[0][2]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((input.coordinates[0][2].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "[number, number, number]",
                value: input.coordinates[0][2]
            })) && ("number" === typeof input.coordinates[0][2][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][0]",
                expected: "number",
                value: input.coordinates[0][2][0]
            })) && ("number" === typeof input.coordinates[0][2][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][1]",
                expected: "number",
                value: input.coordinates[0][2][1]
            })) && ("number" === typeof input.coordinates[0][2][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2][2]",
                expected: "number",
                value: input.coordinates[0][2][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][2]",
                expected: "Coordinate3d",
                value: input.coordinates[0][2]
            })) && ((Array.isArray(input.coordinates[0][3]) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((input.coordinates[0][3].length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "[number, number, number]",
                value: input.coordinates[0][3]
            })) && ("number" === typeof input.coordinates[0][3][0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][0]",
                expected: "number",
                value: input.coordinates[0][3][0]
            })) && ("number" === typeof input.coordinates[0][3][1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][1]",
                expected: "number",
                value: input.coordinates[0][3][1]
            })) && ("number" === typeof input.coordinates[0][3][2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3][2]",
                expected: "number",
                value: input.coordinates[0][3][2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][3]",
                expected: "Coordinate3d",
                value: input.coordinates[0][3]
            })) && ((Array.isArray(input.coordinates[0].slice(4)) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            })) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => (Array.isArray(elem) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) && ((elem.length === 3 || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "[number, number, number]",
                value: elem
            })) && ("number" === typeof elem[0] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                expected: "number",
                value: elem[0]
            })) && ("number" === typeof elem[1] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                expected: "number",
                value: elem[1]
            })) && ("number" === typeof elem[2] || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "][2]",
                expected: "number",
                value: elem[2]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                expected: "Coordinate3d",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "...Coordinate3d",
                value: input.coordinates[0].slice(4)
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates[0]",
                expected: "PolygonCoordinatesRing<Coordinate3d>",
                value: input.coordinates[0]
            }))) || $guard(_exceptionable, {
                path: _path + ".coordinates",
                expected: "PolygonCoordinates<Coordinate3d>",
                value: input.coordinates
            }));
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometry3d = (input: any, _exceptionable: boolean = true): input is PolygonGeometry3d => {
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any, _index1: number) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2]))))))) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["type", "coordinates"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isPolygonGeometry3d = (input: any): input is PolygonGeometry3d => {
    const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomPolygonGeometry3d = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonGeometry3d> => {
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        type: "Polygon",
        coordinates: [
            [
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ],
                [
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100),
                    (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
                ]
            ]
        ]
    });
    return $ro0();
};
export const stringifyPolygonGeometry3d = (input: PolygonGeometry3d): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $rest = (typia.createStringify as any).rest;
    const $so0 = (input: any): any => `{"type":${(() => {
        if ("string" === typeof input.type)
            return $string(input.type);
        if ("string" === typeof input.type)
            return "\"" + input.type + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input.type
        });
    })()},"coordinates":${`[${`[${`[${input.coordinates[0][0][0]},${input.coordinates[0][0][1]},${input.coordinates[0][0][2]}]`},${`[${input.coordinates[0][1][0]},${input.coordinates[0][1][1]},${input.coordinates[0][1][2]}]`},${`[${input.coordinates[0][2][0]},${input.coordinates[0][2][1]},${input.coordinates[0][2][2]}]`},${`[${input.coordinates[0][3][0]},${input.coordinates[0][3][1]},${input.coordinates[0][3][2]}]`}${$rest(`[${input.coordinates[0].slice(4).map((elem: any) => `[${elem[0]},${elem[1]},${elem[2]}]`).join(",")}]`)}]`}]`}}`;
    return $so0(input);
};
export const validatePolygonGeometry3d = (input: any): typia.IValidation<PolygonGeometry3d> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometry3d => {
        const $io0 = (input: any): boolean => "Polygon" === input.type && (Array.isArray(input.coordinates) && (input.coordinates.length === 1 && (Array.isArray(input.coordinates[0]) && (Array.isArray(input.coordinates[0][0]) && (input.coordinates[0][0].length === 3 && "number" === typeof input.coordinates[0][0][0] && "number" === typeof input.coordinates[0][0][1] && "number" === typeof input.coordinates[0][0][2]) && (Array.isArray(input.coordinates[0][1]) && (input.coordinates[0][1].length === 3 && "number" === typeof input.coordinates[0][1][0] && "number" === typeof input.coordinates[0][1][1] && "number" === typeof input.coordinates[0][1][2])) && (Array.isArray(input.coordinates[0][2]) && (input.coordinates[0][2].length === 3 && "number" === typeof input.coordinates[0][2][0] && "number" === typeof input.coordinates[0][2][1] && "number" === typeof input.coordinates[0][2][2])) && (Array.isArray(input.coordinates[0][3]) && (input.coordinates[0][3].length === 3 && "number" === typeof input.coordinates[0][3][0] && "number" === typeof input.coordinates[0][3][1] && "number" === typeof input.coordinates[0][3][2])) && (Array.isArray(input.coordinates[0].slice(4)) && input.coordinates[0].slice(4).every((elem: any) => Array.isArray(elem) && (elem.length === 3 && "number" === typeof elem[0] && "number" === typeof elem[1] && "number" === typeof elem[2])))))));
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometry3d => {
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["Polygon" === input.type || $report(_exceptionable, {
                    path: _path + ".type",
                    expected: "\"Polygon\"",
                    value: input.type
                }), (Array.isArray(input.coordinates) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })) && ((input.coordinates.length === 1 || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "[PolygonCoordinatesRing<Coordinate3d>]",
                    value: input.coordinates
                })) && [
                    (Array.isArray(input.coordinates[0]) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })) && ([
                        (Array.isArray(input.coordinates[0][0]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        })) && ((input.coordinates[0][0].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][0]
                        })) && [
                            "number" === typeof input.coordinates[0][0][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][0]",
                                expected: "number",
                                value: input.coordinates[0][0][0]
                            }),
                            "number" === typeof input.coordinates[0][0][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][1]",
                                expected: "number",
                                value: input.coordinates[0][0][1]
                            }),
                            "number" === typeof input.coordinates[0][0][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][0][2]",
                                expected: "number",
                                value: input.coordinates[0][0][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][0]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][0]
                        }),
                        (Array.isArray(input.coordinates[0][1]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        })) && ((input.coordinates[0][1].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][1]
                        })) && [
                            "number" === typeof input.coordinates[0][1][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][0]",
                                expected: "number",
                                value: input.coordinates[0][1][0]
                            }),
                            "number" === typeof input.coordinates[0][1][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][1]",
                                expected: "number",
                                value: input.coordinates[0][1][1]
                            }),
                            "number" === typeof input.coordinates[0][1][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][1][2]",
                                expected: "number",
                                value: input.coordinates[0][1][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][1]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][1]
                        }),
                        (Array.isArray(input.coordinates[0][2]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        })) && ((input.coordinates[0][2].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][2]
                        })) && [
                            "number" === typeof input.coordinates[0][2][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][0]",
                                expected: "number",
                                value: input.coordinates[0][2][0]
                            }),
                            "number" === typeof input.coordinates[0][2][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][1]",
                                expected: "number",
                                value: input.coordinates[0][2][1]
                            }),
                            "number" === typeof input.coordinates[0][2][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][2][2]",
                                expected: "number",
                                value: input.coordinates[0][2][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][2]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][2]
                        }),
                        (Array.isArray(input.coordinates[0][3]) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })) && ((input.coordinates[0][3].length === 3 || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "[number, number, number]",
                            value: input.coordinates[0][3]
                        })) && [
                            "number" === typeof input.coordinates[0][3][0] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][0]",
                                expected: "number",
                                value: input.coordinates[0][3][0]
                            }),
                            "number" === typeof input.coordinates[0][3][1] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][1]",
                                expected: "number",
                                value: input.coordinates[0][3][1]
                            }),
                            "number" === typeof input.coordinates[0][3][2] || $report(_exceptionable, {
                                path: _path + ".coordinates[0][3][2]",
                                expected: "number",
                                value: input.coordinates[0][3][2]
                            })
                        ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                            path: _path + ".coordinates[0][3]",
                            expected: "Coordinate3d",
                            value: input.coordinates[0][3]
                        })
                    ].every((flag: boolean) => flag) && ((Array.isArray(input.coordinates[0].slice(4)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    })) && input.coordinates[0].slice(4).map((elem: any, _index1: number) => (Array.isArray(elem) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })) && ((elem.length === 3 || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "[number, number, number]",
                        value: elem
                    })) && [
                        "number" === typeof elem[0] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][0]",
                            expected: "number",
                            value: elem[0]
                        }),
                        "number" === typeof elem[1] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][1]",
                            expected: "number",
                            value: elem[1]
                        }),
                        "number" === typeof elem[2] || $report(_exceptionable, {
                            path: _path + ".coordinates[0][" + (4 + _index1) + "][2]",
                            expected: "number",
                            value: elem[2]
                        })
                    ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                        path: _path + ".coordinates[0][" + (4 + _index1) + "]",
                        expected: "Coordinate3d",
                        value: elem
                    })).every((flag: boolean) => flag) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "...Coordinate3d",
                        value: input.coordinates[0].slice(4)
                    }))) || $report(_exceptionable, {
                        path: _path + ".coordinates[0]",
                        expected: "PolygonCoordinatesRing<Coordinate3d>",
                        value: input.coordinates[0]
                    })
                ].every((flag: boolean) => flag)) || $report(_exceptionable, {
                    path: _path + ".coordinates",
                    expected: "PolygonCoordinates<Coordinate3d>",
                    value: input.coordinates
                })].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "PolygonGeometry3d",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// PolygonGeometryType
export const assertPolygonGeometryType = (input: any): PolygonGeometryType => {
    const __is = (input: any): input is PolygonGeometryType => {
        return "Polygon" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometryType => {
            const $guard = (typia.createAssert as any).guard;
            return "Polygon" === input || $guard(true, {
                path: _path + "",
                expected: "\"Polygon\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsPolygonGeometryType = (input: any, _exceptionable: boolean = true): input is PolygonGeometryType => {
    return "Polygon" === input;
};
export const isPolygonGeometryType = (input: any): input is PolygonGeometryType => {
    return "Polygon" === input;
};
export const randomPolygonGeometryType = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<PolygonGeometryType> => {
    return "Polygon";
};
export const stringifyPolygonGeometryType = (input: PolygonGeometryType): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"Polygon\"",
            value: input
        });
    })();
};
export const validatePolygonGeometryType = (input: any): typia.IValidation<PolygonGeometryType> => {
    const errors = [] as any[];
    const __is = (input: any): input is PolygonGeometryType => {
        return "Polygon" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is PolygonGeometryType => {
            return "Polygon" === input || $report(true, {
                path: _path + "",
                expected: "\"Polygon\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// SimpleStyleProperties
export const assertSimpleStyleProperties = (input: any): SimpleStyleProperties => {
    const __is = (input: any): input is SimpleStyleProperties => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is SimpleStyleProperties => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => (undefined === input.title || "string" === typeof input.title || $guard(_exceptionable, {
                path: _path + ".title",
                expected: "(string | undefined)",
                value: input.title
            })) && (undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(string | undefined)",
                value: input.description
            })) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"] || $guard(_exceptionable, {
                path: _path + "[\"marker-size\"]",
                expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
                value: input["marker-size"]
            })) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"] || $guard(_exceptionable, {
                path: _path + "[\"marker-symbol\"]",
                expected: "(string | undefined)",
                value: input["marker-symbol"]
            })) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"] || $guard(_exceptionable, {
                path: _path + "[\"marker-color\"]",
                expected: "(string | undefined)",
                value: input["marker-color"]
            })) && (undefined === input.stroke || "string" === typeof input.stroke || $guard(_exceptionable, {
                path: _path + ".stroke",
                expected: "(string | undefined)",
                value: input.stroke
            })) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"] || $guard(_exceptionable, {
                path: _path + "[\"stroke-opacity\"]",
                expected: "(number | undefined)",
                value: input["stroke-opacity"]
            })) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"] || $guard(_exceptionable, {
                path: _path + "[\"stroke-width\"]",
                expected: "(number | undefined)",
                value: input["stroke-width"]
            })) && (undefined === input.fill || "string" === typeof input.fill || $guard(_exceptionable, {
                path: _path + ".fill",
                expected: "(string | undefined)",
                value: input.fill
            })) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"] || $guard(_exceptionable, {
                path: _path + "[\"fill-opacity\"]",
                expected: "(number | undefined)",
                value: input["fill-opacity"]
            })) && (false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return true;
                return true;
            }));
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsSimpleStyleProperties = (input: any, _exceptionable: boolean = true): input is SimpleStyleProperties => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
        if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return false;
    });
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input, true);
};
export const isSimpleStyleProperties = (input: any): input is SimpleStyleProperties => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return true;
        return true;
    });
    return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
};
export const randomSimpleStyleProperties = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<SimpleStyleProperties> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {
            title: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            description: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "marker-size": $pick([
                () => undefined,
                () => "small",
                () => "medium",
                () => "large"
            ])(),
            "marker-symbol": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "marker-color": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            stroke: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "stroke-opacity": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            "stroke-width": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])(),
            fill: $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
            ])(),
            "fill-opacity": $pick([
                () => undefined,
                () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
            ])()
        } as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = "fucking any type exists...", (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifySimpleStyleProperties = (input: SimpleStyleProperties): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $tail = (typia.createStringify as any).tail;
    const $so0 = (input: any): any => `{${$tail(`${undefined === input.title ? "" : `"title":${undefined !== input.title ? $string(input.title) : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? $string(input.description) : undefined},`}${undefined === input["marker-size"] ? "" : `"marker-size":${undefined !== input["marker-size"] ? (() => {
        if ("string" === typeof input["marker-size"])
            return $string(input["marker-size"]);
        if ("string" === typeof input["marker-size"])
            return "\"" + input["marker-size"] + "\"";
        $throws({
            expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
            value: input["marker-size"]
        });
    })() : undefined},`}${undefined === input["marker-symbol"] ? "" : `"marker-symbol":${undefined !== input["marker-symbol"] ? $string(input["marker-symbol"]) : undefined},`}${undefined === input["marker-color"] ? "" : `"marker-color":${undefined !== input["marker-color"] ? $string(input["marker-color"]) : undefined},`}${undefined === input.stroke ? "" : `"stroke":${undefined !== input.stroke ? $string(input.stroke) : undefined},`}${undefined === input["stroke-opacity"] ? "" : `"stroke-opacity":${undefined !== input["stroke-opacity"] ? input["stroke-opacity"] : undefined},`}${undefined === input["stroke-width"] ? "" : `"stroke-width":${undefined !== input["stroke-width"] ? input["stroke-width"] : undefined},`}${undefined === input.fill ? "" : `"fill":${undefined !== input.fill ? $string(input.fill) : undefined},`}${undefined === input["fill-opacity"] ? "" : `"fill-opacity":${undefined !== input["fill-opacity"] ? input["fill-opacity"] : undefined},`}${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; if (["title", "description", "marker-size", "marker-symbol", "marker-color", "stroke", "stroke-opacity", "stroke-width", "fill", "fill-opacity"].some((regular: any) => regular === key))
        return ""; return `${JSON.stringify(key)}:${undefined !== value ? JSON.stringify(value) : undefined}`; }).filter((str: any) => "" !== str).join(",")}`)}}`;
    return $so0(input);
};
export const validateSimpleStyleProperties = (input: any): typia.IValidation<SimpleStyleProperties> => {
    const errors = [] as any[];
    const __is = (input: any): input is SimpleStyleProperties => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => (undefined === input.title || "string" === typeof input.title) && (undefined === input.description || "string" === typeof input.description) && (undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"]) && (undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"]) && (undefined === input["marker-color"] || "string" === typeof input["marker-color"]) && (undefined === input.stroke || "string" === typeof input.stroke) && (undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"]) && (undefined === input["stroke-width"] || "number" === typeof input["stroke-width"]) && (undefined === input.fill || "string" === typeof input.fill) && (undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"]) && Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return true;
            return true;
        });
        return "object" === typeof input && null !== input && false === Array.isArray(input) && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is SimpleStyleProperties => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [undefined === input.title || "string" === typeof input.title || $report(_exceptionable, {
                    path: _path + ".title",
                    expected: "(string | undefined)",
                    value: input.title
                }), undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(string | undefined)",
                    value: input.description
                }), undefined === input["marker-size"] || "small" === input["marker-size"] || "medium" === input["marker-size"] || "large" === input["marker-size"] || $report(_exceptionable, {
                    path: _path + "[\"marker-size\"]",
                    expected: "(\"large\" | \"medium\" | \"small\" | undefined)",
                    value: input["marker-size"]
                }), undefined === input["marker-symbol"] || "string" === typeof input["marker-symbol"] || $report(_exceptionable, {
                    path: _path + "[\"marker-symbol\"]",
                    expected: "(string | undefined)",
                    value: input["marker-symbol"]
                }), undefined === input["marker-color"] || "string" === typeof input["marker-color"] || $report(_exceptionable, {
                    path: _path + "[\"marker-color\"]",
                    expected: "(string | undefined)",
                    value: input["marker-color"]
                }), undefined === input.stroke || "string" === typeof input.stroke || $report(_exceptionable, {
                    path: _path + ".stroke",
                    expected: "(string | undefined)",
                    value: input.stroke
                }), undefined === input["stroke-opacity"] || "number" === typeof input["stroke-opacity"] || $report(_exceptionable, {
                    path: _path + "[\"stroke-opacity\"]",
                    expected: "(number | undefined)",
                    value: input["stroke-opacity"]
                }), undefined === input["stroke-width"] || "number" === typeof input["stroke-width"] || $report(_exceptionable, {
                    path: _path + "[\"stroke-width\"]",
                    expected: "(number | undefined)",
                    value: input["stroke-width"]
                }), undefined === input.fill || "string" === typeof input.fill || $report(_exceptionable, {
                    path: _path + ".fill",
                    expected: "(string | undefined)",
                    value: input.fill
                }), undefined === input["fill-opacity"] || "number" === typeof input["fill-opacity"] || $report(_exceptionable, {
                    path: _path + "[\"fill-opacity\"]",
                    expected: "(number | undefined)",
                    value: input["fill-opacity"]
                }), false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return true;
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input && false === Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "SimpleStyleProperties",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300
export const assertTilejson300 = (input: any): Tilejson300 => {
    const __is = (input: any): input is Tilejson300 => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $iu0 = (input: any): any => (() => {
            if ("pbf" === input.format)
                return $io3(input);
            if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300 => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input.format
            })) && (undefined === input.vector_layers || (Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "(TilejsonVectorLayers | undefined)",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "(TilejsonVectorLayers | undefined)",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            const $ao3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "\"pbf\"",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index7: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index7 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index7 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index7 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index8: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index8 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index9: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index9 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index10: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index10 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index11: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index11 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index12: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index12 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $au0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("pbf" === input.format)
                    return $ao3(input, _path, true && _exceptionable);
                if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                    return $ao0(input, _path, true && _exceptionable);
                return $guard(_exceptionable, {
                    path: _path,
                    expected: "(Tilejson300Vector | Tilejson300Raster)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            })) && $au0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300 = (input: any, _exceptionable: boolean = true): input is Tilejson300 => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (4 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    const $io3 = (input: any, _exceptionable: boolean = true): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index7: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index8: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index9: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index10: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index11: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index12: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $iu0 = (input: any, _exceptionable: boolean = true): any => (() => {
        if ("pbf" === input.format)
            return $io3(input, true && _exceptionable);
        if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $io0(input, true && _exceptionable);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input, true);
};
export const isTilejson300 = (input: any): input is Tilejson300 => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $iu0 = (input: any): any => (() => {
        if ("pbf" === input.format)
            return $io3(input);
        if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $io0(input);
        return false;
    })();
    return "object" === typeof input && null !== input && $iu0(input);
};
export const randomTilejson300 = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Tilejson300> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp"
        ])(),
        vector_layers: $pick([
            () => undefined,
            () => (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
        ])(),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    const $ro3 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: "pbf",
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    return $pick([
        () => $ro3(),
        () => $ro0()
    ])();
};
export const stringifyTilejson300 = (input: Tilejson300): string => {
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.vector_layers ? "" : `"vector_layers":${undefined !== input.vector_layers ? `[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]` : undefined},`}${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    const $so3 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $su0 = (input: any): any => (() => {
        if ("pbf" === input.format)
            return $so3(input);
        if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
            return $so0(input);
        $throws({
            expected: "(Tilejson300Vector | Tilejson300Raster)",
            value: input
        });
    })();
    return $su0(input);
};
export const validateTilejson300 = (input: any): typia.IValidation<Tilejson300> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300 => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        const $io3 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $iu0 = (input: any): any => (() => {
            if ("pbf" === input.format)
                return $io3(input);
            if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                return $io0(input);
            return false;
        })();
        return "object" === typeof input && null !== input && $iu0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300 => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["png" === input.format || "jpg" === input.format || "webp" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"png\" | \"webp\")",
                    value: input.format
                }), undefined === input.vector_layers || (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "(TilejsonVectorLayers | undefined)",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "(TilejsonVectorLayers | undefined)",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            const $vo3 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "\"pbf\"",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index7: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index7 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index7 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index7 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index8: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index8 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index9: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index9 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index10: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index10 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index11: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index11 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index12: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index12 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vu0 = (input: any, _path: string, _exceptionable: boolean = true): any => (() => {
                if ("pbf" === input.format)
                    return $vo3(input, _path, true && _exceptionable);
                if ("png" === input.format || "jpg" === input.format || "webp" === input.format)
                    return $vo0(input, _path, true && _exceptionable);
                return $report(_exceptionable, {
                    path: _path,
                    expected: "(Tilejson300Vector | Tilejson300Raster)",
                    value: input
                });
            })();
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            })) && $vu0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "(Tilejson300Raster | Tilejson300Vector)",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300Raster
export const assertTilejson300Raster = (input: any): Tilejson300Raster => {
    const __is = (input: any): input is Tilejson300Raster => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Raster => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input.format
            })) && (undefined === input.vector_layers || (Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "(TilejsonVectorLayers | undefined)",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "(TilejsonVectorLayers | undefined)",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300Raster = (input: any, _exceptionable: boolean = true): input is Tilejson300Raster => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (4 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejson300Raster = (input: any): input is Tilejson300Raster => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejson300Raster = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Tilejson300Raster> => {
    const $pick = (typia.createRandom as any).pick;
    const $generator = (typia.createRandom as any).generator;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp"
        ])(),
        vector_layers: $pick([
            () => undefined,
            () => (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth))
        ])(),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejson300Raster = (input: Tilejson300Raster): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.vector_layers ? "" : `"vector_layers":${undefined !== input.vector_layers ? `[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]` : undefined},`}${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejson300Raster = (input: any): typia.IValidation<Tilejson300Raster> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300Raster => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => ("png" === input.format || "jpg" === input.format || "webp" === input.format) && (undefined === input.vector_layers || Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Raster => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["png" === input.format || "jpg" === input.format || "webp" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"png\" | \"webp\")",
                    value: input.format
                }), undefined === input.vector_layers || (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "(TilejsonVectorLayers | undefined)",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "(TilejsonVectorLayers | undefined)",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Tilejson300Raster",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// Tilejson300Vector
export const assertTilejson300Vector = (input: any): Tilejson300Vector => {
    const __is = (input: any): input is Tilejson300Vector => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Vector => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "\"pbf\"",
                value: input.format
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index2 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejson300Vector = (input: any, _exceptionable: boolean = true): input is Tilejson300Vector => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index2: number) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["format", "vector_layers", "name", "tilejson", "tiles", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejson300Vector = (input: any): input is Tilejson300Vector => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejson300Vector = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<Tilejson300Vector> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        format: "pbf",
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejson300Vector = (input: Tilejson300Vector): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input.format
        });
    })()},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`},"name":${$string(input.name)},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejson300Vector = (input: any): typia.IValidation<Tilejson300Vector> => {
    const errors = [] as any[];
    const __is = (input: any): input is Tilejson300Vector => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "pbf" === input.format && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && "string" === typeof input.name && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is Tilejson300Vector => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "\"pbf\"",
                    value: input.format
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index1 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index1 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), "string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index2: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index2 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "Tilejson300Vector",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonCommon
export const assertTilejsonCommon = (input: any): TilejsonCommon => {
    const __is = (input: any): input is TilejsonCommon => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonCommon => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.name || $guard(_exceptionable, {
                path: _path + ".name",
                expected: "string",
                value: input.name
            })) && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format || $guard(_exceptionable, {
                path: _path + ".format",
                expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
                value: input.format
            })) && ("string" === typeof input.tilejson || $guard(_exceptionable, {
                path: _path + ".tilejson",
                expected: "string",
                value: input.tilejson
            })) && ((Array.isArray(input.tiles) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".tiles[" + _index1 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".tiles",
                expected: "Array<string>",
                value: input.tiles
            })) && ((Array.isArray(input.vector_layers) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && input.vector_layers.every((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index2 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao1(elem, _path + ".vector_layers[" + _index2 + "]", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".vector_layers[" + _index2 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".vector_layers",
                expected: "TilejsonVectorLayers",
                value: input.vector_layers
            })) && (null === input.version || undefined === input.version || "string" === typeof input.version || $guard(_exceptionable, {
                path: _path + ".version",
                expected: "(null | string | undefined)",
                value: input.version
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".bounds[" + _index3 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".bounds",
                expected: "(Array<number> | null | undefined)",
                value: input.bounds
            })) && (null === input.center || undefined === input.center || (Array.isArray(input.center) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && input.center.every((elem: any, _index4: number) => "number" === typeof elem || $guard(_exceptionable, {
                path: _path + ".center[" + _index4 + "]",
                expected: "number",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".center",
                expected: "(Array<number> | null | undefined)",
                value: input.center
            })) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $guard(_exceptionable, {
                path: _path + ".attribution",
                expected: "(null | string | undefined)",
                value: input.attribution
            })) && (null === input.template || undefined === input.template || "string" === typeof input.template || $guard(_exceptionable, {
                path: _path + ".template",
                expected: "(null | string | undefined)",
                value: input.template
            })) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $guard(_exceptionable, {
                path: _path + ".scheme",
                expected: "(null | string | undefined)",
                value: input.scheme
            })) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend || $guard(_exceptionable, {
                path: _path + ".legend",
                expected: "(null | string | undefined)",
                value: input.legend
            })) && (null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".grids[" + _index5 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".grids",
                expected: "(Array<string> | null | undefined)",
                value: input.grids
            })) && (null === input.data || undefined === input.data || (Array.isArray(input.data) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && input.data.every((elem: any, _index6: number) => "string" === typeof elem || $guard(_exceptionable, {
                path: _path + ".data[" + _index6 + "]",
                expected: "string",
                value: elem
            })) || $guard(_exceptionable, {
                path: _path + ".data",
                expected: "(Array<string> | null | undefined)",
                value: input.data
            })) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $guard(_exceptionable, {
                path: _path + ".fillzoom",
                expected: "(null | number | undefined)",
                value: input.fillzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao2(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonCommon = (input: any, _exceptionable: boolean = true): input is TilejsonCommon => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any, _index1: number) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any, _index2: number) => "object" === typeof elem && null !== elem && $io1(elem, true && _exceptionable))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any, _index3: number) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any, _index4: number) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any, _index5: number) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any, _index6: number) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom) && (5 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["name", "format", "tilejson", "tiles", "vector_layers", "version", "description", "minzoom", "maxzoom", "bounds", "center", "attribution", "template", "scheme", "legend", "grids", "data", "fillzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io2 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejsonCommon = (input: any): input is TilejsonCommon => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejsonCommon = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<TilejsonCommon> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        name: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        format: $pick([
            () => "png",
            () => "jpg",
            () => "webp",
            () => "pbf"
        ])(),
        tilejson: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        tiles: (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()),
        vector_layers: (generator?.array ?? $generator.array)(() => $ro1(_recursive, _recursive ? 1 + _depth : _depth)),
        version: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        bounds: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        center: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100))
        ])(),
        attribution: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        template: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        scheme: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        legend: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        grids: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        data: $pick([
            () => undefined,
            () => null,
            () => (generator?.array ?? $generator.array)(() => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)())
        ])(),
        fillzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro2(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro2 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejsonCommon = (input: TilejsonCommon): string => {
    const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.version ? "" : `"version":${undefined !== input.version ? null !== input.version ? $string(input.version) : "null" : undefined},`}${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.bounds ? "" : `"bounds":${undefined !== input.bounds ? null !== input.bounds ? `[${input.bounds.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.center ? "" : `"center":${undefined !== input.center ? null !== input.center ? `[${input.center.map((elem: any) => elem).join(",")}]` : "null" : undefined},`}${undefined === input.attribution ? "" : `"attribution":${undefined !== input.attribution ? null !== input.attribution ? $string(input.attribution) : "null" : undefined},`}${undefined === input.template ? "" : `"template":${undefined !== input.template ? null !== input.template ? $string(input.template) : "null" : undefined},`}${undefined === input.scheme ? "" : `"scheme":${undefined !== input.scheme ? null !== input.scheme ? $string(input.scheme) : "null" : undefined},`}${undefined === input.legend ? "" : `"legend":${undefined !== input.legend ? null !== input.legend ? $string(input.legend) : "null" : undefined},`}${undefined === input.grids ? "" : `"grids":${undefined !== input.grids ? null !== input.grids ? `[${input.grids.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.data ? "" : `"data":${undefined !== input.data ? null !== input.data ? `[${input.data.map((elem: any) => $string(elem)).join(",")}]` : "null" : undefined},`}${undefined === input.fillzoom ? "" : `"fillzoom":${undefined !== input.fillzoom ? null !== input.fillzoom ? input.fillzoom : "null" : undefined},`}"name":${$string(input.name)},"format":${(() => {
        if ("string" === typeof input.format)
            return $string(input.format);
        if ("string" === typeof input.format)
            return "\"" + input.format + "\"";
        $throws({
            expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
            value: input.format
        });
    })()},"tilejson":${$string(input.tilejson)},"tiles":${`[${input.tiles.map((elem: any) => $string(elem)).join(",")}]`},"vector_layers":${`[${input.vector_layers.map((elem: any) => $so1(elem)).join(",")}]`}}`;
    const $so1 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so2(input.fields)}}`;
    const $so2 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejsonCommon = (input: any): typia.IValidation<TilejsonCommon> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonCommon => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.name && ("png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format) && "string" === typeof input.tilejson && (Array.isArray(input.tiles) && input.tiles.every((elem: any) => "string" === typeof elem)) && (Array.isArray(input.vector_layers) && input.vector_layers.every((elem: any) => "object" === typeof elem && null !== elem && $io1(elem))) && (null === input.version || undefined === input.version || "string" === typeof input.version) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.bounds || undefined === input.bounds || Array.isArray(input.bounds) && input.bounds.every((elem: any) => "number" === typeof elem)) && (null === input.center || undefined === input.center || Array.isArray(input.center) && input.center.every((elem: any) => "number" === typeof elem)) && (null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution) && (null === input.template || undefined === input.template || "string" === typeof input.template) && (null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme) && (null === input.legend || undefined === input.legend || "string" === typeof input.legend) && (null === input.grids || undefined === input.grids || Array.isArray(input.grids) && input.grids.every((elem: any) => "string" === typeof elem)) && (null === input.data || undefined === input.data || Array.isArray(input.data) && input.data.every((elem: any) => "string" === typeof elem)) && (null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom);
        const $io1 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io2(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io2 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonCommon => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.name || $report(_exceptionable, {
                    path: _path + ".name",
                    expected: "string",
                    value: input.name
                }), "png" === input.format || "jpg" === input.format || "webp" === input.format || "pbf" === input.format || $report(_exceptionable, {
                    path: _path + ".format",
                    expected: "(\"jpg\" | \"pbf\" | \"png\" | \"webp\")",
                    value: input.format
                }), "string" === typeof input.tilejson || $report(_exceptionable, {
                    path: _path + ".tilejson",
                    expected: "string",
                    value: input.tilejson
                }), (Array.isArray(input.tiles) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                })) && input.tiles.map((elem: any, _index1: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".tiles[" + _index1 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".tiles",
                    expected: "Array<string>",
                    value: input.tiles
                }), (Array.isArray(input.vector_layers) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                })) && input.vector_layers.map((elem: any, _index2: number) => ("object" === typeof elem && null !== elem || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index2 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })) && $vo1(elem, _path + ".vector_layers[" + _index2 + "]", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".vector_layers[" + _index2 + "]",
                    expected: "TilejsonVectorLayer",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".vector_layers",
                    expected: "TilejsonVectorLayers",
                    value: input.vector_layers
                }), null === input.version || undefined === input.version || "string" === typeof input.version || $report(_exceptionable, {
                    path: _path + ".version",
                    expected: "(null | string | undefined)",
                    value: input.version
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.bounds || undefined === input.bounds || (Array.isArray(input.bounds) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                })) && input.bounds.map((elem: any, _index3: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".bounds[" + _index3 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".bounds",
                    expected: "(Array<number> | null | undefined)",
                    value: input.bounds
                }), null === input.center || undefined === input.center || (Array.isArray(input.center) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                })) && input.center.map((elem: any, _index4: number) => "number" === typeof elem || $report(_exceptionable, {
                    path: _path + ".center[" + _index4 + "]",
                    expected: "number",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".center",
                    expected: "(Array<number> | null | undefined)",
                    value: input.center
                }), null === input.attribution || undefined === input.attribution || "string" === typeof input.attribution || $report(_exceptionable, {
                    path: _path + ".attribution",
                    expected: "(null | string | undefined)",
                    value: input.attribution
                }), null === input.template || undefined === input.template || "string" === typeof input.template || $report(_exceptionable, {
                    path: _path + ".template",
                    expected: "(null | string | undefined)",
                    value: input.template
                }), null === input.scheme || undefined === input.scheme || "string" === typeof input.scheme || $report(_exceptionable, {
                    path: _path + ".scheme",
                    expected: "(null | string | undefined)",
                    value: input.scheme
                }), null === input.legend || undefined === input.legend || "string" === typeof input.legend || $report(_exceptionable, {
                    path: _path + ".legend",
                    expected: "(null | string | undefined)",
                    value: input.legend
                }), null === input.grids || undefined === input.grids || (Array.isArray(input.grids) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                })) && input.grids.map((elem: any, _index5: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".grids[" + _index5 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".grids",
                    expected: "(Array<string> | null | undefined)",
                    value: input.grids
                }), null === input.data || undefined === input.data || (Array.isArray(input.data) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                })) && input.data.map((elem: any, _index6: number) => "string" === typeof elem || $report(_exceptionable, {
                    path: _path + ".data[" + _index6 + "]",
                    expected: "string",
                    value: elem
                })).every((flag: boolean) => flag) || $report(_exceptionable, {
                    path: _path + ".data",
                    expected: "(Array<string> | null | undefined)",
                    value: input.data
                }), null === input.fillzoom || undefined === input.fillzoom || "number" === typeof input.fillzoom || $report(_exceptionable, {
                    path: _path + ".fillzoom",
                    expected: "(null | number | undefined)",
                    value: input.fillzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo2(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo2 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "TilejsonCommon",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonRasterFormat
export const assertTilejsonRasterFormat = (input: any): TilejsonRasterFormat => {
    const __is = (input: any): input is TilejsonRasterFormat => {
        return "png" === input || "jpg" === input || "webp" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
            const $guard = (typia.createAssert as any).guard;
            return "png" === input || "jpg" === input || "webp" === input || $guard(true, {
                path: _path + "",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonRasterFormat = (input: any, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
    return "png" === input || "jpg" === input || "webp" === input;
};
export const isTilejsonRasterFormat = (input: any): input is TilejsonRasterFormat => {
    return "png" === input || "jpg" === input || "webp" === input;
};
export const randomTilejsonRasterFormat = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<TilejsonRasterFormat> => {
    const $pick = (typia.createRandom as any).pick;
    return $pick([
        () => "png",
        () => "jpg",
        () => "webp"
    ])();
};
export const stringifyTilejsonRasterFormat = (input: TilejsonRasterFormat): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "(\"jpg\" | \"png\" | \"webp\")",
            value: input
        });
    })();
};
export const validateTilejsonRasterFormat = (input: any): typia.IValidation<TilejsonRasterFormat> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonRasterFormat => {
        return "png" === input || "jpg" === input || "webp" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonRasterFormat => {
            return "png" === input || "jpg" === input || "webp" === input || $report(true, {
                path: _path + "",
                expected: "(\"jpg\" | \"png\" | \"webp\")",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorFormat
export const assertTilejsonVectorFormat = (input: any): TilejsonVectorFormat => {
    const __is = (input: any): input is TilejsonVectorFormat => {
        return "pbf" === input;
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
            const $guard = (typia.createAssert as any).guard;
            return "pbf" === input || $guard(true, {
                path: _path + "",
                expected: "\"pbf\"",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorFormat = (input: any, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
    return "pbf" === input;
};
export const isTilejsonVectorFormat = (input: any): input is TilejsonVectorFormat => {
    return "pbf" === input;
};
export const randomTilejsonVectorFormat = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<TilejsonVectorFormat> => {
    return "pbf";
};
export const stringifyTilejsonVectorFormat = (input: TilejsonVectorFormat): string => {
    const $string = (typia.createStringify as any).string;
    const $throws = (typia.createStringify as any).throws;
    return (() => {
        if ("string" === typeof input)
            return $string(input);
        if ("string" === typeof input)
            return "\"" + input + "\"";
        $throws({
            expected: "\"pbf\"",
            value: input
        });
    })();
};
export const validateTilejsonVectorFormat = (input: any): typia.IValidation<TilejsonVectorFormat> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorFormat => {
        return "pbf" === input;
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorFormat => {
            return "pbf" === input || $report(true, {
                path: _path + "",
                expected: "\"pbf\"",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorLayer
export const assertTilejsonVectorLayer = (input: any): TilejsonVectorLayer => {
    const __is = (input: any): input is TilejsonVectorLayer => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao1(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return ("object" === typeof input && null !== input || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            })) && $ao0(input, _path + "", true) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorLayer = (input: any, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return "object" === typeof input && null !== input && $io0(input, true);
};
export const isTilejsonVectorLayer = (input: any): input is TilejsonVectorLayer => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return "object" === typeof input && null !== input && $io0(input);
};
export const randomTilejsonVectorLayer = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<TilejsonVectorLayer> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return $ro0();
};
export const stringifyTilejsonVectorLayer = (input: TilejsonVectorLayer): string => {
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so1(input.fields)}}`;
    const $so1 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return $so0(input);
};
export const validateTilejsonVectorLayer = (input: any): typia.IValidation<TilejsonVectorLayer> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorLayer => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return "object" === typeof input && null !== input && $io0(input);
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayer => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo1(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return ("object" === typeof input && null !== input || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            })) && $vo0(input, _path + "", true) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayer",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
// TilejsonVectorLayers
export const assertTilejsonVectorLayers = (input: any): TilejsonVectorLayers => {
    const __is = (input: any): input is TilejsonVectorLayers => {
        const $join = (typia.createAssert as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input))
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
            const $guard = (typia.createAssert as any).guard;
            const $join = (typia.createAssert as any).join;
            const $ao0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ("string" === typeof input.id || $guard(_exceptionable, {
                path: _path + ".id",
                expected: "string",
                value: input.id
            })) && (("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && $ao1(input.fields, _path + ".fields", true && _exceptionable) || $guard(_exceptionable, {
                path: _path + ".fields",
                expected: "Record<string, string>",
                value: input.fields
            })) && (null === input.description || undefined === input.description || "string" === typeof input.description || $guard(_exceptionable, {
                path: _path + ".description",
                expected: "(null | string | undefined)",
                value: input.description
            })) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $guard(_exceptionable, {
                path: _path + ".maxzoom",
                expected: "(null | number | undefined)",
                value: input.maxzoom
            })) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $guard(_exceptionable, {
                path: _path + ".minzoom",
                expected: "(null | number | undefined)",
                value: input.minzoom
            }));
            const $ao1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => false === _exceptionable || Object.keys(input).every((key: any) => {
                const value = input[key];
                if (undefined === value)
                    return true;
                if (RegExp(/(.*)/).test(key))
                    return "string" === typeof value || $guard(_exceptionable, {
                        path: _path + $join(key),
                        expected: "string",
                        value: value
                    });
                return true;
            });
            return (Array.isArray(input) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            })) && input.every((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $ao0(elem, _path + "[" + _index1 + "]", true) || $guard(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) || $guard(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            });
        })(input, "$input", true);
    return input;
};
export const equalsTilejsonVectorLayers = (input: any, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
    const $join = (typia.createEquals as any).join;
    const $io0 = (input: any, _exceptionable: boolean = true): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields, true && _exceptionable)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom) && (2 === Object.keys(input).length || Object.keys(input).every((key: any) => {
        if (["id", "fields", "description", "maxzoom", "minzoom"].some((prop: any) => key === prop))
            return true;
        const value = input[key];
        if (undefined === value)
            return true;
        return false;
    }));
    const $io1 = (input: any, _exceptionable: boolean = true): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return false;
    });
    return Array.isArray(input) && input.every((elem: any, _index1: number) => "object" === typeof elem && null !== elem && $io0(elem, true));
};
export const isTilejsonVectorLayers = (input: any): input is TilejsonVectorLayers => {
    const $join = (typia.createIs as any).join;
    const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
};
export const randomTilejsonVectorLayers = (generator?: Partial<typia.IRandomGenerator>): typia.Primitive<TilejsonVectorLayers> => {
    const $generator = (typia.createRandom as any).generator;
    const $pick = (typia.createRandom as any).pick;
    const $ro0 = (_recursive: boolean = false, _depth: number = 0): any => ({
        id: (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(),
        fields: $ro1(_recursive, _recursive ? 1 + _depth : _depth),
        description: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()
        ])(),
        maxzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])(),
        minzoom: $pick([
            () => undefined,
            () => null,
            () => (generator?.customs ?? $generator.customs)?.number?.([]) ?? (generator?.number ?? $generator.number)(0, 100)
        ])()
    });
    const $ro1 = (_recursive: boolean = false, _depth: number = 0): any => {
        const output = {} as any;
        (generator?.array ?? $generator.array)(() => output[(generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)()] = (generator?.customs ?? $generator.customs)?.string?.([]) ?? (generator?.string ?? $generator.string)(), (generator?.integer ?? $generator.integer)(0, 3));
        return output;
    };
    return (generator?.array ?? $generator.array)(() => $ro0());
};
export const stringifyTilejsonVectorLayers = (input: TilejsonVectorLayers): string => {
    const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
        const value = input[key];
        if (undefined === value)
            return true;
        if (RegExp(/(.*)/).test(key))
            return "string" === typeof value;
        return true;
    });
    const $string = (typia.createStringify as any).string;
    const $join = (typia.createStringify as any).join;
    const $so0 = (input: any): any => `{${undefined === input.description ? "" : `"description":${undefined !== input.description ? null !== input.description ? $string(input.description) : "null" : undefined},`}${undefined === input.maxzoom ? "" : `"maxzoom":${undefined !== input.maxzoom ? null !== input.maxzoom ? input.maxzoom : "null" : undefined},`}${undefined === input.minzoom ? "" : `"minzoom":${undefined !== input.minzoom ? null !== input.minzoom ? input.minzoom : "null" : undefined},`}"id":${$string(input.id)},"fields":${$so1(input.fields)}}`;
    const $so1 = (input: any): any => `{${Object.entries(input).map(([key, value]: [string, any]) => { if (undefined === value)
        return ""; return `${JSON.stringify(key)}:${$string(value)}`; }).filter((str: any) => "" !== str).join(",")}}`;
    return `[${input.map((elem: any) => $so0(elem)).join(",")}]`;
};
export const validateTilejsonVectorLayers = (input: any): typia.IValidation<TilejsonVectorLayers> => {
    const errors = [] as any[];
    const __is = (input: any): input is TilejsonVectorLayers => {
        const $join = (typia.createValidate as any).join;
        const $io0 = (input: any): boolean => "string" === typeof input.id && ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) && $io1(input.fields)) && (null === input.description || undefined === input.description || "string" === typeof input.description) && (null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom) && (null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom);
        const $io1 = (input: any): boolean => Object.keys(input).every((key: any) => {
            const value = input[key];
            if (undefined === value)
                return true;
            if (RegExp(/(.*)/).test(key))
                return "string" === typeof value;
            return true;
        });
        return Array.isArray(input) && input.every((elem: any) => "object" === typeof elem && null !== elem && $io0(elem));
    };
    if (false === __is(input)) {
        const $report = (typia.createValidate as any).report(errors);
        ((input: any, _path: string, _exceptionable: boolean = true): input is TilejsonVectorLayers => {
            const $join = (typia.createValidate as any).join;
            const $vo0 = (input: any, _path: string, _exceptionable: boolean = true): boolean => ["string" === typeof input.id || $report(_exceptionable, {
                    path: _path + ".id",
                    expected: "string",
                    value: input.id
                }), ("object" === typeof input.fields && null !== input.fields && false === Array.isArray(input.fields) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                })) && $vo1(input.fields, _path + ".fields", true && _exceptionable) || $report(_exceptionable, {
                    path: _path + ".fields",
                    expected: "Record<string, string>",
                    value: input.fields
                }), null === input.description || undefined === input.description || "string" === typeof input.description || $report(_exceptionable, {
                    path: _path + ".description",
                    expected: "(null | string | undefined)",
                    value: input.description
                }), null === input.maxzoom || undefined === input.maxzoom || "number" === typeof input.maxzoom || $report(_exceptionable, {
                    path: _path + ".maxzoom",
                    expected: "(null | number | undefined)",
                    value: input.maxzoom
                }), null === input.minzoom || undefined === input.minzoom || "number" === typeof input.minzoom || $report(_exceptionable, {
                    path: _path + ".minzoom",
                    expected: "(null | number | undefined)",
                    value: input.minzoom
                })].every((flag: boolean) => flag);
            const $vo1 = (input: any, _path: string, _exceptionable: boolean = true): boolean => [false === _exceptionable || Object.keys(input).map((key: any) => {
                    const value = input[key];
                    if (undefined === value)
                        return true;
                    if (RegExp(/(.*)/).test(key))
                        return "string" === typeof value || $report(_exceptionable, {
                            path: _path + $join(key),
                            expected: "string",
                            value: value
                        });
                    return true;
                }).every((flag: boolean) => flag)].every((flag: boolean) => flag);
            return (Array.isArray(input) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            })) && input.map((elem: any, _index1: number) => ("object" === typeof elem && null !== elem || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })) && $vo0(elem, _path + "[" + _index1 + "]", true) || $report(true, {
                path: _path + "[" + _index1 + "]",
                expected: "TilejsonVectorLayer",
                value: elem
            })).every((flag: boolean) => flag) || $report(true, {
                path: _path + "",
                expected: "TilejsonVectorLayers",
                value: input
            });
        })(input, "$input", true);
    }
    const success = 0 === errors.length;
    return {
        success,
        errors,
        data: success ? input : undefined
    } as any;
};
